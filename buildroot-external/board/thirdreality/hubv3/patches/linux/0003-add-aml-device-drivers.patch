From f568d6bd7d309b4e1bb944a1f51ae2033b7fef90 Mon Sep 17 00:00:00 2001
From: "tianwei.ge" <gtweiiiii@gmail.com>
Date: Fri, 13 Dec 2024 15:26:25 +0800
Subject: [PATCH] add aml device drivers

---
 drivers/Kconfig                               |    2 +
 drivers/Makefile                              |    2 +
 drivers/amlogic/Kconfig                       |    7 +
 drivers/amlogic/Makefile                      |   25 +
 drivers/amlogic/mmc/Kconfig                   |    3 +
 drivers/amlogic/mmc/Makefile                  |    3 +
 drivers/amlogic/mmc/host/Kconfig              |   30 +
 drivers/amlogic/mmc/host/Makefile             |   17 +
 drivers/amlogic/mmc/host/meson-cqhci.c        |  199 +
 drivers/amlogic/mmc/host/meson-cqhci.h        |   59 +
 drivers/amlogic/mmc/host/meson-g12a-mmc.c     | 2854 +++++++++++
 drivers/amlogic/mmc/host/meson-gx-mmc.c       | 4236 +++++++++++++++++
 drivers/amlogic/mmc/host/meson-mmc-main.c     |   31 +
 drivers/amlogic/mmc/host/meson-mmc-main.h     |   15 +
 drivers/amlogic/mmc/host/mmc_common.h         |   33 +
 drivers/amlogic/mmc/host/mmc_dtb.c            |  460 ++
 drivers/amlogic/mmc/host/mmc_dtb.h            |   16 +
 drivers/amlogic/mmc/host/mmc_key.c            |  572 +++
 drivers/amlogic/mmc/host/mmc_key.h            |   72 +
 drivers/amlogic/wifi/Kconfig                  |   25 +
 drivers/amlogic/wifi/Makefile                 |    8 +
 drivers/amlogic/wifi/dhd_static_buf.c         |  659 +++
 drivers/amlogic/wifi/wifi_dt.c                | 1120 +++++
 include/linux/amlogic/aml_sd.h                |  543 +++
 include/linux/amlogic/cpu_version.h           |    6 +
 include/linux/amlogic/dhd_buf.h               |    9 +
 include/linux/amlogic/gki_module.h            |   98 +
 include/linux/amlogic/key_manage.h            |   29 +
 .../amlogic/media/registers/cpu_version.h     |  346 ++
 include/linux/amlogic/module_merge.h          |   21 +
 include/linux/amlogic/pm.h                    |   98 +
 include/linux/amlogic/wifi_dt.h               |   25 +
 32 files changed, 11623 insertions(+)
 create mode 100644 drivers/amlogic/Kconfig
 create mode 100644 drivers/amlogic/Makefile
 create mode 100644 drivers/amlogic/mmc/Kconfig
 create mode 100644 drivers/amlogic/mmc/Makefile
 create mode 100644 drivers/amlogic/mmc/host/Kconfig
 create mode 100644 drivers/amlogic/mmc/host/Makefile
 create mode 100644 drivers/amlogic/mmc/host/meson-cqhci.c
 create mode 100644 drivers/amlogic/mmc/host/meson-cqhci.h
 create mode 100644 drivers/amlogic/mmc/host/meson-g12a-mmc.c
 create mode 100644 drivers/amlogic/mmc/host/meson-gx-mmc.c
 create mode 100644 drivers/amlogic/mmc/host/meson-mmc-main.c
 create mode 100644 drivers/amlogic/mmc/host/meson-mmc-main.h
 create mode 100644 drivers/amlogic/mmc/host/mmc_common.h
 create mode 100644 drivers/amlogic/mmc/host/mmc_dtb.c
 create mode 100644 drivers/amlogic/mmc/host/mmc_dtb.h
 create mode 100644 drivers/amlogic/mmc/host/mmc_key.c
 create mode 100644 drivers/amlogic/mmc/host/mmc_key.h
 create mode 100644 drivers/amlogic/wifi/Kconfig
 create mode 100644 drivers/amlogic/wifi/Makefile
 create mode 100644 drivers/amlogic/wifi/dhd_static_buf.c
 create mode 100644 drivers/amlogic/wifi/wifi_dt.c
 create mode 100644 include/linux/amlogic/aml_sd.h
 create mode 100644 include/linux/amlogic/cpu_version.h
 create mode 100644 include/linux/amlogic/dhd_buf.h
 create mode 100644 include/linux/amlogic/gki_module.h
 create mode 100644 include/linux/amlogic/key_manage.h
 create mode 100644 include/linux/amlogic/media/registers/cpu_version.h
 create mode 100644 include/linux/amlogic/module_merge.h
 create mode 100644 include/linux/amlogic/pm.h
 create mode 100644 include/linux/amlogic/wifi_dt.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index efb66e25f..ae0950209 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -243,4 +243,6 @@ source "drivers/hte/Kconfig"
 
 source "drivers/cdx/Kconfig"
 
+source "drivers/amlogic/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 1bec7819a..81da6f963 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -199,3 +199,5 @@ obj-$(CONFIG_DRM_ACCEL)		+= accel/
 obj-$(CONFIG_CDX_BUS)		+= cdx/
 
 obj-$(CONFIG_S390)		+= s390/
+
+obj-y += amlogic/
diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
new file mode 100644
index 000000000..c35e094b0
--- /dev/null
+++ b/drivers/amlogic/Kconfig
@@ -0,0 +1,7 @@
+menu "Amlogic Device Drivers"
+
+# source "drivers/amlogic/bluetooth/Kconfig"
+source "drivers/amlogic/wifi/Kconfig"
+source "drivers/amlogic/mmc/Kconfig"
+
+endmenu
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
new file mode 100644
index 000000000..78bb55a1c
--- /dev/null
+++ b/drivers/amlogic/Makefile
@@ -0,0 +1,25 @@
+
+##########################################
+########## Amlogic Drivers ###############
+##########################################
+
+# obj-y              += bluetooth/
+obj-y              += wifi/
+obj-y              += mmc/
+
+KBUILD_CFLAGS_MODULE += $(GKI_EXT_MODULE_PREDEFINE)
+
+all:
+	@$(MAKE) -C $(KERNEL_SRC) M=$(M)  modules $(GKI_EXT_MODULE_CONFIG)
+
+modules_install:
+	@echo "$(MAKE) INSTALL_MOD_STRIP=1 M=$(M) -C $(KERNEL_SRC) modules_install"
+#       @$(MAKE) INSTALL_MOD_STRIP=1 M=$(M) -C $(KERNEL_SRC) modules_install
+#       mkdir -p ${OUT_DIR}/../vendor_lib/modules
+#       cd ${OUT_DIR}/$(M)/; find -name "*.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;
+	mkdir -p ${OUT_DIR}/../vendor_lib/modules
+	(cd ${OUT_DIR}/$(M)/; find -name "dvb_demux.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;)
+	(cd ${OUT_DIR}/$(M)/; find -name "aml_aucpu.ko" -exec cp {} ${OUT_DIR}/../vendor_lib/modules/ \;)
+
+clean:
+	$(MAKE) -C $(KERNEL_SRC) M=$(M) clean
diff --git a/drivers/amlogic/mmc/Kconfig b/drivers/amlogic/mmc/Kconfig
new file mode 100644
index 000000000..48b448019
--- /dev/null
+++ b/drivers/amlogic/mmc/Kconfig
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+source "drivers/amlogic/mmc/host/Kconfig"
diff --git a/drivers/amlogic/mmc/Makefile b/drivers/amlogic/mmc/Makefile
new file mode 100644
index 000000000..1039d1dec
--- /dev/null
+++ b/drivers/amlogic/mmc/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+obj-y		+= host/
diff --git a/drivers/amlogic/mmc/host/Kconfig b/drivers/amlogic/mmc/host/Kconfig
new file mode 100644
index 000000000..6809167dd
--- /dev/null
+++ b/drivers/amlogic/mmc/host/Kconfig
@@ -0,0 +1,30 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+config AMLOGIC_MMC_MESON_GX
+         tristate "Amlogic S905/GX*/AXG SD/MMC Host Controller support"
+         depends on MMC
+         help
+           This selects support for the Amlogic SD/MMC Host Controller
+           found on the S905/GX*/AXG family of SoCs.  This controller is
+           MMC 5.1 compliant and supports SD, eMMC and SDIO interfaces.
+           If you have a controller with this interface, say Y here.
+
+config AMLOGIC_MMC_CQHCI
+         tristate "Amlogic MMC CQHCI Host Controller support"
+         depends on MMC_CQHCI
+         help
+           This selects support for the Amlogic MMC CQHCI Host Controller
+           found on the P1/A5/T5M/*/ family of SoCs.  This controller is
+           MMC 5.1 compliant and supports SD, eMMC and SDIO interfaces.
+           If you have a controller with this interface, say Y here.
+
+config AMLOGIC_MMC_RPMB
+         tristate "Amlogic MMC RPMB support"
+         depends on MMC
+         help
+           This selects support for the Amlogic MMC RPMB found on the
+		   A4/A5 family of SoCs.  This controller is
+           MMC 5.1 compliant and supports eMMC interfaces.
+           If you have a controller with this interface, say Y here.
+
+
diff --git a/drivers/amlogic/mmc/host/Makefile b/drivers/amlogic/mmc/host/Makefile
new file mode 100644
index 000000000..2629a491d
--- /dev/null
+++ b/drivers/amlogic/mmc/host/Makefile
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+ccflags-y += -I$(srctree)/drivers/mmc/core
+#ccflags-y += -DDEBUG
+
+MODULE_NAME = amlogic-mmc
+obj-y = $(MODULE_NAME).o
+$(MODULE_NAME)-y = meson-mmc-main.o
+$(MODULE_NAME)-y += meson-gx-mmc.o
+$(MODULE_NAME)-y += meson-g12a-mmc.o
+$(MODULE_NAME)-y += mmc_dtb.o
+$(MODULE_NAME)-y += mmc_key.o
+$(MODULE_NAME)-$(CONFIG_AMLOGIC_MMC_CQHCI) += meson-cqhci.o
+
+PR_FMT = $(subst amlogic-,,$(MODULE_NAME))
+PR_FMT_DEFINE="-Dpr_fmt(fmt)= \"[$(PR_FMT)]: \" fmt"
+ccflags-y += $(PR_FMT_DEFINE)
diff --git a/drivers/amlogic/mmc/host/meson-cqhci.c b/drivers/amlogic/mmc/host/meson-cqhci.c
new file mode 100644
index 000000000..8e3b70abf
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-cqhci.c
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+#include <linux/platform_device.h>
+#include <linux/ktime.h>
+
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/amlogic/aml_sd.h>
+#include "meson-cqhci.h"
+
+bool aml_cqe_irq(struct meson_host *host, u32 intmask, int *cmd_error,
+		int *data_error)
+{
+	if (!host->mmc->cqe_on)
+		return false;
+
+	if (intmask & (IRQ_RXD_ERR_MASK | IRQ_TXD_ERR))
+		*data_error = -EILSEQ;
+	else if (intmask & IRQ_DESC_TIMEOUT)
+		*data_error = -ETIMEDOUT;
+	else if (intmask & IRQ_DESC_ERR)
+		*data_error = -EIO; /* indicate all ddr issue */
+	else
+		*data_error = 0;
+
+	if (intmask & (IRQ_RESP_ERR))
+		*cmd_error = -EILSEQ;
+	else if (intmask & IRQ_RESP_TIMEOUT)
+		*cmd_error = -ETIMEDOUT;
+	else
+		*cmd_error = 0;
+
+	writel(0x7fff, host->regs + SD_EMMC_STATUS);
+	if (*data_error || *cmd_error) {
+		dev_err(host->dev, "cmd_err[0x%x], data_err[0x%x],status[0x%x]\n",
+				*cmd_error, *data_error, intmask);
+		if (host->debug_flag) {
+			dev_notice(host->dev, "clktree : 0x%x,host_clock: 0x%x\n",
+				   readl(host->clk_tree_base),
+				   readl(host->regs));
+			dev_notice(host->dev, "adjust: 0x%x,cfg: 0x%x,intf3: 0x%x\n",
+				   readl(host->regs + SD_EMMC_V3_ADJUST),
+				   readl(host->regs + SD_EMMC_CFG),
+				   readl(host->regs + SD_EMMC_INTF3));
+			dev_notice(host->dev, "irq_en: 0x%x\n",
+				   readl(host->regs + 0x4c));
+			dev_notice(host->dev, "delay1: 0x%x,delay2: 0x%x\n",
+				   readl(host->regs + SD_EMMC_DELAY1),
+				   readl(host->regs + SD_EMMC_DELAY2));
+			dev_notice(host->dev, "pinmux: 0x%x\n",
+				   readl(host->pin_mux_base));
+		}
+	}
+	return true;
+}
+
+u32 aml_cqhci_irq(struct meson_host *host)
+{
+	int cmd_error = 0;
+	int data_error = 0;
+	u32 irq_en, raw_status, intmask;
+
+	irq_en = readl(host->regs + SD_EMMC_IRQ_EN);
+	raw_status = readl(host->regs + SD_EMMC_STATUS);
+	intmask = raw_status & irq_en;
+
+	if (!aml_cqe_irq(host, intmask, &cmd_error, &data_error))
+		return intmask;
+
+	cqhci_irq(host->mmc, intmask, cmd_error, data_error);
+
+	return 0;
+}
+
+void aml_cqhci_writel(struct cqhci_host *host, u32 val, int reg)
+{
+	writel(val, host->mmio + reg);
+}
+
+u32 aml_cqhci_readl(struct cqhci_host *host, int reg)
+{
+	return readl(host->mmio + reg);
+}
+
+void aml_cqe_enable(struct mmc_host *mmc)
+{
+	struct cqhci_host *cq_host = mmc->cqe_private;
+	u32 val;
+
+	/*
+	 * CQHCI/SDMMC design prevents write access to sdhci block size
+	 * register when CQE is enabled and unhalted.
+	 * CQHCI driver enables CQE prior to activation, so disable CQE before
+	 * programming block size in sdhci controller and enable it back.
+	 */
+	if (!cq_host->activated) {
+		val = cqhci_readl(cq_host, CQHCI_CFG);
+		if (val & CQHCI_ENABLE)
+			cqhci_writel(cq_host, (val & ~CQHCI_ENABLE), CQHCI_CFG);
+		//aml_set_max_blocks(mmc);
+		if (val & CQHCI_ENABLE)
+			cqhci_writel(cq_host, val, CQHCI_CFG);
+	}
+
+	/*
+	 * CMD CRC errors are seen sometimes with some eMMC devices when status
+	 * command is sent during transfer of last data block which is the
+	 * default case as send status command block counter (CBC) is 1.
+	 * Recommended fix to set CBC to 0 allowing send status command only
+	 * when data lines are idle.
+	 * amlogic cheng recommend 1 & 1;
+	 */
+	//val = cqhci_readl(cq_host, CQHCI_SSC1);
+	val = CQHCI_SSC1_CBC(1) | CQHCI_SSC1_CIT(1);
+	cqhci_writel(cq_host, val, CQHCI_SSC1);
+
+	mmc->cqe_on = true;
+}
+
+void aml_cqe_disable(struct mmc_host *mmc, bool recovery)
+{
+	//struct cqhci_host *cq_host = mmc->cqe_private;
+	struct meson_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	mmc->cqe_on = false;
+
+	pr_debug("%s: CQE off, IRQ mask %#x, IRQ status %#x\n",
+		mmc_hostname(mmc), readl(host->regs + SD_EMMC_IRQ_EN),
+		readl(host->regs + SD_EMMC_STATUS));
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+struct cqhci_host_ops amlogic_cqhci_ops = {
+//	.write_l = aml_cqhci_writel,
+//	.read_l = aml_cqhci_readl,
+	.enable	= aml_cqe_enable,
+	.disable = aml_cqe_disable,
+//	.dumpregs = aml_dumpregs,
+//	.update_dcmd_desc = aml_update_dcmd_desc,
+};
+
+int amlogic_add_host(struct meson_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct cqhci_host *cq_host;
+	bool dma64;
+	int ret;
+
+	if (!host->enable_hwcq)
+		return mmc_add_host(mmc);
+
+	mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;
+	mmc->max_seg_size = SD_EMMC_MAX_SEG_SIZE;
+
+	cq_host = devm_kzalloc(host->dev,
+				sizeof(*cq_host), GFP_KERNEL);
+	if (!cq_host) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	cq_host->mmio = host->regs + SD_EMMC_CQE_REG;
+	cq_host->ops = &amlogic_cqhci_ops;
+
+	dma64 = host->flags & AML_USE_64BIT_DMA;
+	if (dma64)
+		cq_host->caps |= CQHCI_TASK_DESC_SZ_128;
+
+	ret = cqhci_init(cq_host, host->mmc, dma64);
+	if (ret)
+		return ret;
+
+	ret = mmc_add_host(mmc);
+	if (ret)
+		goto cleanup;
+
+	return 0;
+
+cleanup:
+	devm_kfree(host->dev, cq_host);
+	return ret;
+}
+
diff --git a/drivers/amlogic/mmc/host/meson-cqhci.h b/drivers/amlogic/mmc/host/meson-cqhci.h
new file mode 100644
index 000000000..fd8678e23
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-cqhci.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef LINUX_AMLMMC_CQHCI_H
+#define LINUX_AMLMMC_CQHCI_H
+
+#include <linux/compiler.h>
+#include <linux/bitops.h>
+#include <linux/spinlock_types.h>
+#include <linux/types.h>
+#include <linux/completion.h>
+#include <linux/wait.h>
+#include <linux/irqreturn.h>
+
+#include "../drivers/mmc/host/cqhci.h"
+/* The resp returned by cmd19 and cmd52/3 can't use the same mask */
+#define SDIO_RESP_ERR_MASK 0x0
+
+#define SD_EMMC_CQE_REG    0x100
+#define SD_EMMC_CQVER    (SD_EMMC_CQE_REG + 0x0)
+#define SD_EMMC_CQCAP    (SD_EMMC_CQE_REG + 0x4)
+#define SD_EMMC_CQCFG    (SD_EMMC_CQE_REG + 0x8)
+#define SD_EMMC_CQCTL    (SD_EMMC_CQE_REG + 0xc)
+
+#define SD_EMMC_CQIS     (SD_EMMC_CQE_REG + 0x10)
+#define SD_EMMC_CQISTE   (SD_EMMC_CQE_REG + 0x14)
+#define SD_EMMC_CQISGE   (SD_EMMC_CQE_REG + 0x18)
+#define SD_EMMC_CQIC     (SD_EMMC_CQE_REG + 0x1c)
+
+#define SD_EMMC_CQTDLBA  (SD_EMMC_CQE_REG + 0x20)
+#define SD_EMMC_CQTDLBAU (SD_EMMC_CQE_REG + 0x24)
+#define SD_EMMC_CQTDBR   (SD_EMMC_CQE_REG + 0x28)
+#define SD_EMMC_CQTCN    (SD_EMMC_CQE_REG + 0x2c)
+
+#define SD_EMMC_CQDQS    (SD_EMMC_CQE_REG + 0x30)
+#define SD_EMMC_CQDPT    (SD_EMMC_CQE_REG + 0x34)
+#define SD_EMMC_CQTCLR   (SD_EMMC_CQE_REG + 0x38)
+
+#define SD_EMMC_CQSSC1   (SD_EMMC_CQE_REG + 0x40)
+#define SD_EMMC_CQSSC2   (SD_EMMC_CQE_REG + 0x44)
+#define SD_EMMC_CQCRDCT  (SD_EMMC_CQE_REG + 0x48)
+
+#define SD_EMMC_CQRMEM   (SD_EMMC_CQE_REG + 0x50)
+#define SD_EMMC_CQTERRI  (SD_EMMC_CQE_REG + 0x54)
+#define SD_EMMC_CQCRI    (SD_EMMC_CQE_REG + 0x58)
+#define SD_EMMC_CQCRA    (SD_EMMC_CQE_REG + 0x5c)
+
+bool aml_cqe_irq(struct meson_host *host, u32 intmask, int *cmd_error,
+	int *data_error);
+u32 aml_cqhci_irq(struct meson_host *host);
+void aml_cqhci_writel(struct cqhci_host *host, u32 val, int reg);
+u32 aml_cqhci_readl(struct cqhci_host *host, int reg);
+void aml_cqe_enable(struct mmc_host *mmc);
+void aml_cqe_disable(struct mmc_host *mmc, bool recovery);
+int amlogic_add_host(struct meson_host *host);
+
+#endif
diff --git a/drivers/amlogic/mmc/host/meson-g12a-mmc.c b/drivers/amlogic/mmc/host/meson-g12a-mmc.c
new file mode 100644
index 000000000..8d6b97d7a
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-g12a-mmc.c
@@ -0,0 +1,2854 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/iopoll.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+#include <linux/interrupt.h>
+#include <linux/bitfield.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_sd.h>
+#include <linux/delay.h>
+#include <core.h>
+#include <mmc_ops.h>
+#include <linux/time.h>
+#include <linux/random.h>
+#include <linux/gpio/consumer.h>
+#include <linux/sched/clock.h>
+#include <linux/debugfs.h>
+#include "mmc_key.h"
+#include "mmc_dtb.h"
+// #if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+// #include <trace/hooks/mmc.h>
+// #endif
+#include <linux/moduleparam.h>
+#include <linux/amlogic/gki_module.h>
+
+#include "meson-cqhci.h"
+
+struct mmc_gpio {
+	struct gpio_desc *ro_gpio;
+	struct gpio_desc *cd_gpio;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	char *ro_label;
+	char *cd_label;
+	u32 cd_debounce_delay_ms;
+};
+
+static struct wifi_clk_table wifi_clk[WIFI_CLOCK_TABLE_MAX] = {
+	{"8822BS", 0, 0xb822, 167000000},
+	{"8822CS", 0, 0xc822, 167000000},
+	{"qca6174", 0, 0x50a, 167000000}
+};
+
+//extern struct mmc_host *sdio_host;
+
+// #if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+// void mmc_sd_update_cmdline_timing(void *data, struct mmc_card *card, int *err)
+// {
+// 	/* nothing */
+// 	*err = 0;
+// }
+
+// void mmc_sd_update_dataline_timing(void *data, struct mmc_card *card, int *err)
+// {
+// 	/* nothing */
+// 	*err = 0;
+// }
+
+// //#define SD_CMD_TIMING mmc_sd_update_cmdline_timing
+// //#define SD_DATA_TIMING mmc_sd_update_dataline_timing
+// #endif
+
+static inline u32 aml_mv_dly1_nommc(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 18);
+}
+
+static inline u32 aml_mv_dly1(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 18) | ((x) << 24);
+}
+
+static inline u32 aml_mv_dly2(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 24);
+}
+
+static inline u32 aml_mv_dly2_nocmd(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12);
+}
+
+//int aml_disable_mmc_cqe(struct mmc_card *card)
+//{
+//	int ret = 0;
+//
+//	if (card->reenable_cmdq && card->ext_csd.cmdq_en) {
+//		pr_debug("[%s] [%d]\n", __func__, __LINE__);
+//		ret = mmc_cmdq_disable(card);
+//		if (ret)
+//			pr_err("[%s] disable cqe mode failed\n", __func__);
+//	}
+//	return ret;
+//}
+//
+//int aml_enable_mmc_cqe(struct mmc_card *card)
+//{
+//	int ret = 0;
+//
+//	if (card->reenable_cmdq && !card->ext_csd.cmdq_en) {
+//		pr_debug("[%s] [%d]\n", __func__, __LINE__);
+//		ret = mmc_cmdq_enable(card);
+//		if (ret)
+//			pr_err("[%s] reenable cqe mode failed\n", __func__);
+//	}
+//	return ret;
+//}
+
+static int tdma_of_parse(struct mmc_host *mmc, u32 index)
+{
+	struct device *dev = mmc->parent;
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	u32 cd_debounce_delay_ms;
+	int ret = 0;
+
+	if (!dev || !dev_fwnode(dev))
+		return 0;
+
+	mmc->caps |= MMC_CAP_4_BIT_DATA;
+	/* f_max is obtained from the optional "max-frequency" property */
+	device_property_read_u32(dev, "max-frequency", &mmc->f_max);
+
+	if (index == MMC_MULT_DEV_SEQ_SDIO) {
+		mmc->caps |= MMC_CAP_NONREMOVABLE;
+	} else {
+		if (device_property_read_bool(dev, "cd-inverted"))
+			mmc->caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;
+
+		if (device_property_read_u32(dev, "cd-debounce-delay-ms",
+					     &cd_debounce_delay_ms))
+			cd_debounce_delay_ms = 200;
+
+		if (device_property_read_bool(dev, "broken-cd"))
+			mmc->caps |= MMC_CAP_NEEDS_POLL;
+
+		ret = mmc_gpiod_request_cd(mmc, "cd", 0, false,
+					   cd_debounce_delay_ms * 1000);
+		if (!ret) {
+			dev_info(mmc->parent, "Got CD GPIO\n");
+		} else if (ret != -ENOENT) {
+			dev_info(mmc->parent, "[%s] ret:%d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	if (device_property_read_bool(dev, "disable-wp"))
+		mmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;
+	if (device_property_read_bool(dev, "cap-sd-highspeed"))
+		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
+
+	if (index == MMC_MULT_DEV_SEQ_SDIO) {
+		if (device_property_read_bool(dev, "sd-uhs-sdr104"))
+			mmc->caps |= MMC_CAP_UHS_SDR104;
+		if (device_property_read_bool(dev, "cap-sdio-irq"))
+			mmc->caps |= MMC_CAP_SDIO_IRQ;
+		if (device_property_read_bool(dev, "keep-power-in-suspend"))
+			mmc->pm_caps |= MMC_PM_KEEP_POWER;
+	}
+	if (device_property_read_bool(dev, "no-sdio"))
+		mmc->caps2 |= MMC_CAP2_NO_SDIO;
+	if (device_property_read_bool(dev, "no-sd"))
+		mmc->caps2 |= MMC_CAP2_NO_SD;
+	if (device_property_read_bool(dev, "no-mmc"))
+		mmc->caps2 |= MMC_CAP2_NO_MMC;
+
+	if (index == MMC_MULT_DEV_SEQ_SD) {
+		mmc->caps2 &= ~(MMC_CAP2_NO_SD);
+		pdata->card_type = CARD_TYPE_NON_SDIO;
+	}
+	if (index == MMC_MULT_DEV_SEQ_SDIO) {
+		mmc->caps2 &= ~(MMC_CAP2_NO_SDIO);
+		pdata->card_type = CARD_TYPE_SDIO;
+	}
+	return ret;
+}
+
+static int amlogic_of_parse(struct mmc_host *mmc)
+{
+	struct device *dev = mmc->parent;
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+
+	if (device_property_read_u32(dev, "init_core_phase",
+			&pdata->sd_mmc.init.core_phase) < 0)
+		pdata->sd_mmc.init.core_phase = 2;
+	if (device_property_read_u32(dev, "init_tx_phase",
+			&pdata->sd_mmc.init.tx_phase) < 0)
+		pdata->sd_mmc.init.tx_delay = 0;
+	if (device_property_read_u32(dev, "hs2_core_phase",
+			&pdata->sd_mmc.hs2.core_phase) < 0)
+		pdata->sd_mmc.hs2.core_phase = 2;
+	if (device_property_read_u32(dev, "hs2_tx_phase",
+			&pdata->sd_mmc.hs2.tx_phase) < 0)
+		pdata->sd_mmc.hs2.tx_delay = 0;
+	if (device_property_read_u32(dev, "hs4_core_phase",
+			&pdata->sd_mmc.hs4.core_phase) < 0)
+		pdata->sd_mmc.hs4.core_phase = 0;
+	if (device_property_read_u32(dev, "hs4_tx_phase",
+			&pdata->sd_mmc.hs4.tx_phase) < 0)
+		pdata->sd_mmc.hs4.tx_phase = 0;
+	if (device_property_read_u32(dev, "src_clk_rate",
+			&pdata->src_clk_rate) < 0)
+		pdata->src_clk_rate = 1000000000;
+	if (device_property_read_u32(dev, "sdr_tx_delay",
+			&pdata->sd_mmc.sdr.tx_delay) < 0)
+		pdata->sd_mmc.sdr.tx_delay = 0;
+	if (device_property_read_u32(dev, "sdr_core_phase",
+			&pdata->sd_mmc.sdr.core_phase) < 0)
+		pdata->sd_mmc.sdr.core_phase = 2;
+	if (device_property_read_u32(dev, "sdr_tx_phase",
+			&pdata->sd_mmc.sdr.tx_phase) < 0)
+		pdata->sd_mmc.sdr.tx_phase = 0;
+
+	if (device_property_read_u32(dev, "card_type",
+			&pdata->card_type) < 0)
+		dev_err(mmc->parent,
+			"No config cart type value\n");
+
+	if (device_property_read_bool(dev, "mmc_debug_flag"))
+		pdata->debug_flag = 0;
+	else
+		pdata->debug_flag = 1;
+
+	return 0;
+}
+
+/*
+ * Checks that a normal transfer didn't have any errors
+ */
+//static int mmc_check_result(struct mmc_request *mrq)
+//{
+//	int ret;
+//
+//	WARN_ON(!mrq || !mrq->cmd || !mrq->data);
+//
+//	ret = 0;
+//
+//	if (!ret && mrq->cmd->error)
+//		ret = mrq->cmd->error;
+//	if (!ret && mrq->data->error)
+//		ret = mrq->data->error;
+//	if (!ret && mrq->stop && mrq->stop->error)
+//		ret = mrq->stop->error;
+//	if (!ret && mrq->data->bytes_xfered !=
+//			mrq->data->blocks * mrq->data->blksz)
+//		ret = RESULT_FAIL;
+//
+//	if (ret == -EINVAL)
+//		ret = RESULT_UNSUP_HOST;
+//
+//	return ret;
+//}
+
+//static void mmc_prepare_mrq(struct mmc_card *card,
+//			    struct mmc_request *mrq, struct scatterlist *sg,
+//			    unsigned int sg_len, unsigned int dev_addr,
+//			    unsigned int blocks,
+//			    unsigned int blksz, int write)
+//{
+//	WARN_ON(!mrq || !mrq->cmd || !mrq->data || !mrq->stop);
+//
+//	if (blocks > 1) {
+//		mrq->cmd->opcode = write ?
+//			MMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;
+//	} else {
+//		mrq->cmd->opcode = write ?
+//			MMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;
+//	}
+//
+//	mrq->cmd->arg = dev_addr;
+//	if (!mmc_card_is_blockaddr(card))
+//		mrq->cmd->arg <<= 9;
+//
+//	mrq->cmd->flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+//
+//	if (blocks == 1) {
+//		mrq->stop = NULL;
+//	} else {
+//		mrq->stop->opcode = MMC_STOP_TRANSMISSION;
+//		mrq->stop->arg = 0;
+//		mrq->stop->flags = MMC_RSP_R1B | MMC_CMD_AC;
+//	}
+//
+//	mrq->data->blksz = blksz;
+//	mrq->data->blocks = blocks;
+//	mrq->data->flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
+//	mrq->data->sg = sg;
+//	mrq->data->sg_len = sg_len;
+//
+//	mmc_set_data_timeout(mrq->data, card);
+//}
+
+//static unsigned int mmc_capacity(struct mmc_card *card)
+//{
+//	if (!mmc_card_sd(card) && mmc_card_is_blockaddr(card))
+//		return card->ext_csd.sectors;
+//	else
+//		return card->csd.capacity << (card->csd.read_blkbits - 9);
+//}
+
+//static int mmc_transfer(struct mmc_card *card, unsigned int dev_addr,
+//			unsigned int blocks, void *buf, int write)
+//{
+//	u8 original_part_config;
+//	u8 user_part_number = 0;
+//	u8 cur_part_number;
+//	bool switch_partition = false;
+//	unsigned int size;
+//	struct scatterlist sg;
+//	struct mmc_request mrq = {0};
+//	struct mmc_command cmd = {0};
+//	struct mmc_command stop = {0};
+//	struct mmc_data data = {0};
+//	int ret;
+//
+//	cur_part_number = card->ext_csd.part_config
+//		& EXT_CSD_PART_CONFIG_ACC_MASK;
+//	if (cur_part_number != user_part_number) {
+//		switch_partition = true;
+//		original_part_config = card->ext_csd.part_config;
+//		cur_part_number = original_part_config
+//			& (~EXT_CSD_PART_CONFIG_ACC_MASK);
+//		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+//				 EXT_CSD_PART_CONFIG, cur_part_number,
+//				 card->ext_csd.part_time);
+//		if (ret)
+//			return ret;
+//
+//		card->ext_csd.part_config = cur_part_number;
+//	}
+//	if ((dev_addr + blocks) >= mmc_capacity(card)) {
+//		pr_info("[%s] %s range exceeds device capacity!\n",
+//			__func__, write ? "write" : "read");
+//		ret = -1;
+//		return ret;
+//	}
+//
+//	size = blocks << card->csd.read_blkbits;
+//	sg_init_one(&sg, buf, size);
+//
+//	mrq.cmd = &cmd;
+//	mrq.data = &data;
+//	mrq.stop = &stop;
+//
+//	mmc_prepare_mrq(card, &mrq, &sg, 1, dev_addr,
+//			blocks, 1 << card->csd.read_blkbits, write);
+//
+//	mmc_wait_for_req(card->host, &mrq);
+//
+//	ret = mmc_check_result(&mrq);
+//	if (switch_partition) {
+//		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+//				 EXT_CSD_PART_CONFIG, original_part_config,
+//				 card->ext_csd.part_time);
+//		if (ret)
+//			return ret;
+//		card->ext_csd.part_config = original_part_config;
+//	}
+//
+//	return ret;
+//}
+
+//static int mmc_read_internal(struct mmc_card *card, unsigned int dev_addr,
+//			unsigned int blocks, void *buf)
+//{
+//	return mmc_transfer(card, dev_addr, blocks, buf, 0);
+//}
+//
+//static int mmc_write_internal(struct mmc_card *card, unsigned int dev_addr,
+//			unsigned int blocks, void *buf)
+//{
+//	return mmc_transfer(card, dev_addr, blocks, buf, 1);
+//}
+
+static unsigned int meson_mmc_get_timeout_msecs(struct mmc_data *data)
+{
+	unsigned int timeout = data->timeout_ns / NSEC_PER_MSEC;
+
+	if (!timeout)
+		return SD_EMMC_CMD_TIMEOUT_DATA;
+
+	timeout = roundup_pow_of_two(timeout);
+
+	return min(timeout, 32768U); /* max. 2^15 ms */
+}
+
+static void meson_mmc_get_transfer_mode(struct mmc_host *mmc,
+					struct mmc_request *mrq)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	struct mmc_data *data = mrq->data;
+	struct scatterlist *sg;
+	int i;
+	bool use_desc_chain_mode = true;
+
+	/*
+	 * When Controller DMA cannot directly access DDR memory, disable
+	 * support for Chain Mode to directly use the internal SRAM using
+	 * the bounce buffer mode.
+	 */
+	if (host->dram_access_quirk)
+		return;
+
+	/*
+	 * Broken SDIO with AP6255-based WiFi on Khadas VIM Pro has been
+	 * reported. For some strange reason this occurs in descriptor
+	 * chain mode only. So let's fall back to bounce buffer mode
+	 * for command SD_IO_RW_EXTENDED.
+	 */
+	/*if (mrq->cmd->opcode == SD_IO_RW_EXTENDED)
+	 *	return;
+	 */
+
+	for_each_sg(data->sg, sg, data->sg_len, i)
+		/* check for 8 byte alignment */
+		if (sg->offset & 7) {
+			use_desc_chain_mode = false;
+			break;
+		}
+
+	if (use_desc_chain_mode)
+		data->host_cookie |= SD_EMMC_DESC_CHAIN_MODE;
+}
+
+static inline bool meson_mmc_desc_chain_mode(const struct mmc_data *data)
+{
+	return data->host_cookie & SD_EMMC_DESC_CHAIN_MODE;
+}
+
+static inline bool meson_mmc_bounce_buf_read(const struct mmc_data *data)
+{
+	return data && data->flags & MMC_DATA_READ &&
+	       !meson_mmc_desc_chain_mode(data);
+}
+
+static void meson_mmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	meson_mmc_get_transfer_mode(mmc, mrq);
+	data->host_cookie |= SD_EMMC_PRE_REQ_DONE;
+
+	if (!meson_mmc_desc_chain_mode(data))
+		return;
+
+	data->sg_count = dma_map_sg(mmc_dev(mmc), data->sg, data->sg_len,
+				    mmc_get_dma_dir(data));
+	if (!data->sg_count)
+		dev_err(mmc_dev(mmc), "dma_map_sg failed");
+}
+
+static void meson_mmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
+			       int err)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (data && meson_mmc_desc_chain_mode(data) && data->sg_count)
+		dma_unmap_sg(mmc_dev(mmc), data->sg, data->sg_len,
+			     mmc_get_dma_dir(data));
+}
+
+/*
+ * Gating the clock on this controller is tricky.  It seems the mmc clock
+ * is also used by the controller.  It may crash during some operation if the
+ * clock is stopped.  The safest thing to do, whenever possible, is to keep
+ * clock running at stop it at the pad using the pinmux.
+ */
+static void meson_mmc_clk_gate(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 cfg;
+
+	if (pdata->pins_clk_gate) {
+		pinctrl_select_state(host->pinctrl, pdata->pins_clk_gate);
+	} else {
+		/*
+		 * If the pinmux is not provided - default to the classic and
+		 * unsafe method
+		 */
+		cfg = readl(host->regs + SD_EMMC_CFG);
+		cfg |= CFG_STOP_CLOCK;
+		writel(cfg, host->regs + SD_EMMC_CFG);
+	}
+}
+
+static void meson_mmc_clk_ungate(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 cfg;
+
+	if (pdata->pins_clk_gate)
+		pinctrl_select_state(host->pinctrl, pdata->pins_default);
+
+	/* Make sure the clock is not stopped in the controller */
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	cfg &= ~CFG_STOP_CLOCK;
+	writel(cfg, host->regs + SD_EMMC_CFG);
+}
+
+static void meson_mmc_set_phase_delay(struct mmc_host *mmc, u32 mask,
+				      unsigned int phase)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 val;
+
+	val = readl(host->regs);
+	val &= ~mask;
+	val |= phase << __ffs(mask);
+	writel(val, host->regs);
+}
+
+static int no_pxp_clk_set(struct mmc_host *mmc, struct mmc_ios *ios,
+						unsigned long rate)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	int ret = 0;
+	struct clk *src_clk = NULL;
+	u32 cfg = readl(host->regs + SD_EMMC_CFG);
+
+	dev_dbg(host->dev, "[%s]set rate:%lu, %s\n", __func__, rate, mmc_hostname(mmc));
+	if (pdata->src_clk)
+		clk_disable_unprepare(pdata->src_clk);
+
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_HS400:
+		if (host->clk[2])
+			src_clk = host->clk[2];
+		else
+			src_clk = host->clk[1];
+		dev_dbg(host->dev, "HS400 set src rate to:%u\n",
+			pdata->src_clk_rate);
+		ret = clk_set_rate(src_clk, pdata->src_clk_rate);
+		if (ret) {
+			dev_err(host->dev, "set src err\n");
+				return ret;
+		}
+		cfg |= CFG_AUTO_CLK;
+		break;
+	case MMC_TIMING_MMC_HS:
+	case MMC_TIMING_SD_HS:
+	case MMC_TIMING_MMC_DDR52:
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR50:
+	case MMC_TIMING_UHS_SDR104:
+		dev_dbg(host->dev, "[%s]Other mode set src rate to:%u, %s\n",
+				__func__, pdata->src_clk_rate, mmc_hostname(mmc));
+		ret = clk_set_rate(host->clk[1], pdata->src_clk_rate);
+		if (ret) {
+			dev_err(host->dev, "set src err\n");
+				return ret;
+		}
+		src_clk = host->clk[1];
+		cfg |= CFG_AUTO_CLK;
+	/* sdio set clk always on default */
+		if (aml_card_type_sdio(pdata) && !pdata->auto_clk)
+			cfg &= ~CFG_AUTO_CLK;
+		break;
+	case MMC_TIMING_LEGACY:
+		dev_dbg(host->dev, "[%s]Legacy set rate to:%lu, %s\n",
+				__func__, rate, mmc_hostname(mmc));
+		src_clk = host->clk[0];
+	/* enable always on clock for 400KHZ */
+		cfg &= ~CFG_AUTO_CLK;
+
+	/* switch source clock as Total before clk =0, then disable source clk */
+		if (rate == 0) {
+			if (host->mux_div && (!strcmp(__clk_get_name(src_clk), "xtal")))
+				ret = clk_set_parent(host->mux[2], src_clk);
+			else
+				ret = clk_set_parent(host->mux[0], src_clk);
+			pdata->src_clk = NULL;
+			cfg |= CFG_AUTO_CLK;
+			writel(cfg, host->regs + SD_EMMC_CFG);
+			return ret;
+		}
+		break;
+	default:
+		dev_notice(host->dev, "Check mmc/sd/sdio timing mode\n");
+		WARN_ON(1);
+		break;
+	}
+
+	clk_prepare_enable(src_clk);
+	writel(cfg, host->regs + SD_EMMC_CFG);
+	pdata->src_clk = src_clk;
+	if (host->mux_div) { // C1/C2
+		if (!strcmp(__clk_get_name(src_clk), "xtal")) {
+			ret = clk_set_parent(host->mux[2], src_clk);
+		} else {
+			ret = clk_set_parent(host->mux[0], src_clk);
+			if (!ret) {
+				clk_set_rate(host->mux_div, clk_get_rate((src_clk)));
+				ret = clk_set_parent(host->mux[2], host->mux_div);
+			}
+		}
+	} else { // other soc
+		ret = clk_set_parent(host->mux[0], src_clk);
+	}
+
+	if (ret) {
+		dev_err(host->dev, "set parent error\n");
+		return ret;
+	}
+
+	ret = clk_set_rate(host->mmc_clk, rate);
+	if (ret) {
+		dev_err(host->dev, "Unable to set cfg_div_clk to %lu. ret=%d\n",
+			rate, ret);
+		return ret;
+	}
+	host->req_rate = rate;
+	pdata->req_rate = rate;
+	mmc->actual_clock = clk_get_rate(host->mmc_clk);
+
+	dev_dbg(host->dev, "clk rate: %u Hz, %s\n", mmc->actual_clock, mmc_hostname(mmc));
+
+	return ret;
+}
+
+/*
+ * The SD/eMMC IP block has an internal mux and divider used for
+ * generating the MMC clock.  Use the clock framework to create and
+ * manage these clocks.
+ */
+static int meson_mmc_clk_init(struct meson_host *host)
+{
+	struct clk_init_data init;
+	struct clk_divider *div;
+	char clk_name[32], name[16];
+	int i, ret = 0;
+	const char *clk_parent[1];
+	u32 clk_reg;
+
+	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+	clk_reg = CLK_ALWAYS_ON(host);
+	clk_reg |= CLK_DIV_MASK;
+	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);
+	clk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);
+	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
+	writel(clk_reg, host->regs + SD_EMMC_CLOCK);
+
+	for (i = 0; i < 2; i++) {
+		snprintf(name, sizeof(name), "mux%d", i);
+		host->mux[i] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->mux[i])) {
+			if (host->mux[i] != ERR_PTR(-EPROBE_DEFER))
+				dev_err(host->dev, "Missing clock %s\n", name);
+			return PTR_ERR(host->mux[i]);
+		}
+	}
+	host->mux_div = devm_clk_get(host->dev, "mux_div");
+	if (IS_ERR(host->mux_div)) {
+		host->mux_div = NULL;
+		dev_dbg(host->dev,
+			"Missing clock %s(only c1/c2 have mux_div)\n",
+			"mux_div");
+	} else {
+		snprintf(name, sizeof(name), "mux%d", 2);
+		host->mux[2] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->mux[2]))
+			dev_err(host->dev, "Missing clock %s\n", "mux2");
+	}
+
+	for (i = 0; i < 3; i++) {
+		snprintf(name, sizeof(name), "clkin%d", i);
+		host->clk[i] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->clk[i])) {
+			dev_dbg(host->dev,
+				"Missing clock%s, i = %d\n", name, i);
+			host->clk[i] = NULL;
+		}
+	}
+
+	if (host->mux_div) {
+		ret = clk_set_parent(host->mux[2], host->mux_div);
+		if (ret) {
+			dev_err(host->dev, "Set div parent error\n");
+			return ret;
+		}
+	}
+
+	/* create the divider */
+	div = devm_kzalloc(host->dev, sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return -ENOMEM;
+
+	snprintf(clk_name, sizeof(clk_name), "%s#div", dev_name(host->dev));
+	init.name = clk_name;
+	init.ops = &clk_divider_ops;
+	clk_parent[0] = __clk_get_name(host->mux[1]);
+	init.parent_names = clk_parent;
+	init.num_parents = 1;
+	init.flags = CLK_SET_RATE_PARENT;
+
+	div->reg = host->regs + SD_EMMC_CLOCK;
+	div->shift = __ffs(CLK_DIV_MASK);
+	div->width = __builtin_popcountl(CLK_DIV_MASK);
+	div->hw.init = &init;
+	div->flags = CLK_DIVIDER_ONE_BASED;
+
+	host->mmc_clk = devm_clk_register(host->dev, &div->hw);
+	if (WARN_ON(IS_ERR(host->mmc_clk)))
+		return PTR_ERR(host->mmc_clk);
+	/* create the mmc core clock */
+	if (host->mux_div)
+		ret = clk_set_parent(host->mux[2], host->clk[0]);
+	else
+		ret = clk_set_parent(host->mux[0], host->clk[0]);
+	if (ret) {
+		dev_err(host->dev, "Set 24m parent error\n");
+		return ret;
+	}
+	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+	host->f_min = clk_round_rate(host->mmc_clk, 400000);
+	ret = clk_set_rate(host->mmc_clk, host->f_min);
+	if (ret)
+		return ret;
+
+	return clk_prepare_enable(host->mmc_clk);
+}
+
+static int meson_mmc_set_adjust(struct mmc_host *mmc, u32 value)
+{
+	u32 val;
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+
+	val = readl(host->regs + SD_EMMC_V3_ADJUST);
+	val &= ~CLK_ADJUST_DELAY;
+	val &= ~CFG_ADJUST_ENABLE;
+	val |= CFG_ADJUST_ENABLE;
+	val |= value << __ffs(CLK_ADJUST_DELAY);
+
+	writel(val, host->regs + SD_EMMC_V3_ADJUST);
+	return 0;
+}
+
+static int meson_mmc_tuning_transfer(struct mmc_host *mmc, u32 opcode)
+{
+	int tuning_err = 0;
+	int n, nmatch;
+	/* try ntries */
+	for (n = 0, nmatch = 0; n < TUNING_NUM_PER_POINT; n++) {
+		tuning_err = mmc_send_tuning(mmc, opcode, NULL);
+		if (!tuning_err) {
+			nmatch++;
+		} else {
+		/* After the cmd21 command fails,
+		 * it takes a certain time for the emmc status to
+		 * switch from data back to transfer. Currently,
+		 * only this model has this problem.
+		 * by add usleep_range(20, 30);
+		 */
+			usleep_range(20, 30);
+			break;
+		}
+	}
+	return nmatch;
+}
+
+static int find_best_win(struct mmc_host *mmc,
+		char *buf, int num, int *b_s, int *b_sz, bool wrap_f)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	int wrap_win_start = -1, wrap_win_size = 0;
+	int curr_win_start = -1, curr_win_size = 0;
+	int best_win_start = -1, best_win_size = 0;
+	int i = 0, len = 0;
+	u8 *adj_print = NULL;
+
+	len = 0;
+	adj_print = host->adj_win;
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print, "%s: adj_win: < ", mmc_hostname(mmc));
+
+	for (i = 0; i < num; i++) {
+		/*get a ok adjust point!*/
+		if (buf[i]) {
+			if (i == 0)
+				wrap_win_start = i;
+
+			if (wrap_win_start >= 0)
+				wrap_win_size++;
+
+			if (curr_win_start < 0)
+				curr_win_start = i;
+
+			curr_win_size++;
+			len += sprintf(adj_print + len,
+					"%d ", i);
+		} else {
+			if (curr_win_start >= 0) {
+				if (best_win_start < 0) {
+					best_win_start = curr_win_start;
+					best_win_size = curr_win_size;
+				} else {
+					if (best_win_size < curr_win_size) {
+						best_win_start = curr_win_start;
+						best_win_size = curr_win_size;
+					}
+				}
+				wrap_win_start = -1;
+				curr_win_start = -1;
+				curr_win_size = 0;
+			}
+		}
+	}
+
+	sprintf(adj_print + len, ">\n");
+	if (num <= AML_FIXED_ADJ_MAX)
+		pr_debug("%s", host->adj_win);
+
+	/* last point is ok! */
+	if (curr_win_start >= 0) {
+		if (best_win_start < 0) {
+			best_win_start = curr_win_start;
+			best_win_size = curr_win_size;
+		} else if ((wrap_win_size > 0) && wrap_f) {
+			/* Wrap around case */
+			if (curr_win_size + wrap_win_size > best_win_size) {
+				best_win_start = curr_win_start;
+				best_win_size = curr_win_size + wrap_win_size;
+			}
+		} else if (best_win_size < curr_win_size) {
+			best_win_start = curr_win_start;
+			best_win_size = curr_win_size;
+		}
+
+		curr_win_start = -1;
+		curr_win_size = 0;
+	}
+	*b_s = best_win_start;
+	*b_sz = best_win_size;
+
+	return 0;
+}
+
+static void pr_adj_info(char *name,
+		unsigned long x, u32 fir_adj, u32 div)
+{
+	int i;
+
+	pr_debug("[%s] fixed_adj_win_map:%lu\n", name, x);
+	for (i = 0; i < div; i++)
+		pr_debug("[%d]=%d\n", (fir_adj + i) % div,
+				((x >> i) & 0x1) ? 1 : 0);
+}
+
+static unsigned long _test_fixed_adj(struct mmc_host *mmc,
+		u32 opcode, u32 adj, u32 div)
+{
+	int i = 0;
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u8 *adj_print = host->adj_win;
+	u32 len = 0;
+	u32 nmatch = 0;
+	unsigned long fixed_adj_map = 0;
+
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print + len, "%s: adj_win: < ", mmc_hostname(mmc));
+	bitmap_zero(&fixed_adj_map, div);
+	for (i = 0; i < div; i++) {
+		meson_mmc_set_adjust(mmc, adj + i);
+		nmatch = meson_mmc_tuning_transfer(mmc, opcode);
+		/*get a ok adjust point!*/
+		if (nmatch == TUNING_NUM_PER_POINT) {
+			set_bit(adj + i, &fixed_adj_map);
+			len += sprintf(adj_print + len,
+				"%d ", adj + i);
+		}
+		pr_debug("%s: rx_tuning_result[%d] = %d\n",
+				mmc_hostname(mmc), adj + i, nmatch);
+	}
+	len += sprintf(adj_print + len, ">\n");
+	pr_debug("%s", host->adj_win);
+
+	return fixed_adj_map;
+}
+
+static u32 _find_fixed_adj_mid(unsigned long map,
+		u32 adj, u32 div, u32 co)
+{
+	u32 left, right, mid, size = 0;
+
+	left = find_last_bit(&map, div);
+	right = find_first_bit(&map, div);
+	/*
+	 * The lib functions don't need to be modified.
+	 */
+	/* coverity[callee_ptr_arith:SUPPRESS] */
+	mid = find_first_zero_bit(&map, div);
+	size = left - right + 1;
+	pr_debug("left:%u, right:%u, mid:%u, size:%u\n",
+			left, right, mid, size);
+	if (size >= 3 && (mid < right || mid > left)) {
+		mid = (adj + (size - 1) / 2 + (size - 1) % 2) % div;
+		if ((mid == (co - 1)) && div == 5)
+			return NO_FIXED_ADJ_MID;
+		pr_info("tuning-c:%u, tuning-s:%u\n",
+			mid, size);
+		return mid;
+	}
+	return NO_FIXED_ADJ_MID;
+}
+
+static unsigned long _swap_fixed_adj_win(unsigned long map,
+		u32 shift, u32 div)
+{
+	unsigned long left, right;
+	/*
+	 * The lib functions don't need to be modified.
+	 */
+	/* coverity[callee_ptr_arith:SUPPRESS] */
+	bitmap_shift_right(&right, &map,
+			shift, div);
+	bitmap_shift_left(&left, &map,
+			div - shift, div);
+	bitmap_or(&map, &right, &left, div);
+	return map;
+}
+
+static void set_fixed_adj_line_delay(u32 step,
+		struct mmc_host *mmc, bool no_cmd)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+
+	if (aml_card_type_mmc(pdata)) {
+		writel(aml_mv_dly1(step), host->regs + SD_EMMC_DELAY1);
+		if (no_cmd)
+			writel(aml_mv_dly2_nocmd(step),
+					host->regs + SD_EMMC_DELAY2);
+		else
+			writel(aml_mv_dly2(step),
+					host->regs + SD_EMMC_DELAY2);
+	} else {
+		writel(aml_mv_dly1_nommc(step), host->regs + SD_EMMC_DELAY1);
+		if (!no_cmd)
+			writel(AML_MV_DLY2_NOMMC_CMD(step),
+					host->regs + SD_EMMC_DELAY2);
+	}
+	pr_debug("step:%u, delay1:0x%x, delay2:0x%x\n",
+			step,
+			readl(host->regs + SD_EMMC_DELAY1),
+			readl(host->regs + SD_EMMC_DELAY2));
+}
+
+/*	1. find first removed a fixed_adj_point
+ *	2. re-range fixed adj point
+ *	3. retry
+ */
+static u32 _find_fixed_adj_valid_win(struct mmc_host *mmc,
+		u32 opcode,	unsigned long *fixed_adj_map, u32 div)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 step = 0, ret = NO_FIXED_ADJ_MID, fir_adj = 0xff;
+	unsigned long cur_map[1] = {0};
+	unsigned long prev_map[1] = {0};
+	unsigned long tmp[1] = {0};
+	unsigned long dst[1] = {0};
+//	struct mmc_phase *mmc_phase_init = &host->sd_mmc.init;
+	u32 cop, vclk;
+
+	vclk = readl(host->regs + SD_EMMC_CLOCK);
+	cop = (vclk & CLK_CORE_PHASE_MASK) >> __ffs(CLK_CORE_PHASE_MASK);
+//	cop = para->hs2.core_phase;
+
+	div = (div == AML_FIXED_ADJ_MIN) ?
+			AML_FIXED_ADJ_MIN : AML_FIXED_ADJ_MAX;
+	*prev_map = *fixed_adj_map;
+	pr_adj_info("prev_map", *prev_map, 0, div);
+	for (; step <= 63;) {
+		pr_debug("[%s]retry test fixed adj...\n", __func__);
+		step += AML_FIXADJ_STEP;
+		set_fixed_adj_line_delay(step, mmc, false);
+		*cur_map = _test_fixed_adj(mmc, opcode, 0, div);
+		/*pr_adj_info("cur_map", *cur_map, 0, div);*/
+		bitmap_and(tmp, prev_map, cur_map, div);
+		bitmap_xor(dst, prev_map, tmp, div);
+		if (*dst != 0) {
+			fir_adj = find_first_bit(dst, div);
+			pr_adj_info(">>>>>>>>bitmap_xor_dst", *dst, 0, div);
+			pr_debug("[%s] fir_adj:%u\n", __func__, fir_adj);
+
+			*prev_map = _swap_fixed_adj_win(*prev_map,
+					fir_adj, div);
+			pr_adj_info(">>>>>>>>prev_map_range",
+					*prev_map, fir_adj, div);
+			ret = _find_fixed_adj_mid(*prev_map, fir_adj, div, cop);
+			if (ret != NO_FIXED_ADJ_MID) {
+				/* pre adj=core phase-1="hole"&&200MHZ,all line delay+step */
+				if (((ret - 1) == (cop - 1)) && div == 5)
+					set_fixed_adj_line_delay(AML_FIXADJ_STEP, mmc, false);
+				else
+					set_fixed_adj_line_delay(0, mmc, false);
+				return ret;
+			}
+
+			fir_adj = (fir_adj + find_next_bit(prev_map,
+				div, 1)) % div;
+		}
+		if (fir_adj == 0xff)
+			continue;
+
+		*prev_map = *cur_map;
+		*cur_map = _swap_fixed_adj_win(*cur_map, fir_adj, div);
+		pr_adj_info(">>>>>>>>cur_map_range", *cur_map, fir_adj, div);
+		ret = _find_fixed_adj_mid(*cur_map, fir_adj, div, cop);
+		if (ret != NO_FIXED_ADJ_MID) {
+			/* pre adj=core phase-1="hole"&&200MHZ,all line delay+step */
+			if (((ret - 1) == (cop - 1)) && div == 5) {
+				step += AML_FIXADJ_STEP;
+				set_fixed_adj_line_delay(step, mmc, false);
+			}
+			return ret;
+		}
+	}
+
+	pr_debug("[%s][%d] no fixed adj\n", __func__, __LINE__);
+	return ret;
+}
+
+static int meson_mmc_fixadj_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 nmatch = 0;
+	int adj_delay = 0;
+	u8 tuning_num = 0;
+	u32 clk_div, vclk;
+	u32 old_dly, d1_dly, dly;
+	u32 adj_delay_find =  0xff;
+	unsigned long fixed_adj_map[1];
+	bool all_flag = false;
+	int best_s = -1, best_sz = 0;
+	char rx_adj[64] = {0};
+	u8 *adj_print = NULL;
+	u32 len = 0;
+
+	old_dly = readl(host->regs + SD_EMMC_V3_ADJUST);
+	d1_dly = (old_dly >> 0x6) & 0x3F;
+	pr_debug("Data 1 aligned delay is %d\n", d1_dly);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+
+tuning:
+	/* renew */
+	best_s = -1;
+	best_sz = 0;
+	memset(rx_adj, 0, 64);
+
+	len = 0;
+	adj_print = host->adj_win;
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print + len, "%s: adj_win: < ", mmc_hostname(mmc));
+	vclk = readl(host->regs + SD_EMMC_CLOCK);
+	clk_div = vclk & CLK_DIV_MASK;
+	pr_debug("%s: clk %d div %d tuning start\n",
+			mmc_hostname(mmc), mmc->actual_clock, clk_div);
+
+	if (clk_div <= AML_FIXED_ADJ_MAX)
+		bitmap_zero(fixed_adj_map, clk_div);
+	for (adj_delay = 0; adj_delay < clk_div; adj_delay++) {
+		meson_mmc_set_adjust(mmc, adj_delay);
+		nmatch = meson_mmc_tuning_transfer(mmc, opcode);
+		if (nmatch == TUNING_NUM_PER_POINT) {
+			rx_adj[adj_delay]++;
+			if (clk_div <= AML_FIXED_ADJ_MAX)
+				set_bit(adj_delay, fixed_adj_map);
+			len += sprintf(adj_print + len,
+				"%d ", adj_delay);
+		}
+	}
+
+	len += sprintf(adj_print + len, ">\n");
+	pr_debug("%s", host->adj_win);
+
+	find_best_win(mmc, rx_adj, clk_div, &best_s, &best_sz, true);
+
+	if (best_sz <= 0) {
+		if ((tuning_num++ > MAX_TUNING_RETRY) || clk_div >= 10) {
+			pr_info("%s: final result of tuning failed\n",
+				 mmc_hostname(mmc));
+			return -1;
+		}
+		clk_div++;
+		vclk &= ~CLK_DIV_MASK;
+		vclk |= clk_div & CLK_DIV_MASK;
+		writel(vclk, host->regs + SD_EMMC_CLOCK);
+		pr_info("%s: tuning failed, reduce freq and retuning\n",
+			mmc_hostname(mmc));
+		goto tuning;
+	} else if ((best_sz < clk_div) &&
+			(clk_div <= AML_FIXED_ADJ_MAX) &&
+			(clk_div >= AML_FIXED_ADJ_MIN) &&
+			!all_flag) {
+		adj_delay_find = _find_fixed_adj_valid_win(mmc,
+				opcode, fixed_adj_map, clk_div);
+	} else if (best_sz == clk_div) {
+		all_flag = true;
+		dly = readl(host->regs + SD_EMMC_DELAY1);
+		d1_dly = (dly >> 0x6) & 0x3F;
+		pr_debug("%s() d1_dly %d, window start %d, size %d\n",
+			__func__, d1_dly, best_s, best_sz);
+		if (++d1_dly > 0x3F) {
+			pr_err("%s: tuning failed\n",
+				mmc_hostname(mmc));
+			return -1;
+		}
+		dly &= ~(0x3F << 6);
+		dly |= d1_dly << 6;
+		writel(dly, host->regs + SD_EMMC_DELAY1);
+		goto tuning;
+	} else {
+		pr_debug("%s: best_s = %d, best_sz = %d\n",
+				mmc_hostname(mmc),
+				best_s, best_sz);
+	}
+
+	if (adj_delay_find == 0xff) {
+		adj_delay_find = best_s + (best_sz - 1) / 2
+		+ (best_sz - 1) % 2;
+		writel(old_dly, host->regs + SD_EMMC_DELAY1);
+		pr_info("tuning-c:%u, tuning-s:%u\n",
+			adj_delay_find % clk_div, best_sz);
+	}
+	adj_delay_find = adj_delay_find % clk_div;
+
+	meson_mmc_set_adjust(mmc, adj_delay_find);
+
+	pr_info("%s: clk= 0x%x, adj = 0x%x, dly1 = %x, dly2 = %x\n",
+			mmc_hostname(mmc),
+			readl(host->regs + SD_EMMC_CLOCK),
+			readl(host->regs + SD_EMMC_V3_ADJUST),
+			readl(host->regs + SD_EMMC_DELAY1),
+			readl(host->regs + SD_EMMC_DELAY2));
+
+	return 0;
+}
+
+//void sdio_get_card(struct mmc_host *host, struct mmc_card *card)
+//{
+//	host->card = card;
+//}
+
+static int sdio_get_device(void)
+{
+	unsigned int i, device = 0;
+
+	if (sdio_host && sdio_host->card)
+		device = sdio_host->card->cis.device;
+
+	for (i = 0; i < ARRAY_SIZE(wifi_clk); i++) {
+		if (wifi_clk[i].m_device_id == device) {
+			wifi_clk[i].m_use_flag = 1;
+			break;
+		}
+	}
+	pr_debug("sdio device is 0x%x\n", device);
+	return device;
+}
+
+static int meson_mmc_clk_set(struct mmc_host *mmc,
+			struct mmc_ios *ios, bool ddr)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	int ret = 0;
+	u32 cfg;
+	unsigned long rate = ios->clock;
+
+	/* Same request - bail-out */
+	if (aml_card_type_mmc(pdata) &&
+		host->ddr == ddr && host->req_rate == rate) {
+		dev_notice(host->dev, "[%s]bail-out,clk rate: %lu Hz, %s\n",
+			__func__, rate, mmc_hostname(mmc));
+		return 0;
+	}
+
+	/* stop clock */
+	meson_mmc_clk_gate(mmc);
+	host->req_rate = 0;
+	mmc->actual_clock = 0;
+
+	/* Stop the clock during rate change to avoid glitches */
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	cfg |= CFG_STOP_CLOCK;
+	cfg &= ~CFG_AUTO_CLK;
+	writel(cfg, host->regs + SD_EMMC_CFG);
+
+	if (ddr) {
+		/* DDR modes require higher module clock */
+		rate <<= 1;
+		cfg |= CFG_DDR;
+	} else {
+		cfg &= ~CFG_DDR;
+	}
+	writel(cfg, host->regs + SD_EMMC_CFG);
+	host->ddr = ddr;
+	pdata->ddr = ddr;
+
+	ret = no_pxp_clk_set(mmc, ios, rate);
+
+	/* We should report the real output frequency of the controller */
+	if (ddr) {
+		host->req_rate >>= 1;
+		mmc->actual_clock >>= 1;
+	}
+
+	dev_dbg(host->dev, "clk rate: %u Hz, %s\n", mmc->actual_clock, mmc_hostname(mmc));
+	if (rate != mmc->actual_clock)
+		dev_dbg(host->dev, "requested rate was %lu\n", rate);
+
+	/* (re)start clock */
+	meson_mmc_clk_ungate(mmc);
+
+	return ret;
+}
+
+static int meson_mmc_prepare_ios_clock(struct mmc_host *mmc,
+				       struct mmc_ios *ios)
+{
+	//struct amlsd_platform *pdata = mmc_priv(mmc);
+	//struct meson_host *host = pdata->host;
+	bool ddr = false;
+	int i;
+
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_DDR52:
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_HS400:
+		ddr = true;
+		break;
+	case MMC_TIMING_UHS_SDR104:
+		for (i = 0; i < ARRAY_SIZE(wifi_clk); i++) {
+			if (wifi_clk[i].m_use_flag) {
+				ios->clock = wifi_clk[i].m_uhs_max_dtr;
+				break;
+			}
+		}
+		break;
+	default:
+		ddr = false;
+		break;
+	}
+
+	return meson_mmc_clk_set(mmc, ios, ddr);
+}
+
+static void meson_mmc_check_resampling(struct mmc_host *mmc,
+				       struct mmc_ios *ios)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	struct mmc_phase *mmc_phase_set;
+	unsigned int val;
+
+	if (aml_card_type_mmc(pdata) &&
+		host->timing == ios->timing) {
+		dev_notice(host->dev, "[%s]bail-out, timing,  %s\n",
+			__func__, mmc_hostname(mmc));
+		return;
+	}
+
+	writel(0, host->regs + SD_EMMC_DELAY1);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	writel(0, host->regs + SD_EMMC_INTF3);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+	val = readl(host->regs + SD_EMMC_IRQ_EN);
+	val &= ~CFG_CMD_SETUP;
+	writel(val, host->regs + SD_EMMC_IRQ_EN);
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_HS400:
+		val = readl(host->regs + SD_EMMC_V3_ADJUST);
+		val |= DS_ENABLE;
+		writel(val, host->regs + SD_EMMC_V3_ADJUST);
+		val = readl(host->regs + SD_EMMC_IRQ_EN);
+		val |= CFG_CMD_SETUP;
+		writel(val, host->regs + SD_EMMC_IRQ_EN);
+		val = readl(host->regs + SD_EMMC_INTF3);
+		val |= SD_INTF3;
+		writel(val, host->regs + SD_EMMC_INTF3);
+		mmc_phase_set = &pdata->sd_mmc.hs4;
+		break;
+	case MMC_TIMING_MMC_HS200:
+		mmc_phase_set = &pdata->sd_mmc.hs2;
+		break;
+	case MMC_TIMING_MMC_HS:
+		val = readl(host->regs + host->data->adjust);
+		val |= CFG_ADJUST_ENABLE;
+		val &= ~CLK_ADJUST_DELAY;
+		val |= CALI_HS_50M_ADJUST << __ffs(CLK_ADJUST_DELAY);
+		writel(val, host->regs + host->data->adjust);
+		mmc_phase_set = &pdata->sd_mmc.init;
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		mmc_phase_set = &pdata->sd_mmc.init;
+		break;
+	case MMC_TIMING_SD_HS:
+		val = readl(host->regs + SD_EMMC_V3_ADJUST);
+		val |= CFG_ADJUST_ENABLE;
+		writel(val, host->regs + SD_EMMC_V3_ADJUST);
+		mmc_phase_set = &pdata->sd_mmc.init;
+		break;
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR50:
+	case MMC_TIMING_UHS_SDR104:
+		if (aml_card_type_sdio(pdata))
+			sdio_get_device();
+		mmc_phase_set = &pdata->sd_mmc.sdr;
+		break;
+	default:
+		mmc_phase_set = &pdata->sd_mmc.init;
+	}
+	meson_mmc_set_phase_delay(mmc, CLK_CORE_PHASE_MASK,
+				  mmc_phase_set->core_phase);
+	meson_mmc_set_phase_delay(mmc, CLK_TX_PHASE_MASK,
+				  mmc_phase_set->tx_phase);
+	meson_mmc_set_phase_delay(mmc, CLK_TX_DELAY_MASK(host),
+				  mmc_phase_set->tx_delay);
+
+	host->timing = ios->timing;
+	pdata->timing = ios->timing;
+	dev_dbg(host->dev, "[%s]set mmc timing:%u, %s\n",
+			__func__, ios->timing, mmc_hostname(mmc));
+}
+
+static void meson_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 bus_width, val;
+	int err;
+
+	if (host->tdma)
+		wait_for_completion(&host->drv_completion);
+	/*
+	 * GPIO regulator, only controls switching between 1v8 and
+	 * 3v3, doesn't support MMC_POWER_OFF, MMC_POWER_ON.
+	 */
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		if (!IS_ERR(mmc->supply.vmmc))
+			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
+
+		if (!IS_ERR(mmc->supply.vqmmc) && pdata->vqmmc_enabled) {
+			regulator_set_voltage_triplet(mmc->supply.vqmmc, 1700000, 1800000, 1950000);
+			regulator_disable(mmc->supply.vqmmc);
+			pdata->vqmmc_enabled = false;
+		}
+
+		break;
+
+	case MMC_POWER_UP:
+		if (!IS_ERR(mmc->supply.vmmc))
+			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);
+
+		break;
+
+	case MMC_POWER_ON:
+		if (!IS_ERR(mmc->supply.vqmmc) && !pdata->vqmmc_enabled) {
+			int ret = regulator_enable(mmc->supply.vqmmc);
+
+			if (ret < 0)
+				dev_err(host->dev,
+					"failed to enable vqmmc regulator\n");
+			else
+				pdata->vqmmc_enabled = true;
+		}
+
+		break;
+	}
+	pdata->power_mode = ios->power_mode;
+	/* Bus width */
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+		bus_width = CFG_BUS_WIDTH_1;
+		break;
+	case MMC_BUS_WIDTH_4:
+		bus_width = CFG_BUS_WIDTH_4;
+		break;
+	case MMC_BUS_WIDTH_8:
+		bus_width = CFG_BUS_WIDTH_8;
+		break;
+	default:
+		dev_err(host->dev, "Invalid ios->bus_width: %u.  Setting to 4.\n",
+			ios->bus_width);
+		bus_width = CFG_BUS_WIDTH_4;
+	}
+	pdata->bus_width = ios->bus_width;
+
+	val = readl(host->regs + SD_EMMC_CFG);
+	val &= ~CFG_BUS_WIDTH_MASK;
+	val |= FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width);
+	writel(val, host->regs + SD_EMMC_CFG);
+
+	meson_mmc_check_resampling(mmc, ios);
+	err = meson_mmc_prepare_ios_clock(mmc, ios);
+	if (err)
+		dev_err(host->dev, "Failed to set clock: %d\n,", err);
+
+	pdata->clkc = readl(host->regs + SD_EMMC_CLOCK);
+	pdata->ctrl = readl(host->regs + SD_EMMC_CFG);
+	dev_dbg(host->dev, "SD_EMMC_CFG:  0x%08x, %s\n", val, mmc_hostname(mmc));
+	dev_dbg(host->dev, "SD_EMMC_clock:  0x%08x, %s\n", readl(host->regs), mmc_hostname(mmc));
+
+	if (host->tdma)
+		complete(&host->drv_completion);
+}
+
+static void aml_sd_emmc_check_sdio_irq(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 vstat = readl(host->regs + SD_EMMC_STATUS);
+
+	if (host->sdio_irqen) {
+		if (((vstat & IRQ_SDIO) || (!(vstat & (1 << 17)))) &&
+		    host->mmc->sdio_irq_thread &&
+		    (!atomic_read(&host->mmc->sdio_irq_thread_abort))) {
+			/* pr_info("signalling irq 0x%x\n", vstat); */
+			mmc_signal_sdio_irq(host->mmc);
+		}
+	}
+}
+
+void aml_config_pinmux(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+
+	pinctrl_select_state(host->pinctrl, pdata->pins_default);
+}
+
+int aml_config_mmc_clk(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	unsigned int clk;
+	int ret = 0;
+
+	clk = clk_get_rate(host->mmc_clk);
+	pr_debug("[%s][%d] clk:%u\n", __func__, __LINE__, clk);
+	if (clk == mmc->actual_clock) {
+		pr_debug("[%s][%d] return config clk\n", __func__, __LINE__);
+		return ret;
+	}
+	ret = clk_set_parent(host->mux[0], pdata->src_clk);
+	if (ret) {
+		dev_err(host->dev, "[%s]set parent error\n", __func__);
+		return ret;
+	}
+
+	ret = clk_set_rate(host->mmc_clk, pdata->req_rate);
+	if (ret) {
+		dev_err(host->dev, "Unable to set cfg_div_clk to %lu. ret=%d\n",
+			pdata->req_rate, ret);
+		return ret;
+	}
+	return ret;
+}
+
+int aml_save_parameter(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 adj, dly1, dly2, intf3, clk, conf;
+
+	if (aml_card_type_mmc(pdata))
+		return 0;
+	aml_config_pinmux(mmc);
+	clk = readl(host->regs + SD_EMMC_CLOCK);
+	conf = readl(host->regs + SD_EMMC_CFG);
+	adj = readl(host->regs + SD_EMMC_V3_ADJUST);
+	dly1 = readl(host->regs + SD_EMMC_DELAY1);
+	dly2 = readl(host->regs + SD_EMMC_DELAY2);
+	intf3 = readl(host->regs + SD_EMMC_INTF3);
+
+	if (clk == pdata->clkc &&
+		conf == pdata->ctrl &&
+		adj == pdata->adj &&
+		dly1 == pdata->dly1 &&
+		dly2 == pdata->dly2 &&
+		intf3 == pdata->intf3) {
+		pr_debug("[%s][%d] %s\n",
+			__func__, __LINE__, mmc_hostname(mmc));
+		return 0;
+	}
+
+	pr_debug("[%s][%d] c:0x%x, r-c:0x%x, ctrl:0x%x, r-ctrl:0x%x, %s\n",
+		__func__, __LINE__, pdata->clkc, clk, pdata->ctrl, conf, mmc_hostname(mmc));
+	writel(pdata->clkc, host->regs + SD_EMMC_CLOCK);
+	writel(pdata->ctrl, host->regs + SD_EMMC_CFG);
+	writel(pdata->adj, host->regs + SD_EMMC_V3_ADJUST);
+	writel(pdata->dly1, host->regs + SD_EMMC_DELAY1);
+	writel(pdata->dly2, host->regs + SD_EMMC_DELAY2);
+	writel(pdata->intf3, host->regs + SD_EMMC_INTF3);
+	aml_config_mmc_clk(mmc);
+	return 0;
+}
+
+static void meson_mmc_request_done(struct mmc_host *mmc,
+				   struct mmc_request *mrq)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+
+	pr_debug("d %s op:%u, arg:0x%x\n",
+		mmc_hostname(mmc),
+		mrq->cmd->opcode, mrq->cmd->arg);
+	host->cmd = NULL;
+	if (host->needs_pre_post_req)
+		meson_mmc_post_req(mmc, mrq, 0);
+	aml_sd_emmc_check_sdio_irq(mmc);
+	mmc_request_done(host->mmc, mrq);
+	if (host->tdma && pdata->is_tuning == 0)
+		complete(&host->drv_completion);
+}
+
+static void meson_mmc_set_blksz(struct mmc_host *mmc, unsigned int blksz)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 cfg, blksz_old;
+
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	blksz_old = FIELD_GET(CFG_BLK_LEN_MASK, cfg);
+
+	if (!is_power_of_2(blksz))
+		dev_err(host->dev, "blksz %u is not a power of 2\n", blksz);
+
+	blksz = ilog2(blksz);
+
+	/* check if block-size matches, if not update */
+	if (blksz == blksz_old)
+		return;
+
+	dev_dbg(host->dev, "%s: update blk_len %d -> %d\n", __func__,
+		blksz_old, blksz);
+
+	cfg &= ~CFG_BLK_LEN_MASK;
+	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, blksz);
+	writel(cfg, host->regs + SD_EMMC_CFG);
+	pdata->ctrl = cfg;
+}
+
+static void meson_mmc_set_response_bits(struct mmc_command *cmd, u32 *cmd_cfg)
+{
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136)
+			*cmd_cfg |= CMD_CFG_RESP_128;
+		*cmd_cfg |= CMD_CFG_RESP_NUM;
+
+		if (!(cmd->flags & MMC_RSP_CRC))
+			*cmd_cfg |= CMD_CFG_RESP_NOCRC;
+
+		if (cmd->flags & MMC_RSP_BUSY)
+			*cmd_cfg |= CMD_CFG_R1B;
+	} else {
+		*cmd_cfg |= CMD_CFG_NO_RESP;
+	}
+}
+
+static void meson_mmc_desc_chain_transfer(struct mmc_host *mmc, u32 cmd_cfg,
+					  struct mmc_command *cmd)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	struct sd_emmc_desc *desc = host->descs;
+	struct mmc_data *data = host->cmd->data;
+	struct scatterlist *sg;
+	u32 start;
+	int i, j = 0;
+
+	if (data->flags & MMC_DATA_WRITE)
+		cmd_cfg |= CMD_CFG_DATA_WR;
+
+	if (data->blocks > 1) {
+		cmd_cfg |= CMD_CFG_BLOCK_MODE;
+		meson_mmc_set_blksz(mmc, data->blksz);
+	}
+
+	if (mmc_op_multi(cmd->opcode) && cmd->mrq->sbc) {
+		desc[j].cmd_cfg = 0;
+		desc[j].cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+					      MMC_SET_BLOCK_COUNT);
+		desc[j].cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc[j].cmd_cfg |= CMD_CFG_OWNER;
+		desc[j].cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc[j].cmd_arg = cmd->mrq->sbc->arg;
+		desc[j].cmd_resp = 0;
+		desc[j].cmd_data = 0;
+		j++;
+	}
+
+	for_each_sg(data->sg, sg, data->sg_count, i) {
+		unsigned int len = sg_dma_len(sg);
+
+		if (data->blocks > 1)
+			len /= data->blksz;
+
+		desc[i + j].cmd_cfg = cmd_cfg;
+		desc[i + j].cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, len);
+		if (i > 0)
+			desc[i + j].cmd_cfg |= CMD_CFG_NO_CMD;
+		desc[i + j].cmd_arg = host->cmd->arg;
+		desc[i + j].cmd_resp = 0;
+		desc[i + j].cmd_data = sg_dma_address(sg);
+	}
+
+	if (mmc_op_multi(cmd->opcode) && !cmd->mrq->sbc) {
+		desc[data->sg_count].cmd_cfg = 0;
+		desc[data->sg_count].cmd_cfg |=
+			FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+				   MMC_STOP_TRANSMISSION);
+		desc[data->sg_count].cmd_cfg |=
+			FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_OWNER;
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_R1B;
+		desc[data->sg_count].cmd_resp = 0;
+		desc[data->sg_count].cmd_data = 0;
+		j++;
+	}
+
+	desc[data->sg_count + j - 1].cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+	dma_wmb(); /* ensure descriptor is written before kicked */
+	start = host->descs_dma_addr | START_DESC_BUSY;
+	writel(start, host->regs + SD_EMMC_START);
+}
+
+static void meson_mmc_quirk_transfer(struct mmc_host *mmc, u32 cmd_cfg,
+					  struct mmc_command *cmd)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	struct sd_emmc_desc *desc = host->descs;
+	struct mmc_data *data = host->cmd->data;
+	u32 start, data_len;
+
+	if (data->blocks > 1) {
+		cmd_cfg |= CMD_CFG_BLOCK_MODE;
+		meson_mmc_set_blksz(mmc, data->blksz);
+		data_len = data->blocks;
+	} else {
+		data_len = data->blksz;
+	}
+
+	if (mmc_op_multi(cmd->opcode) && cmd->mrq->sbc) {
+		desc->cmd_cfg = 0;
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+					      MMC_SET_BLOCK_COUNT);
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc->cmd_cfg |= CMD_CFG_OWNER;
+		desc->cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc->cmd_arg = cmd->mrq->sbc->arg;
+		desc->cmd_resp = 0;
+		desc->cmd_data = 0;
+		desc++;
+	}
+
+	desc->cmd_cfg = cmd_cfg;
+	desc->cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, data_len);
+	desc->cmd_arg = host->cmd->arg;
+	desc->cmd_resp = 0;
+	desc->cmd_data = host->bounce_dma_addr;
+
+	if (mmc_op_multi(cmd->opcode) && !cmd->mrq->sbc) {
+		desc++;
+		desc->cmd_cfg = 0;
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+				   MMC_STOP_TRANSMISSION);
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc->cmd_cfg |= CMD_CFG_OWNER;
+		desc->cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc->cmd_cfg |= CMD_CFG_R1B;
+		desc->cmd_resp = 0;
+		desc->cmd_data = 0;
+	}
+
+	desc->cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+
+	dma_wmb(); /* ensure descriptor is written before kicked */
+	start = host->descs_dma_addr | START_DESC_BUSY | CMD_DATA_SRAM;
+	writel(start, host->regs + SD_EMMC_START);
+}
+
+static void meson_mmc_start_cmd(struct mmc_host *mmc, struct mmc_command *cmd)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	struct mmc_data *data = cmd->data;
+	u32 val, cmd_cfg = 0, cmd_data = 0;
+	unsigned int xfer_bytes = 0;
+
+	/* Setup descriptors */
+	dma_rmb();
+
+	host->cmd = cmd;
+
+	cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK, cmd->opcode);
+	cmd_cfg |= CMD_CFG_OWNER;  /* owned by CPU */
+
+	meson_mmc_set_response_bits(cmd, &cmd_cfg);
+
+	if (cmd->opcode == SD_SWITCH_VOLTAGE) {
+		val = readl(host->regs + SD_EMMC_CFG);
+		val &= ~CFG_AUTO_CLK;
+		writel(val, host->regs + SD_EMMC_CFG);
+	}
+
+	/* data? */
+	if (data) {
+		data->bytes_xfered = 0;
+		cmd_cfg |= CMD_CFG_DATA_IO;
+		cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,
+				      ilog2(meson_mmc_get_timeout_msecs(data)));
+
+		if (meson_mmc_desc_chain_mode(data)) {
+			meson_mmc_desc_chain_transfer(mmc, cmd_cfg, cmd);
+			return;
+		}
+
+		if (data->blocks > 1) {
+			cmd_cfg |= CMD_CFG_BLOCK_MODE;
+			cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK,
+					      data->blocks);
+			meson_mmc_set_blksz(mmc, data->blksz);
+		} else {
+			cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, data->blksz);
+		}
+
+		xfer_bytes = data->blksz * data->blocks;
+		if (data->flags & MMC_DATA_WRITE) {
+			cmd_cfg |= CMD_CFG_DATA_WR;
+			WARN_ON(xfer_bytes > host->bounce_buf_size);
+			sg_copy_to_buffer(data->sg, data->sg_len,
+					  host->bounce_buf, xfer_bytes);
+			dma_wmb();
+		}
+
+		cmd_data = host->bounce_dma_addr & CMD_DATA_MASK;
+
+		if (host->dram_access_quirk) {
+			meson_mmc_quirk_transfer(mmc, cmd_cfg, cmd);
+			return;
+		}
+	} else {
+		cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,
+				      ilog2(SD_EMMC_CMD_TIMEOUT));
+	}
+
+	/* Last descriptor */
+	cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+	writel(cmd_cfg, host->regs + SD_EMMC_CMD_CFG);
+	writel(cmd_data, host->regs + SD_EMMC_CMD_DAT);
+	writel(0, host->regs + SD_EMMC_CMD_RSP);
+	wmb(); /* ensure descriptor is written before kicked */
+	writel(cmd->arg, host->regs + SD_EMMC_CMD_ARG);
+}
+
+static void meson_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	unsigned long flags;
+
+	if (host->tdma &&
+		mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK) {
+		wait_for_completion(&host->drv_completion);
+		pr_debug("[%s][%d] %s opcode:%u, arg:0x%x\n",
+			__func__, __LINE__, mmc_hostname(mmc),
+			mrq->cmd->opcode, mrq->cmd->arg);
+		aml_save_parameter(mmc);
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->mmc = mmc;
+	host->needs_pre_post_req = mrq->data &&
+			!(mrq->data->host_cookie & SD_EMMC_PRE_REQ_DONE);
+
+	if (host->needs_pre_post_req) {
+		meson_mmc_get_transfer_mode(mmc, mrq);
+		if (!meson_mmc_desc_chain_mode(mrq->data))
+			host->needs_pre_post_req = false;
+	}
+
+	if (host->needs_pre_post_req)
+		meson_mmc_pre_req(mmc, mrq);
+	/* Stop execution */
+	writel(0, host->regs + SD_EMMC_START);
+
+	meson_mmc_start_cmd(mmc, mrq->cmd);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void aml_sd_emmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 vclkc = 0, virqc = 0;
+	unsigned long flags;
+
+	host->sdio_irqen = enable;
+	spin_lock_irqsave(&host->lock, flags);
+	virqc = readl(host->regs + SD_EMMC_IRQ_EN);
+	virqc &= ~IRQ_SDIO;
+	if (enable)
+		virqc |= IRQ_SDIO;
+	writel(virqc, host->regs + SD_EMMC_IRQ_EN);
+
+	if (!pdata->irq_sdio_sleep) {
+		vclkc = readl(host->regs + SD_EMMC_CLOCK);
+		vclkc |= CFG_IRQ_SDIO_SLEEP;
+		vclkc &= ~CFG_IRQ_SDIO_SLEEP_DS;
+		writel(vclkc, host->regs + SD_EMMC_CLOCK);
+		pdata->clkc = vclkc;
+		pdata->irq_sdio_sleep = 1;
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	/* check if irq already occurred */
+	aml_sd_emmc_check_sdio_irq(mmc);
+}
+
+static void meson_mmc_read_resp(struct mmc_host *mmc, struct mmc_command *cmd)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+
+	if (cmd->flags & MMC_RSP_136) {
+		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP3);
+		cmd->resp[1] = readl(host->regs + SD_EMMC_CMD_RSP2);
+		cmd->resp[2] = readl(host->regs + SD_EMMC_CMD_RSP1);
+		cmd->resp[3] = readl(host->regs + SD_EMMC_CMD_RSP);
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP);
+	}
+}
+
+static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
+{
+	struct meson_host *host = dev_id;
+	struct mmc_host *mmc = host->mmc;
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 irq_en, status, raw_status;
+	irqreturn_t ret = IRQ_NONE;
+
+	if (WARN_ON(!host))
+		return IRQ_NONE;
+
+	if (!host->cmd && (aml_card_type_mmc(pdata) ||
+			aml_card_type_non_sdio(pdata))) {
+		pr_debug("ignore irq.[%s]status:0x%x\n",
+			__func__, readl(host->regs + SD_EMMC_STATUS));
+		return IRQ_HANDLED;
+	}
+
+	irq_en = readl(host->regs + SD_EMMC_IRQ_EN);
+	raw_status = readl(host->regs + SD_EMMC_STATUS);
+	status = raw_status & irq_en;
+
+	if (status & IRQ_SDIO) {
+		if (sdio_host && host->tdma) {
+			if (sdio_host->sdio_irq_thread &&
+				(!atomic_read(&sdio_host->sdio_irq_thread_abort))) {
+				mmc_signal_sdio_irq(sdio_host);
+				if (!(status & 0x3fff))
+					return IRQ_HANDLED;
+			}
+		} else {
+			if (host->mmc->sdio_irq_thread &&
+				(!atomic_read(&host->mmc->sdio_irq_thread_abort))) {
+				mmc_signal_sdio_irq(host->mmc);
+				if (!(status & 0x3fff))
+					return IRQ_HANDLED;
+			}
+		}
+	} else if (!(status & 0x3fff)) {
+		return IRQ_HANDLED;
+	}
+
+	cmd = host->cmd;
+	data = cmd->data;
+	if (WARN_ON(!host->cmd)) {
+		dev_err(host->dev, "host->cmd is NULL.\n");
+		return IRQ_HANDLED;
+	}
+
+	cmd->error = 0;
+	if (status & IRQ_CRC_ERR) {
+		if (!pdata->is_tuning)
+			dev_err(host->dev, "%d [0x%x], CRC[0x%04x]\n",
+				cmd->opcode, cmd->arg, status);
+		if (pdata->debug_flag && !pdata->is_tuning) {
+			dev_notice(host->dev, "clktree : 0x%x,host_clock: 0x%x\n",
+				   readl(host->clk_tree_base),
+				   readl(host->regs));
+			dev_notice(host->dev, "adjust: 0x%x,cfg: 0x%x,intf3: 0x%x\n",
+				   readl(host->regs + SD_EMMC_V3_ADJUST),
+				   readl(host->regs + SD_EMMC_CFG),
+				   readl(host->regs + SD_EMMC_INTF3));
+			dev_notice(host->dev, "irq_en: 0x%x\n",
+				   readl(host->regs + 0x4c));
+			dev_notice(host->dev, "delay1: 0x%x,delay2: 0x%x\n",
+				   readl(host->regs + SD_EMMC_DELAY1),
+				   readl(host->regs + SD_EMMC_DELAY2));
+			dev_notice(host->dev, "pinmux: 0x%x\n",
+				   readl(host->pin_mux_base));
+		}
+		cmd->error = -EILSEQ;
+		ret = IRQ_WAKE_THREAD;
+		goto out;
+	}
+
+	if (status & IRQ_TIMEOUTS) {
+		if (!pdata->is_tuning && !(cmd->arg == 0xc00 || cmd->arg == 0x80000c08))
+			dev_err(host->dev, "%d [0x%x], TIMEOUT[0x%04x]\n",
+				cmd->opcode, cmd->arg, status);
+		if (pdata->debug_flag && !pdata->is_tuning) {
+			dev_notice(host->dev, "clktree : 0x%x,host_clock: 0x%x\n",
+				   readl(host->clk_tree_base),
+				   readl(host->regs));
+			dev_notice(host->dev, "adjust: 0x%x,cfg: 0x%x,intf3: 0x%x\n",
+				   readl(host->regs + SD_EMMC_V3_ADJUST),
+				   readl(host->regs + SD_EMMC_CFG),
+				   readl(host->regs + SD_EMMC_INTF3));
+			dev_notice(host->dev, "delay1: 0x%x,delay2: 0x%x\n",
+				   readl(host->regs + SD_EMMC_DELAY1),
+				   readl(host->regs + SD_EMMC_DELAY2));
+			dev_notice(host->dev, "pinmux: 0x%x\n",
+				   readl(host->pin_mux_base));
+			dev_notice(host->dev, "irq_en: 0x%x\n",
+				   readl(host->regs + 0x4c));
+		}
+		cmd->error = -ETIMEDOUT;
+		ret = IRQ_WAKE_THREAD;
+		goto out;
+	}
+
+	if (status & (IRQ_CRC_ERR | IRQ_TIMEOUTS))
+		aml_host_bus_fsm_show(host->mmc, status);
+
+	meson_mmc_read_resp(host->mmc, cmd);
+
+	if (status & IRQ_SDIO) {
+		dev_dbg(host->dev, "IRQ: SDIO TODO.\n");
+		ret = IRQ_HANDLED;
+	}
+
+	if (status & (IRQ_END_OF_CHAIN | IRQ_RESP_STATUS)) {
+		if (data && !cmd->error)
+			data->bytes_xfered = data->blksz * data->blocks;
+		if (meson_mmc_bounce_buf_read(data))
+			ret = IRQ_WAKE_THREAD;
+		else
+			ret = IRQ_HANDLED;
+	}
+
+out:
+	/* ack all raised interrupts */
+	writel(0x7fff, host->regs + SD_EMMC_STATUS);
+	if (cmd->error) {
+		/* Stop desc in case of errors */
+		u32 start = readl(host->regs + SD_EMMC_START);
+
+		if (!pdata->ignore_desc_busy && (start & START_DESC_BUSY)) {
+			start &= ~START_DESC_BUSY;
+			writel(start, host->regs + SD_EMMC_START);
+		}
+	}
+
+	if (ret == IRQ_HANDLED) {
+		meson_mmc_read_resp(host->mmc, cmd);
+		if (cmd->error && !pdata->is_tuning)
+			pr_err("cmd = %d, arg = 0x%x, dev_status = 0x%x\n",
+					cmd->opcode, cmd->arg, cmd->resp[0]);
+		meson_mmc_request_done(host->mmc, cmd->mrq);
+	} else if (ret == IRQ_NONE) {
+		dev_warn(host->dev,
+				"Unexpected IRQ! status=0x%08x, irq_en=0x%08x\n",
+				raw_status, irq_en);
+	}
+
+	return ret;
+}
+
+static int meson_mmc_wait_desc_stop(struct meson_host *host)
+{
+	u32 status;
+
+	/*
+	 * It may sometimes take a while for it to actually halt. Here, we
+	 * are giving it 5ms to comply
+	 *
+	 * If we don't confirm the descriptor is stopped, it might raise new
+	 * IRQs after we have called mmc_request_done() which is bad.
+	 */
+
+	return readl_poll_timeout(host->regs + SD_EMMC_STATUS, status,
+				  !(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
+				  100, 10000);
+}
+
+static irqreturn_t meson_mmc_irq_thread(int irq, void *dev_id)
+{
+	struct meson_host *host = dev_id;
+	struct mmc_command *cmd = host->cmd;
+	struct mmc_data *data;
+	unsigned int xfer_bytes;
+
+	if (WARN_ON(!cmd))
+		return IRQ_NONE;
+
+	if (cmd->error) {
+		meson_mmc_wait_desc_stop(host);
+		meson_mmc_request_done(host->mmc, cmd->mrq);
+
+		return IRQ_HANDLED;
+	}
+
+	data = cmd->data;
+	if (meson_mmc_bounce_buf_read(data)) {
+		xfer_bytes = data->blksz * data->blocks;
+		WARN_ON(xfer_bytes > host->bounce_buf_size);
+		sg_copy_from_buffer(data->sg, data->sg_len,
+				    host->bounce_buf, xfer_bytes);
+	}
+
+	meson_mmc_read_resp(host->mmc, cmd);
+	meson_mmc_request_done(host->mmc, cmd->mrq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * NOTE: we only need this until the GPIO/pinctrl driver can handle
+ * interrupts.  For now, the MMC core will use this for polling.
+ */
+static int meson_mmc_get_cd(struct mmc_host *mmc)
+{
+	int status = mmc_gpio_get_cd(mmc);
+
+	if (status == -EINVAL)
+		return 1; /* assume present */
+
+	return !status;
+}
+
+static void meson_mmc_cfg_init(struct meson_host *host)
+{
+	u32 cfg = 0;
+
+	cfg |= FIELD_PREP(CFG_RESP_TIMEOUT_MASK,
+			  ilog2(SD_EMMC_CFG_RESP_TIMEOUT));
+	cfg |= FIELD_PREP(CFG_RC_CC_MASK, ilog2(SD_EMMC_CFG_CMD_GAP));
+	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, ilog2(SD_EMMC_CFG_BLK_SIZE));
+
+	/* abort chain on R/W errors */
+
+	writel(cfg, host->regs + SD_EMMC_CFG);
+
+	host->timing = -1;
+}
+
+static int meson_mmc_card_busy(struct mmc_host *mmc)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	u32 regval, val;
+	int ret = 0;
+
+	if (host->tdma)
+		wait_for_completion(&host->drv_completion);
+
+	regval = readl(host->regs + SD_EMMC_STATUS);
+	if (!aml_card_type_mmc(pdata) && host->sd_sdio_switch_volat_done) {
+		val = readl(host->regs + SD_EMMC_CFG);
+		val |= CFG_AUTO_CLK;
+		writel(val, host->regs + SD_EMMC_CFG);
+		host->sd_sdio_switch_volat_done = 0;
+		pdata->ctrl = val;
+	}
+
+	/* We are only interrested in lines 0 to 3, so mask the other ones */
+	if (!aml_card_type_mmc(pdata))
+		ret = !(FIELD_GET(STATUS_DATI, regval) & 0xf);
+	else
+		ret = !(FIELD_GET(STATUS_DATI, regval) & 0x1);
+
+	if (host->tdma)
+		complete(&host->drv_completion);
+
+	return ret;
+}
+
+static int meson_mmc_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	int err;
+
+	if (IS_ERR(mmc->supply.vqmmc) && IS_ERR(mmc->supply.vmmc))
+		return 0;
+	/* vqmmc regulator is available */
+	if (!IS_ERR(mmc->supply.vqmmc)) {
+		/*
+		 * The usual amlogic setup uses a GPIO to switch from one
+		 * regulator to the other. While the voltage ramp up is
+		 * pretty fast, care must be taken when switching from 3.3v
+		 * to 1.8v. Please make sure the regulator framework is aware
+		 * of your own regulator constraints
+		 */
+		err = mmc_regulator_set_vqmmc(mmc, ios);
+
+		if (!err && ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)
+			host->sd_sdio_switch_volat_done = 1;
+
+		return err;
+	}
+
+	/* no vqmmc regulator, assume fixed regulator at 3/3.3V */
+	if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+		return 0;
+
+	return -EINVAL;
+}
+
+static int meson_mmc_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct amlsd_platform *pdata = mmc_priv(mmc);
+	struct meson_host *host = pdata->host;
+	int err = 0;
+
+	if (host->tdma)
+		wait_for_completion(&host->drv_completion);
+	pdata->is_tuning = 1;
+	err = meson_mmc_fixadj_tuning(mmc, opcode);
+	pdata->is_tuning = 0;
+	if (host->tdma)
+		complete(&host->drv_completion);
+
+	return err;
+}
+
+//static void sdio_rescan(struct mmc_host *mmc)
+//{
+//	int ret;
+//
+//	mmc->rescan_entered = 0;
+//	//mmc->host_rescan_disable = false;
+//	mmc_detect_change(mmc, 0);
+//	// start the delayed_work
+//	ret = flush_work(&mmc->detect.work);
+//	// wait for the delayed_work to finish
+//	if (!ret)
+//		pr_info("Error: delayed_work mmc_rescan() already idle!\n");
+//}
+
+//static void sdio_reset_comm(struct mmc_card *card)
+//{
+//	struct mmc_host *host = card->host;
+//	int i = 0, err = 0;
+//
+//	while (!card->sdio_func[i] && i < SDIO_MAX_FUNCS)
+//		i++;
+//	if (WARN_ON(i == SDIO_MAX_FUNCS))
+//		return;
+//	sdio_claim_host(card->sdio_func[i]);
+//	err = mmc_sw_reset(host);
+//	sdio_release_host(card->sdio_func[i]);
+//	if (err)
+//		pr_info("%s Failed, error = %d\n", __func__, err);
+//	return;
+//}
+//
+//void sdio_reinit(void)
+//{
+//	if (sdio_host) {
+//		struct mmc_ios *ios = &sdio_host->ios;
+//
+//		if (sdio_host->card) {
+//			if (ios)
+//				ios->timing = 0;
+//			sdio_reset_comm(sdio_host->card);
+//		}
+//		else
+//			sdio_rescan(sdio_host);
+//	} else {
+//		pr_info("Error: sdio_host is NULL\n");
+//	}
+//
+//	pr_debug("[%s] finish\n", __func__);
+//}
+//EXPORT_SYMBOL(sdio_reinit);
+//
+//void sdio_clk_always_on(bool clk_aws_on)
+//{
+//	struct meson_host *host = NULL;
+//	struct amlsd_platform *pdata = NULL;
+//	u32 conf = 0;
+//
+//	if (sdio_host) {
+//		pdata = mmc_priv(sdio_host);
+//		host = pdata->host;
+//		conf = readl(host->regs + SD_EMMC_CFG);
+//		if (clk_aws_on)
+//			conf &= ~CFG_AUTO_CLK;
+//		else
+//			conf |= CFG_AUTO_CLK;
+//		writel(conf, host->regs + SD_EMMC_CFG);
+//		pr_info("[%s] clk:0x%x, cfg:0x%x\n",
+//				__func__, readl(host->regs + SD_EMMC_CLOCK),
+//				readl(host->regs + SD_EMMC_CFG));
+//	} else {
+//		pr_info("Error: sdio_host is NULL\n");
+//	}
+//
+//	pr_info("[%s] finish\n", __func__);
+//}
+//EXPORT_SYMBOL(sdio_clk_always_on);
+//
+//void sdio_set_max_regs(unsigned int size)
+//{
+//	if (sdio_host) {
+//		sdio_host->max_req_size = size;
+//		sdio_host->max_seg_size = sdio_host->max_req_size;
+//	} else {
+//		pr_info("Error: sdio_host is NULL\n");
+//	}
+//
+//	pr_info("[%s] finish\n", __func__);
+//}
+//EXPORT_SYMBOL(sdio_set_max_regs);
+//
+///*this function tells wifi is using sd(sdiob) or sdio(sdioa)*/
+//const char *get_wifi_inf(void)
+//{
+//	if (sdio_host)
+//		return mmc_hostname(sdio_host);
+//	else
+//		return "sdio";
+//}
+//EXPORT_SYMBOL(get_wifi_inf);
+//
+//int sdio_get_vendor(void)
+//{
+//	int vendor = 0;
+//
+//	if (sdio_host && sdio_host->card)
+//		vendor = sdio_host->card->cis.vendor;
+//
+//	pr_info("sdio vendor is 0x%x\n", vendor);
+//	return vendor;
+//}
+//EXPORT_SYMBOL(sdio_get_vendor);
+
+//static struct pinctrl * __must_check aml_pinctrl_select(struct mmc_host *mmc,
+//							const char *name)
+//{
+//	struct amlsd_platform *pdata = mmc_priv(mmc);
+//	struct meson_host *host = pdata->host;
+//	struct pinctrl *p = host->pinctrl;
+//	struct pinctrl_state *s;
+//	int ret = 1;
+//
+//	if (!p) {
+//		dev_err(host->dev, "%s NULL POINT!!\n", __func__);
+//		return ERR_PTR(ret);
+//	}
+//
+//	s = pinctrl_lookup_state(p, name);
+//	if (IS_ERR(s)) {
+//		pr_err("lookup %s fail\n", name);
+//		devm_pinctrl_put(p);
+//		return ERR_CAST(s);
+//	}
+//
+//	ret = pinctrl_select_state(p, s);
+//	if (ret < 0) {
+//		pr_err("select %s fail\n", name);
+//		devm_pinctrl_put(p);
+//		return ERR_PTR(ret);
+//	}
+//	return p;
+//}
+//
+//static int aml_uart_switch(struct mmc_host *mmc, bool on)
+//{
+//	//struct amlsd_platform *pdata = mmc_priv(mmc);
+//	//struct meson_host *host = pdata->host;
+//	struct pinctrl *pc;
+//	char *name[2] = {
+//		"sd_to_ao_uart_pins",
+//		"ao_to_sd_uart_pins",
+//	};
+//
+//	pc = aml_pinctrl_select(mmc, name[on]);
+//	return on;
+//}
+//
+//static int aml_is_sduart(struct mmc_host *mmc)
+//{
+//	struct amlsd_platform *pdata = mmc_priv(mmc);
+//	struct meson_host *host = pdata->host;
+//	int in = 0, i;
+//	int high_cnt = 0, low_cnt = 0;
+//	u32 vstat = 0;
+//
+//	if (pdata->is_uart)
+//		return 0;
+//	//if (!pdata->sd_uart_init) {
+//	//	aml_uart_switch(mmc, 0);
+//	//} else {
+//	//	in = (readl(host->pin_mux_base) & DATA3_PINMUX_MASK) >>
+//	//		__ffs(DATA3_PINMUX_MASK);
+//	//	if (in == 2)
+//	//		return 1;
+//	//	else
+//	//		return 0;
+//	//}
+//	for (i = 0; ; i++) {
+//		mdelay(1);
+//		vstat = readl(host->regs + SD_EMMC_STATUS) & 0xffffffff;
+//		if (vstat & 0x80000) {
+//			high_cnt++;
+//			low_cnt = 0;
+//		} else {
+//			low_cnt++;
+//			high_cnt = 0;
+//		}
+//		if (high_cnt > 100 || low_cnt > 100)
+//			break;
+//	}
+//	if (low_cnt > 100)
+//		in = 1;
+//	return in;
+//}
+
+//static int aml_is_card_insert(struct mmc_gpio *ctx)
+//{
+//	int ret = 0, in_count = 0, out_count = 0, i;
+//
+//	if (ctx->cd_gpio) {
+//		for (i = 0; i < 200; i++) {
+//			ret = gpiod_get_value(ctx->cd_gpio);
+//			if (ret)
+//				out_count++;
+//			in_count++;
+//			if (out_count > 100 || in_count > 100)
+//				break;
+//		}
+//		if (out_count > 100)
+//			ret = 1;
+//		else if (in_count > 100)
+//			ret = 0;
+//	}
+////        if (ctx->override_cd_active_level)
+//  //              ret = !ret; /* reverse, so ---- 0: no inserted  1: inserted */
+//
+//	return ret;
+//}
+
+//int meson_mmc_cd_detect(struct mmc_host *mmc)
+//{
+//	int gpio_val, val, ret = 0;
+//	struct amlsd_platform *pdata = mmc_priv(mmc);
+//	struct meson_host *host = pdata->host;
+//	struct mmc_gpio *ctx = mmc->slot.handler_priv;
+//
+//	if (host->tdma)
+//		wait_for_completion(&host->drv_completion);
+//	gpio_val = aml_is_card_insert(ctx);
+//	dev_notice(host->dev, "card %s\n", gpio_val ? "OUT" : "IN");
+//	mmc->trigger_card_event = true;
+//	if (!gpio_val) {//card insert
+//		if (pdata->card_insert)
+//			goto out;
+//		pdata->card_insert = 1;
+//		val = aml_is_sduart(mmc);
+//		dev_notice(host->dev, " %s insert\n", val ? "UART" : "SDCARD");
+//		if (val) {//uart insert
+//			pdata->is_uart = 1;
+//			aml_uart_switch(mmc, 1);
+//			mmc->caps &= ~MMC_CAP_4_BIT_DATA;
+//			pdata->pins_default = pinctrl_lookup_state(host->pinctrl,
+//								  "sd_1bit_pins");
+//			if (IS_ERR(pdata->pins_default)) {
+//				ret = PTR_ERR(pdata->pins_default);
+//				goto out;
+//			}
+//		} else {//sdcard insert
+//			aml_uart_switch(mmc, 0);
+//			mmc->caps |= MMC_CAP_4_BIT_DATA;
+//			pdata->pins_default = pinctrl_lookup_state(host->pinctrl,
+//								  "sd_default");
+//		}
+//	} else { //card out
+//		if (!pdata->card_insert)
+//			goto out;
+//		if (pdata->is_uart) {
+//			pdata->is_uart = 0;
+//			devm_free_irq(mmc->parent, host->cd_irq, mmc);
+//		}
+//		pdata->card_insert = 0;
+//		aml_uart_switch(mmc, 0);
+//	}
+//	if (!pdata->is_uart)
+//		mmc_detect_change(mmc, msecs_to_jiffies(200));
+//
+//out:
+//	if (host->tdma)
+//		complete(&host->drv_completion);
+//	return ret;
+//}
+
+static const struct mmc_host_ops meson_mmc_ops = {
+	.request	= meson_mmc_request,
+	.set_ios	= meson_mmc_set_ios,
+	.enable_sdio_irq = aml_sd_emmc_enable_sdio_irq,
+	.get_cd         = meson_mmc_get_cd,
+	.pre_req	= meson_mmc_pre_req,
+	.post_req	= meson_mmc_post_req,
+	.execute_tuning = meson_mmc_execute_tuning,
+//	.hs400_complete = aml_post_hs400_timming,
+	.card_busy	= meson_mmc_card_busy,
+	.start_signal_voltage_switch = meson_mmc_voltage_switch,
+//	.init_card      = sdio_get_card,
+};
+
+static void add_dtbkey(struct work_struct *work)
+{
+	int ret;
+	struct meson_host *host =
+		container_of(work, struct meson_host, dtbkey.work);
+	struct mmc_host *mmc = host->mmc;
+
+	if (mmc->card) {
+		emmc_key_init(mmc->card, &ret);
+		if (ret)
+			pr_err("%s:%d,emmc_key_init fail\n", __func__, __LINE__);
+
+		amlmmc_dtb_init(mmc->card, &ret);
+		if (ret)
+			pr_err("%s:%d,amlmmc_dtb_init fail\n", __func__, __LINE__);
+	} else {
+		schedule_delayed_work(&host->dtbkey, 50);
+	}
+}
+
+static int g12a_mmc_probe(struct platform_device *pdev)
+{
+	struct meson_host *host = NULL;
+	struct mmc_host *mmc = NULL;
+	struct amlsd_platform *pdata = NULL;
+	int ret;
+	u32 i, dev_index = 0, dev_num = 0;
+
+	host = kzalloc(sizeof(*host), GFP_KERNEL);
+	if (!host)
+		return -ENODEV;
+	/* The G12A SDIO Controller needs an SRAM bounce buffer */
+	host->dram_access_quirk = device_property_read_bool(&pdev->dev,
+				"amlogic,dram-access-quirk");
+	host->tdma = device_property_read_bool(&pdev->dev,
+				"time-sharing-mult");
+	host->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, host);
+	host->data = (struct meson_mmc_data *)
+		of_device_get_match_data(&pdev->dev);
+
+	if (!host->data) {
+		ret = -EINVAL;
+		goto free_host;
+	}
+	ret = device_reset_optional(&pdev->dev);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "device reset failed: %d\n", ret);
+
+		return ret;
+	}
+
+	host->res[0] = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->regs = devm_ioremap_resource(&pdev->dev, host->res[0]);
+	if (IS_ERR(host->regs)) {
+		ret = PTR_ERR(host->regs);
+		goto free_host;
+	}
+
+	host->res[1] = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	host->clk_tree_base = ioremap(host->res[1]->start, resource_size(host->res[1]));
+	if (IS_ERR(host->clk_tree_base)) {
+		ret = PTR_ERR(host->clk_tree_base);
+		goto free_host;
+	}
+	//val = readl(host->clk_tree_base);
+	//if (aml_card_type_non_sdio(pdata))
+	//	val &= EMMC_SDIO_CLOCK_FELD;
+	//else
+	//	val &= ~EMMC_SDIO_CLOCK_FELD;
+	//writel(val, host->clk_tree_base);
+
+	host->res[2] = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	host->pin_mux_base = ioremap(host->res[2]->start, resource_size(host->res[2]));
+	if (IS_ERR(host->pin_mux_base)) {
+		ret = PTR_ERR(host->pin_mux_base);
+		goto free_host;
+	}
+
+	host->irq = platform_get_irq(pdev, 0);
+	if (host->irq <= 0) {
+		ret = -EINVAL;
+		goto free_host;
+	}
+
+	host->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(host->pinctrl)) {
+		ret = PTR_ERR(host->pinctrl);
+		goto free_host;
+	}
+
+	host->core_clk = devm_clk_get(&pdev->dev, "core");
+	if (IS_ERR(host->core_clk)) {
+		ret = PTR_ERR(host->core_clk);
+		goto free_host;
+	}
+
+	ret = clk_prepare_enable(host->core_clk);
+	if (ret)
+		goto free_host;
+
+	ret = meson_mmc_clk_init(host);
+	if (ret)
+		goto err_core_clk;
+
+	/* set config to sane default */
+	meson_mmc_cfg_init(host);
+
+	/* Stop execution */
+	writel(0, host->regs + SD_EMMC_START);
+
+	/* clear, ack and enable interrupts */
+	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
+	       host->regs + SD_EMMC_STATUS);
+	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
+	       host->regs + SD_EMMC_IRQ_EN);
+
+	ret = request_threaded_irq(host->irq, meson_mmc_irq,
+				   meson_mmc_irq_thread, IRQF_ONESHOT,
+				   dev_name(&pdev->dev), host);
+	if (ret)
+		goto err_init_clk;
+
+	/*
+	 * At the moment, we don't know how to reliably enable HS400.
+	 * From the different datasheets, it is not even clear if this mode
+	 * is officially supported by any of the SoCs
+	 */
+	if (host->dram_access_quirk) {
+		/*
+		 * The MMC Controller embeds 1,5KiB of internal SRAM
+		 * that can be used to be used as bounce buffer.
+		 * In the case of the G12A SDIO controller, use these
+		 * instead of the DDR memory
+		 */
+		host->bounce_buf_size = SD_EMMC_SRAM_DATA_BUF_LEN;
+		host->bounce_buf = host->regs + SD_EMMC_SRAM_DATA_BUF_OFF;
+		host->bounce_dma_addr = host->res[0]->start + SD_EMMC_SRAM_DATA_BUF_OFF;
+
+		host->descs = host->regs + SD_EMMC_SRAM_DESC_BUF_OFF;
+		host->descs_dma_addr = host->res[0]->start + SD_EMMC_SRAM_DESC_BUF_OFF;
+
+	} else {
+		/* data bounce buffer */
+		host->bounce_buf_size = SD_EMMC_MAX_REQ_SIZE;
+		host->bounce_buf =
+			dma_alloc_coherent(host->dev, host->bounce_buf_size,
+					   &host->bounce_dma_addr, GFP_KERNEL);
+		if (!host->bounce_buf) {
+			dev_err(host->dev, "Unable to map allocate DMA bounce buffer.\n");
+			ret = -ENOMEM;
+			goto err_free_irq;
+		}
+
+		host->descs = dma_alloc_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,
+			      &host->descs_dma_addr, GFP_KERNEL);
+		if (!host->descs) {
+			ret = -ENOMEM;
+			goto err_bounce_buf;
+		}
+	}
+
+	host->blk_test = devm_kzalloc(host->dev, 512 * CALI_BLK_CNT, GFP_KERNEL);
+	if (!host->blk_test) {
+		ret = -ENOMEM;
+		goto err_bounce_buf;
+	}
+	host->adj_win = devm_kzalloc(host->dev, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN, GFP_KERNEL);
+	if (!host->adj_win) {
+		ret = -ENOMEM;
+		goto err_free_irq;
+	}
+
+	if (host->tdma) {
+		init_completion(&host->drv_completion);
+		host->drv_completion.done = 1;
+		dev_num = MMC_DEVICES_NUM;
+		dev_index = 1;
+	}
+	for (i = dev_index; i <= dev_num; i++) {
+		mmc = mmc_alloc_host(sizeof(struct amlsd_platform), &pdev->dev);
+		if (!mmc)
+			return -ENOMEM;
+
+		pdata = mmc_priv(mmc);
+		memset(pdata, 0, sizeof(struct amlsd_platform));
+		pdata->host = host;
+		pdata->mmc = mmc;
+		pdata->timing = -1;
+		pdata->req_rate = -1;
+		pdata->ddr = 0;
+		pdata->vqmmc_enabled = false;
+		pdata->src_clk = NULL;
+		pdata->clkc = readl(host->regs + SD_EMMC_CLOCK);
+		pdata->ctrl = readl(host->regs + SD_EMMC_CFG);
+
+		/* Get regulators and the supported OCR mask */
+		ret = mmc_regulator_get_supply(mmc);
+		if (ret) {
+			dev_warn(&pdev->dev, "power regulator get failed!\n");
+			goto free_host;
+		}
+
+		if (host->tdma)
+			ret = tdma_of_parse(mmc, i);
+		else
+			ret = mmc_of_parse(mmc);
+		if (ret) {
+			if (ret != -EPROBE_DEFER)
+				dev_warn(&pdev->dev, "error parsing DT: %d\n", ret);
+			goto free_host;
+		}
+		amlogic_of_parse(mmc);
+		mmc->hold_retune = 1;
+
+		if (aml_card_type_non_sdio(pdata)) {
+			if (!IS_ERR(mmc->supply.vqmmc))
+				regulator_set_voltage_triplet(mmc->supply.vqmmc,
+					1700000, 1800000, 1950000);
+		}
+
+		if (aml_card_type_non_sdio(pdata))
+			pdata->pins_default = pinctrl_lookup_state(host->pinctrl,
+								  "sd_1bit_pins");
+		else
+			pdata->pins_default = pinctrl_lookup_state(host->pinctrl,
+								  "default");
+		if (IS_ERR(pdata->pins_default)) {
+			ret = PTR_ERR(pdata->pins_default);
+			goto free_host;
+		}
+
+		if (aml_card_type_non_sdio(pdata))
+			pdata->pins_clk_gate =
+				pinctrl_lookup_state(host->pinctrl,
+						"sd_clk-gate");
+		if (aml_card_type_sdio(pdata))
+			pdata->pins_clk_gate =
+				pinctrl_lookup_state(host->pinctrl,
+						"sdio_clk-gate");
+
+		if (IS_ERR(pdata->pins_clk_gate)) {
+			dev_warn(&pdev->dev,
+				 "can't get clk-gate pinctrl, using clk_stop bit\n");
+			pdata->pins_clk_gate = NULL;
+		}
+
+		if (aml_card_type_mmc(pdata))
+			mmc->caps |= MMC_CAP_CMD23;
+		if (host->dram_access_quirk) {
+			/* Limit segments to 1 due to low available sram memory */
+			mmc->max_segs = 1;
+			/* Limit to the available sram memory */
+			mmc->max_blk_count = SD_EMMC_SRAM_DATA_BUF_LEN /
+					     mmc->max_blk_size;
+		} else {
+			mmc->max_blk_count = CMD_CFG_LENGTH_MASK;
+			mmc->max_segs = SD_EMMC_MAX_SEGS;
+		}
+		mmc->max_req_size = SD_EMMC_MAX_REQ_SIZE;
+		mmc->max_seg_size = mmc->max_req_size;
+		mmc->ocr_avail = 0x200080;
+		mmc->max_current_180 = 300; /* 300 mA in 1.8V */
+		mmc->max_current_330 = 300; /* 300 mA in 3.3V */
+
+		if (aml_card_type_sdio(pdata)) {
+			/* do NOT run mmc_rescan for the first time */
+			mmc->rescan_entered = 1;
+		} else {
+			mmc->rescan_entered = 0;
+		}
+		if (aml_card_type_non_sdio(pdata))
+			pdata->pins_default = pinctrl_lookup_state(host->pinctrl, "sd_default");
+
+		mmc->ops = &meson_mmc_ops;
+		mmc_add_host(mmc);
+
+		if (aml_card_type_sdio(pdata)) {/* if sdio_wifi */
+			sdio_host = mmc;
+		}
+
+		if (aml_card_type_mmc(pdata)) {
+			INIT_DELAYED_WORK(&host->dtbkey, add_dtbkey);
+			schedule_delayed_work(&host->dtbkey, 50);
+		}
+
+// #if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+// #ifdef CONFIG_ANDROID_VENDOR_HOOKS
+// 		if (aml_card_type_non_sdio(pdata)) {
+// 			ret =
+// 			register_trace_android_vh_mmc_sd_update_cmdline_timing(SD_CMD_TIMING,
+// 				NULL);
+// 			if (ret)
+// 				pr_err("register update_cmdline_timing failed, err:%d\n", ret);
+// 			ret =
+// 			register_trace_android_vh_mmc_sd_update_dataline_timing(SD_DATA_TIMING,
+// 				NULL);
+// 			if (ret)
+// 				pr_err("register update_dataline timing failed, err:%d\n", ret);
+// 		}
+// #endif
+// #endif
+		dev_notice(host->dev, "host probe success!, %s\n", mmc_hostname(mmc));
+	}
+	return 0;
+
+err_bounce_buf:
+	if (!host->dram_access_quirk)
+		dma_free_coherent(host->dev, host->bounce_buf_size,
+				  host->bounce_buf, host->bounce_dma_addr);
+err_free_irq:
+	devm_kfree(host->dev, host->adj_win);
+	free_irq(host->irq, host);
+err_init_clk:
+	clk_disable_unprepare(host->mmc_clk);
+err_core_clk:
+	clk_disable_unprepare(host->core_clk);
+free_host:
+	dev_notice(host->dev, "host probe failed!\n");
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int g12a_mmc_remove(struct platform_device *pdev)
+{
+	struct meson_host *host = dev_get_drvdata(&pdev->dev);
+
+	mmc_remove_host(host->mmc);
+
+	/* disable interrupts */
+	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	free_irq(host->irq, host);
+
+	dma_free_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,
+			  host->descs, host->descs_dma_addr);
+
+	if (!host->dram_access_quirk)
+		dma_free_coherent(host->dev, host->bounce_buf_size,
+				  host->bounce_buf, host->bounce_dma_addr);
+
+	clk_disable_unprepare(host->mmc_clk);
+	clk_disable_unprepare(host->core_clk);
+
+	devm_kfree(host->dev, host->adj_win);
+	mmc_free_host(host->mmc);
+	return 0;
+}
+
+static const struct meson_mmc_data meson_g12a_data = {
+	.tx_delay_mask	= CLK_V3_TX_DELAY_MASK,
+	.rx_delay_mask	= CLK_V3_RX_DELAY_MASK,
+	.always_on	= CLK_V3_ALWAYS_ON,
+	.adjust		= SD_EMMC_V3_ADJUST,
+};
+
+static const struct of_device_id g12a_mmc_of_match[] = {
+	{ .compatible = "amlogic,meson-g12a-mmc", .data = &meson_g12a_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, g12a_mmc_of_match);
+
+static struct platform_driver g12a_mmc_driver = {
+	.probe		= g12a_mmc_probe,
+	.remove		= g12a_mmc_remove,
+	.driver		= {
+		.name = G12A_DRIVER_NAME,
+		.of_match_table = of_match_ptr(g12a_mmc_of_match),
+	},
+};
+
+int __init g12a_mmc_init(void)
+{
+	return platform_driver_register(&g12a_mmc_driver);
+}
+
+void __exit g12a_mmc_exit(void)
+{
+	platform_driver_unregister(&g12a_mmc_driver);
+}
+
+//module_platform_driver(g12a_mmc_driver);
+
+//MODULE_DESCRIPTION("Amlogic G12a SD/eMMC driver");
+//MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
+//MODULE_LICENSE("GPL v2");
diff --git a/drivers/amlogic/mmc/host/meson-gx-mmc.c b/drivers/amlogic/mmc/host/meson-gx-mmc.c
new file mode 100644
index 000000000..1c6882498
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-gx-mmc.c
@@ -0,0 +1,4236 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/iopoll.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+#include <linux/interrupt.h>
+#include <linux/bitfield.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_sd.h>
+#include <linux/delay.h>
+#include <core.h>
+#include <mmc_ops.h>
+#include <linux/time.h>
+#include <linux/random.h>
+#include <linux/gpio/consumer.h>
+#include <linux/sched/clock.h>
+#include <linux/debugfs.h>
+#include "mmc_key.h"
+#include "mmc_dtb.h"
+#include <linux/proc_fs.h>
+//KV_TODO: modify
+// #if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+// #include <trace/hooks/mmc.h>
+// #endif
+#include <linux/moduleparam.h>
+#include <linux/amlogic/gki_module.h>
+
+#include "meson-cqhci.h"
+
+struct mmc_gpio {
+	struct gpio_desc *ro_gpio;
+	struct gpio_desc *cd_gpio;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	char *ro_label;
+	char *cd_label;
+	u32 cd_debounce_delay_ms;
+};
+
+struct wifi_clk_table wifi_clk[WIFI_CLOCK_TABLE_MAX] = {
+	{"8822BS", 0, 0xb822, 167000000},
+	{"8822CS", 0, 0xc822, 167000000},
+	{"qca6174", 0, 0x50a, 167000000}
+};
+
+struct mmc_host *sdio_host;
+static char *caps2_quirks = "none";
+
+//#if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+//void mmc_sd_update_cmdline_timing(void *data, struct mmc_card *card, int *err)
+//{
+//	/* nothing */
+//	*err = 0;
+//}
+//
+//void mmc_sd_update_dataline_timing(void *data, struct mmc_card *card, int *err)
+//{
+//	/* nothing */
+//	*err = 0;
+//}
+//
+//#define SD_CMD_TIMING mmc_sd_update_cmdline_timing
+//#define SD_DATA_TIMING mmc_sd_update_dataline_timing
+//#endif
+
+static inline u32 aml_mv_dly1_nommc(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 18);
+}
+
+static inline u32 aml_mv_dly1(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 18) | ((x) << 24);
+}
+
+static inline u32 aml_mv_dly2(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12) | ((x) << 24);
+}
+
+static inline u32 aml_mv_dly2_nocmd(u32 x)
+{
+	return (x) | ((x) << 6) | ((x) << 12);
+}
+
+int amlogic_of_parse(struct mmc_host *host)
+{
+	struct device *dev = host->parent;
+	struct meson_host *mmc = mmc_priv(host);
+
+	if (device_property_read_u32(dev, "init_core_phase",
+			&mmc->sd_mmc.init.core_phase) < 0)
+		mmc->sd_mmc.init.core_phase = 2;
+	if (device_property_read_u32(dev, "init_tx_phase",
+			&mmc->sd_mmc.init.tx_phase) < 0)
+		mmc->sd_mmc.init.tx_delay = 0;
+	if (device_property_read_u32(dev, "hs2_core_phase",
+			&mmc->sd_mmc.hs2.core_phase) < 0)
+		mmc->sd_mmc.hs2.core_phase = 2;
+	if (device_property_read_u32(dev, "hs2_tx_phase",
+			&mmc->sd_mmc.hs2.tx_phase) < 0)
+		mmc->sd_mmc.hs2.tx_delay = 0;
+	if (device_property_read_u32(dev, "hs4_core_phase",
+			&mmc->sd_mmc.hs4.core_phase) < 0)
+		mmc->sd_mmc.hs4.core_phase = 0;
+	if (device_property_read_u32(dev, "hs4_tx_phase",
+			&mmc->sd_mmc.hs4.tx_phase) < 0)
+		mmc->sd_mmc.hs4.tx_phase = 0;
+	if (device_property_read_u32(dev, "src_clk_rate",
+			&mmc->src_clk_rate) < 0)
+		mmc->src_clk_rate = 1000000000;
+	if (device_property_read_u32(dev, "sdr_tx_delay",
+			&mmc->sd_mmc.sdr.tx_delay) < 0)
+		mmc->sd_mmc.sdr.tx_delay = 0;
+	if (device_property_read_u32(dev, "sdr_core_phase",
+			&mmc->sd_mmc.sdr.core_phase) < 0)
+		mmc->sd_mmc.sdr.core_phase = 2;
+	if (device_property_read_u32(dev, "sdr_tx_phase",
+			&mmc->sd_mmc.sdr.tx_phase) < 0)
+		mmc->sd_mmc.sdr.tx_phase = 0;
+
+	if (device_property_read_bool(dev, "ignore_desc_busy"))
+		mmc->ignore_desc_busy = true;
+	else
+		mmc->ignore_desc_busy = false;
+
+	if (device_property_read_bool(dev, "use_intf3_tuning"))
+		mmc->use_intf3_tuning = true;
+	else
+		mmc->use_intf3_tuning = false;
+
+	if (device_property_read_u32(dev, "card_type",
+			&mmc->card_type) < 0) {
+		dev_err(host->parent,
+			"No config cart type value\n");
+		return -1;
+	}
+
+	if (device_property_read_u32(dev, "nwr_cnt", &mmc->nwr_cnt) < 0)
+		mmc->nwr_cnt = 0;
+
+	if (device_property_read_u32(dev, "tx_delay",
+				&mmc->sd_mmc.hs4.tx_delay) < 0)
+		mmc->sd_mmc.hs4.tx_delay = 16;
+
+	device_property_read_u32(dev, "save_para", &mmc->save_para);
+	device_property_read_u32(dev, "compute_cmd_delay",
+				&mmc->compute_cmd_delay);
+	device_property_read_u32(dev, "compute_coef", &mmc->compute_coef);
+
+	if (device_property_read_bool(dev, "mmc_debug_flag"))
+		mmc->debug_flag = 0;
+	else
+		mmc->debug_flag = 1;
+
+	if (device_property_read_bool(dev, "mmc-run-pxp"))
+		mmc->run_pxp_flag = 1;
+	else
+		mmc->run_pxp_flag = 0;
+
+	if (device_property_read_bool(dev, "supports-cqe"))
+		mmc->enable_hwcq = true;
+	else
+		mmc->enable_hwcq = false;
+
+	if (device_property_read_bool(dev, "use-64bit-dma"))
+		mmc->flags |= AML_USE_64BIT_DMA;
+
+	if (device_property_read_bool(dev, "auto-clock-sdio"))
+		mmc->auto_clk = true;
+	else
+		mmc->auto_clk = false;
+
+	return 0;
+}
+
+/*
+ * Checks that a normal transfer didn't have any errors
+ */
+static int mmc_check_result(struct mmc_request *mrq)
+{
+	int ret;
+
+	WARN_ON(!mrq || !mrq->cmd || !mrq->data);
+
+	ret = 0;
+
+	if (!ret && mrq->cmd->error)
+		ret = mrq->cmd->error;
+	if (!ret && mrq->data->error)
+		ret = mrq->data->error;
+	if (!ret && mrq->stop && mrq->stop->error)
+		ret = mrq->stop->error;
+	if (!ret && mrq->data->bytes_xfered !=
+			mrq->data->blocks * mrq->data->blksz)
+		ret = RESULT_FAIL;
+
+	if (ret == -EINVAL)
+		ret = RESULT_UNSUP_HOST;
+
+	return ret;
+}
+
+static void mmc_prepare_mrq(struct mmc_card *card,
+			    struct mmc_request *mrq, struct scatterlist *sg,
+			    unsigned int sg_len, unsigned int dev_addr,
+			    unsigned int blocks,
+			    unsigned int blksz, int write)
+{
+	WARN_ON(!mrq || !mrq->cmd || !mrq->data || !mrq->stop);
+
+	if (blocks > 1) {
+		mrq->cmd->opcode = write ?
+			MMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;
+	} else {
+		mrq->cmd->opcode = write ?
+			MMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;
+	}
+
+	mrq->cmd->arg = dev_addr;
+	if (!mmc_card_is_blockaddr(card))
+		mrq->cmd->arg <<= 9;
+
+	mrq->cmd->flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	if (blocks == 1) {
+		mrq->stop = NULL;
+	} else {
+		mrq->stop->opcode = MMC_STOP_TRANSMISSION;
+		mrq->stop->arg = 0;
+		mrq->stop->flags = MMC_RSP_R1B | MMC_CMD_AC;
+	}
+
+	mrq->data->blksz = blksz;
+	mrq->data->blocks = blocks;
+	mrq->data->flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
+	mrq->data->sg = sg;
+	mrq->data->sg_len = sg_len;
+
+	mmc_set_data_timeout(mrq->data, card);
+}
+
+unsigned int mmc_capacity(struct mmc_card *card)
+{
+	if (!mmc_card_sd(card) && mmc_card_is_blockaddr(card))
+		return card->ext_csd.sectors;
+	else
+		return card->csd.capacity << (card->csd.read_blkbits - 9);
+}
+
+static int mmc_transfer(struct mmc_card *card, unsigned int dev_addr,
+			unsigned int blocks, void *buf, int write)
+{
+	u8 original_part_config;
+	u8 user_part_number = 0;
+	u8 cur_part_number;
+	bool switch_partition = false;
+	unsigned int size;
+	struct scatterlist sg;
+	struct mmc_request mrq = {0};
+	struct mmc_command cmd = {0};
+	struct mmc_command stop = {0};
+	struct mmc_data data = {0};
+	int ret;
+
+	cur_part_number = card->ext_csd.part_config
+		& EXT_CSD_PART_CONFIG_ACC_MASK;
+	if (cur_part_number != user_part_number) {
+		switch_partition = true;
+		original_part_config = card->ext_csd.part_config;
+		cur_part_number = original_part_config
+			& (~EXT_CSD_PART_CONFIG_ACC_MASK);
+		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_PART_CONFIG, cur_part_number,
+				 card->ext_csd.part_time);
+		if (ret)
+			return ret;
+
+		card->ext_csd.part_config = cur_part_number;
+	}
+	if ((dev_addr + blocks) >= mmc_capacity(card)) {
+		pr_info("[%s] %s range exceeds device capacity!\n",
+			__func__, write ? "write" : "read");
+		ret = -1;
+		return ret;
+	}
+
+	size = blocks << card->csd.read_blkbits;
+	sg_init_one(&sg, buf, size);
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	mrq.stop = &stop;
+
+	mmc_prepare_mrq(card, &mrq, &sg, 1, dev_addr,
+			blocks, 1 << card->csd.read_blkbits, write);
+
+	mmc_wait_for_req(card->host, &mrq);
+
+	ret = mmc_check_result(&mrq);
+	if (switch_partition) {
+		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_PART_CONFIG, original_part_config,
+				 card->ext_csd.part_time);
+		if (ret)
+			return ret;
+		card->ext_csd.part_config = original_part_config;
+	}
+
+	return ret;
+}
+
+int aml_disable_mmc_cqe(struct mmc_card *card)
+{
+	int ret = 0;
+
+	if (card->reenable_cmdq && card->ext_csd.cmdq_en) {
+		pr_debug("[%s] [%d]\n", __func__, __LINE__);
+		ret = mmc_cmdq_disable(card);
+		if (ret)
+			pr_err("[%s] disable cqe mode failed\n", __func__);
+	}
+	return ret;
+}
+
+int aml_enable_mmc_cqe(struct mmc_card *card)
+{
+	int ret = 0;
+
+	if (card->reenable_cmdq && !card->ext_csd.cmdq_en) {
+		pr_debug("[%s] [%d]\n", __func__, __LINE__);
+		ret = mmc_cmdq_enable(card);
+		if (ret)
+			pr_err("[%s] reenable cqe mode failed\n", __func__);
+	}
+	return ret;
+}
+
+int mmc_read_internal(struct mmc_card *card, unsigned int dev_addr,
+			unsigned int blocks, void *buf)
+{
+	return mmc_transfer(card, dev_addr, blocks, buf, 0);
+}
+
+int mmc_write_internal(struct mmc_card *card, unsigned int dev_addr,
+			unsigned int blocks, void *buf)
+{
+	return mmc_transfer(card, dev_addr, blocks, buf, 1);
+}
+
+static unsigned int meson_mmc_get_timeout_msecs(struct mmc_data *data)
+{
+	unsigned int timeout = data->timeout_ns / NSEC_PER_MSEC;
+
+	if (!timeout)
+		return SD_EMMC_CMD_TIMEOUT_DATA;
+
+	timeout = roundup_pow_of_two(timeout);
+
+	return min(timeout, 32768U); /* max. 2^15 ms */
+}
+
+static void meson_mmc_get_transfer_mode(struct mmc_host *mmc,
+					struct mmc_request *mrq)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+	struct scatterlist *sg;
+	int i;
+	bool use_desc_chain_mode = true;
+
+	/*
+	 * When Controller DMA cannot directly access DDR memory, disable
+	 * support for Chain Mode to directly use the internal SRAM using
+	 * the bounce buffer mode.
+	 */
+	if (host->dram_access_quirk)
+		return;
+
+	/*
+	 * Broken SDIO with AP6255-based WiFi on Khadas VIM Pro has been
+	 * reported. For some strange reason this occurs in descriptor
+	 * chain mode only. So let's fall back to bounce buffer mode
+	 * for command SD_IO_RW_EXTENDED.
+	 */
+	/*if (mrq->cmd->opcode == SD_IO_RW_EXTENDED)
+	 *	return;
+	 */
+
+	for_each_sg(data->sg, sg, data->sg_len, i)
+		/* check for 8 byte alignment */
+		if (sg->offset & 7) {
+			use_desc_chain_mode = false;
+			break;
+		}
+
+	if (use_desc_chain_mode)
+		data->host_cookie |= SD_EMMC_DESC_CHAIN_MODE;
+}
+
+static inline bool meson_mmc_desc_chain_mode(const struct mmc_data *data)
+{
+	return data->host_cookie & SD_EMMC_DESC_CHAIN_MODE;
+}
+
+static inline bool meson_mmc_bounce_buf_read(const struct mmc_data *data)
+{
+	return data && data->flags & MMC_DATA_READ &&
+	       !meson_mmc_desc_chain_mode(data);
+}
+
+static void meson_mmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	meson_mmc_get_transfer_mode(mmc, mrq);
+	data->host_cookie |= SD_EMMC_PRE_REQ_DONE;
+
+	if (!meson_mmc_desc_chain_mode(data))
+		return;
+
+	data->sg_count = dma_map_sg(mmc_dev(mmc), data->sg, data->sg_len,
+				    mmc_get_dma_dir(data));
+	if (!data->sg_count)
+		dev_err(mmc_dev(mmc), "dma_map_sg failed");
+}
+
+static void meson_mmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
+			       int err)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (data && meson_mmc_desc_chain_mode(data) && data->sg_count)
+		dma_unmap_sg(mmc_dev(mmc), data->sg, data->sg_len,
+			     mmc_get_dma_dir(data));
+}
+
+/*
+ * Gating the clock on this controller is tricky.  It seems the mmc clock
+ * is also used by the controller.  It may crash during some operation if the
+ * clock is stopped.  The safest thing to do, whenever possible, is to keep
+ * clock running at stop it at the pad using the pinmux.
+ */
+static void meson_mmc_clk_gate(struct meson_host *host)
+{
+	u32 cfg;
+
+	if (host->pins_clk_gate) {
+		pinctrl_select_state(host->pinctrl, host->pins_clk_gate);
+	} else {
+		/*
+		 * If the pinmux is not provided - default to the classic and
+		 * unsafe method
+		 */
+		cfg = readl(host->regs + SD_EMMC_CFG);
+		cfg |= CFG_STOP_CLOCK;
+		writel(cfg, host->regs + SD_EMMC_CFG);
+	}
+}
+
+static void meson_mmc_clk_ungate(struct meson_host *host)
+{
+	u32 cfg;
+
+	if (host->pins_clk_gate)
+		pinctrl_select_state(host->pinctrl, host->pins_default);
+
+	/* Make sure the clock is not stopped in the controller */
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	cfg &= ~CFG_STOP_CLOCK;
+	writel(cfg, host->regs + SD_EMMC_CFG);
+}
+
+static void meson_mmc_set_phase_delay(struct meson_host *host, u32 mask,
+				      unsigned int phase)
+{
+	u32 val;
+
+	val = readl(host->regs);
+	val &= ~mask;
+	val |= phase << __ffs(mask);
+	writel(val, host->regs);
+}
+
+static void pxp_clk_set(struct meson_host *host, unsigned long rate)
+{
+	u32 clk_src, val;
+	unsigned long src_rate;
+	u32 clk_div;
+
+	if (rate <= 400000) {
+		src_rate = 24000000;
+		clk_src = 0;
+	} else {
+		src_rate = 1000000000;
+		clk_src = (1 << 6);
+	}
+	dev_err(host->dev, "clock reg:0x%x\n", readl(host->regs + SD_EMMC_CLOCK));
+	clk_div = DIV_ROUND_UP(src_rate, rate);
+	pr_info("clk_div:0x%x\n", clk_div);
+	val = readl(host->regs + SD_EMMC_CLOCK);
+	pr_info("val:0x%x\n", val);
+	val &= ~CLK_DIV_MASK;
+	val |= clk_div;
+	val &= ~CLK_SRC_MASK;
+	val |= clk_src;
+	writel(val, host->regs + SD_EMMC_CLOCK);
+	pr_info("clock reg:0x%x, rate:%lu\n", readl(host->regs + SD_EMMC_CLOCK), rate);
+}
+
+static int no_pxp_clk_set(struct meson_host *host, struct mmc_ios *ios,
+						unsigned long rate)
+{
+	int ret = 0;
+	struct clk *src_clk = NULL;
+	struct mmc_host *mmc = host->mmc;
+	u32 cfg = readl(host->regs + SD_EMMC_CFG);
+
+	dev_dbg(host->dev, "[%s]set rate:%lu\n", __func__, rate);
+	if (host->src_clk)
+		clk_disable_unprepare(host->src_clk);
+
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_HS400:
+		if (host->clk[2])
+			src_clk = host->clk[2];
+		else
+			src_clk = host->clk[1];
+		dev_dbg(host->dev, "HS400 set src rate to:%u\n",
+			host->src_clk_rate);
+		ret = clk_set_rate(src_clk, host->src_clk_rate);
+		if (ret) {
+			dev_err(host->dev, "set src err\n");
+				return ret;
+		}
+		cfg |= CFG_AUTO_CLK;
+		break;
+	case MMC_TIMING_MMC_HS:
+	case MMC_TIMING_SD_HS:
+	case MMC_TIMING_MMC_DDR52:
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR50:
+	case MMC_TIMING_UHS_SDR104:
+		dev_dbg(host->dev, "[%s]Other mode set src rate to:%u\n",
+				__func__, host->src_clk_rate);
+		ret = clk_set_rate(host->clk[1], host->src_clk_rate);
+		if (ret) {
+			dev_err(host->dev, "set src err\n");
+				return ret;
+		}
+		src_clk = host->clk[1];
+		cfg |= CFG_AUTO_CLK;
+	/* sdio set clk always on default */
+		if (aml_card_type_sdio(host) && !host->auto_clk)
+			cfg &= ~CFG_AUTO_CLK;
+		break;
+	case MMC_TIMING_LEGACY:
+		dev_dbg(host->dev, "[%s]Legacy set rate to:%lu\n",
+				__func__, rate);
+		src_clk = host->clk[0];
+	/* enable always on clock for 400KHZ */
+		cfg &= ~CFG_AUTO_CLK;
+
+	/* switch source clock as Total before clk =0, then disable source clk */
+		if (rate == 0) {
+			if (host->mux_div && (!strcmp(__clk_get_name(src_clk), "xtal")))
+				ret = clk_set_parent(host->mux[2], src_clk);
+			else
+				ret = clk_set_parent(host->mux[0], src_clk);
+			host->src_clk = NULL;
+			cfg |= CFG_AUTO_CLK;
+			writel(cfg, host->regs + SD_EMMC_CFG);
+			return ret;
+		}
+		break;
+	default:
+		dev_dbg(host->dev, "Check mmc/sd/sdio timing mode\n");
+		WARN_ON(1);
+		break;
+	}
+
+	clk_prepare_enable(src_clk);
+	writel(cfg, host->regs + SD_EMMC_CFG);
+	host->src_clk = src_clk;
+	if (host->mux_div) { // C1/C2
+		if (!strcmp(__clk_get_name(src_clk), "xtal")) {
+			ret = clk_set_parent(host->mux[2], src_clk);
+		} else {
+			ret = clk_set_parent(host->mux[0], src_clk);
+			if (!ret) {
+				clk_set_rate(host->mux_div, clk_get_rate((src_clk)));
+				ret = clk_set_parent(host->mux[2], host->mux_div);
+			}
+		}
+	} else { // other soc
+		ret = clk_set_parent(host->mux[0], src_clk);
+	}
+
+	if (ret) {
+		dev_err(host->dev, "set parent error\n");
+		return ret;
+	}
+
+	ret = clk_set_rate(host->mmc_clk, rate);
+	if (ret) {
+		dev_err(host->dev, "Unable to set cfg_div_clk to %lu. ret=%d\n",
+			rate, ret);
+		return ret;
+	}
+	host->req_rate = rate;
+	mmc->actual_clock = clk_get_rate(host->mmc_clk);
+
+	dev_dbg(host->dev, "clk rate: %u Hz\n", mmc->actual_clock);
+
+	return ret;
+}
+
+/*
+ * The SD/eMMC IP block has an internal mux and divider used for
+ * generating the MMC clock.  Use the clock framework to create and
+ * manage these clocks.
+ */
+static int meson_mmc_clk_init(struct meson_host *host)
+{
+	struct clk_init_data init;
+	struct clk_divider *div;
+	char clk_name[32], name[16];
+	int i, ret = 0;
+	const char *clk_parent[1];
+	u32 clk_reg;
+
+	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+	clk_reg = CLK_ALWAYS_ON(host);
+	clk_reg |= CLK_DIV_MASK;
+	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);
+	clk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);
+	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
+	writel(clk_reg, host->regs + SD_EMMC_CLOCK);
+
+	for (i = 0; i < 2; i++) {
+		snprintf(name, sizeof(name), "mux%d", i);
+		host->mux[i] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->mux[i])) {
+			if (host->mux[i] != ERR_PTR(-EPROBE_DEFER))
+				dev_err(host->dev, "Missing clock %s\n", name);
+			return PTR_ERR(host->mux[i]);
+		}
+	}
+	host->mux_div = devm_clk_get(host->dev, "mux_div");
+	if (IS_ERR(host->mux_div)) {
+		host->mux_div = NULL;
+		dev_dbg(host->dev,
+			"Missing clock %s(only c1/c2 have mux_div)\n",
+			"mux_div");
+	} else {
+		snprintf(name, sizeof(name), "mux%d", 2);
+		host->mux[2] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->mux[2]))
+			dev_err(host->dev, "Missing clock %s\n", "mux2");
+	}
+
+	for (i = 0; i < 3; i++) {
+		snprintf(name, sizeof(name), "clkin%d", i);
+		host->clk[i] = devm_clk_get(host->dev, name);
+		if (IS_ERR(host->clk[i])) {
+			dev_dbg(host->dev,
+				"Missing clock%s, i = %d\n", name, i);
+			host->clk[i] = NULL;
+		}
+	}
+
+	if (host->mux_div) {
+		ret = clk_set_parent(host->mux[2], host->mux_div);
+		if (ret) {
+			dev_err(host->dev, "Set div parent error\n");
+			return ret;
+		}
+	}
+
+	/* create the divider */
+	div = devm_kzalloc(host->dev, sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return -ENOMEM;
+
+	snprintf(clk_name, sizeof(clk_name), "%s#div", dev_name(host->dev));
+	init.name = clk_name;
+	init.ops = &clk_divider_ops;
+	clk_parent[0] = __clk_get_name(host->mux[1]);
+	init.parent_names = clk_parent;
+	init.num_parents = 1;
+	init.flags = CLK_SET_RATE_PARENT;
+
+	div->reg = host->regs + SD_EMMC_CLOCK;
+	div->shift = __ffs(CLK_DIV_MASK);
+	div->width = __builtin_popcountl(CLK_DIV_MASK);
+	div->hw.init = &init;
+	div->flags = CLK_DIVIDER_ONE_BASED;
+
+	host->mmc_clk = devm_clk_register(host->dev, &div->hw);
+	if (WARN_ON(IS_ERR(host->mmc_clk)))
+		return PTR_ERR(host->mmc_clk);
+	/* create the mmc core clock */
+	if (host->mux_div) {
+		ret = clk_set_parent(host->mux[2], host->clk[0]);
+	} else {
+		ret = clk_set_parent(host->mux[0], host->clk[0]);
+	}
+	if (ret) {
+		dev_err(host->dev, "Set 24m parent error\n");
+		return ret;
+	}
+	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
+	host->mmc->f_min = clk_round_rate(host->mmc_clk, 400000);
+	ret = clk_set_rate(host->mmc_clk, host->mmc->f_min);
+	if (ret)
+		return ret;
+
+	return clk_prepare_enable(host->mmc_clk);
+}
+
+static int meson_mmc_pxp_clk_init(struct meson_host *host)
+{
+	u32 reg_val, val;
+	struct mmc_phase *mmc_phase_init = &host->sd_mmc.init;
+
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+	writel(0, host->regs + SD_EMMC_DELAY1);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	writel(0, host->regs + SD_EMMC_CLOCK);
+
+	reg_val = 0;
+	reg_val |= CLK_ALWAYS_ON(host);
+	reg_val |= CLK_DIV_MASK;
+	writel(reg_val, host->regs + SD_EMMC_CLOCK);
+
+	val = readl(host->clk_tree_base);
+	pr_debug("clk tree base:0x%x\n", val);
+	if (aml_card_type_non_sdio(host))
+		writel(0x800000, host->clk_tree_base);
+
+	else
+		writel(0x80, host->clk_tree_base);
+
+	reg_val = readl(host->regs);
+	reg_val &= ~CLK_DIV_MASK;
+	reg_val |= 60;
+	writel(reg_val, host->regs);
+
+	meson_mmc_set_phase_delay(host, CLK_CORE_PHASE_MASK,
+									mmc_phase_init->core_phase);
+	meson_mmc_set_phase_delay(host, CLK_TX_PHASE_MASK,
+									mmc_phase_init->tx_phase);
+	reg_val = readl(host->regs + SD_EMMC_CFG);
+	reg_val |= CFG_AUTO_CLK;
+	reg_val = readl(host->regs + SD_EMMC_CFG);
+	return 0;
+}
+
+static unsigned int aml_sd_emmc_clktest(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+	u32 clktest = 0, delay_cell = 0, clktest_log = 0, count = 0;
+	u32 vcfg = readl(host->regs + SD_EMMC_CFG);
+	int i = 0;
+	unsigned int cycle = 0;
+
+	writel(0, (host->regs + SD_EMMC_V3_ADJUST));
+	cycle = (1000000000 / mmc->actual_clock) * 1000;
+	vcfg &= ~(1 << 23);
+	writel(vcfg, host->regs + SD_EMMC_CFG);
+	writel(0, host->regs + SD_EMMC_DELAY1);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	intf3 &= ~CLKTEST_EXP_MASK;
+	intf3 |= 8 << __ffs(CLKTEST_EXP_MASK);
+	intf3 |= CLKTEST_ON_M;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	clktest_log = readl(host->regs + SD_EMMC_CLKTEST_LOG);
+	clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+	while (!(clktest_log & 0x80000000)) {
+		mdelay(1);
+		i++;
+		clktest_log = readl(host->regs + SD_EMMC_CLKTEST_LOG);
+		clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+		if (i > 4) {
+			pr_warn("[%s] [%d] emmc clktest error\n",
+				__func__, __LINE__);
+			break;
+		}
+	}
+	if (clktest_log & 0x80000000) {
+		clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+		count = clktest / (1 << 8);
+		if (vcfg & 0x4)
+			delay_cell = ((cycle / 2) / count);
+		else
+			delay_cell = (cycle / count);
+	}
+	pr_info("%s [%d] clktest : %u, delay_cell: %d, count: %u\n",
+		__func__, __LINE__, clktest, delay_cell, count);
+	intf3 = readl(host->regs + SD_EMMC_INTF3);
+	intf3 &= ~CLKTEST_ON_M;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	vcfg = readl(host->regs + SD_EMMC_CFG);
+	vcfg |= (1 << 23);
+	writel(vcfg, host->regs + SD_EMMC_CFG);
+	host->delay_cell = delay_cell;
+	return count;
+}
+
+static int meson_mmc_set_adjust(struct mmc_host *mmc, u32 value)
+{
+	u32 val;
+	struct meson_host *host = mmc_priv(mmc);
+
+	val = readl(host->regs + SD_EMMC_V3_ADJUST);
+	val &= ~CLK_ADJUST_DELAY;
+	val &= ~CFG_ADJUST_ENABLE;
+	val |= CFG_ADJUST_ENABLE;
+	val |= value << __ffs(CLK_ADJUST_DELAY);
+
+	writel(val, host->regs + SD_EMMC_V3_ADJUST);
+	return 0;
+}
+
+int meson_mmc_tuning_transfer(struct mmc_host *mmc, u32 opcode)
+{
+	int tuning_err = 0;
+	int n, nmatch;
+	/* try ntries */
+	for (n = 0, nmatch = 0; n < TUNING_NUM_PER_POINT; n++) {
+		tuning_err = mmc_send_tuning(mmc, opcode, NULL);
+		if (!tuning_err) {
+			nmatch++;
+		} else {
+		/* After the cmd21 command fails,
+		 * it takes a certain time for the emmc status to
+		 * switch from data back to transfer. Currently,
+		 * only this model has this problem.
+		 * by add usleep_range(20, 30);
+		 */
+			usleep_range(20, 30);
+			break;
+		}
+	}
+	return nmatch;
+}
+
+static int find_best_win(struct mmc_host *mmc,
+		char *buf, int num, int *b_s, int *b_sz, bool wrap_f)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	int wrap_win_start = -1, wrap_win_size = 0;
+	int curr_win_start = -1, curr_win_size = 0;
+	int best_win_start = -1, best_win_size = 0;
+	int i = 0, len = 0;
+	u8 *adj_print = NULL;
+
+	len = 0;
+	adj_print = host->adj_win;
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print, "%s: adj_win: < ", mmc_hostname(mmc));
+
+	for (i = 0; i < num; i++) {
+		/*get a ok adjust point!*/
+		if (buf[i]) {
+			if (i == 0)
+				wrap_win_start = i;
+
+			if (wrap_win_start >= 0)
+				wrap_win_size++;
+
+			if (curr_win_start < 0)
+				curr_win_start = i;
+
+			curr_win_size++;
+			len += sprintf(adj_print + len,
+					"%d ", i);
+		} else {
+			if (curr_win_start >= 0) {
+				if (best_win_start < 0) {
+					best_win_start = curr_win_start;
+					best_win_size = curr_win_size;
+				} else {
+					if (best_win_size < curr_win_size) {
+						best_win_start = curr_win_start;
+						best_win_size = curr_win_size;
+					}
+				}
+				wrap_win_start = -1;
+				curr_win_start = -1;
+				curr_win_size = 0;
+			}
+		}
+	}
+
+	sprintf(adj_print + len, ">\n");
+	if (num <= AML_FIXED_ADJ_MAX)
+		pr_info("%s", host->adj_win);
+
+	/* last point is ok! */
+	if (curr_win_start >= 0) {
+		if (best_win_start < 0) {
+			best_win_start = curr_win_start;
+			best_win_size = curr_win_size;
+		} else if ((wrap_win_size > 0) && wrap_f) {
+			/* Wrap around case */
+			if (curr_win_size + wrap_win_size > best_win_size) {
+				best_win_start = curr_win_start;
+				best_win_size = curr_win_size + wrap_win_size;
+			}
+		} else if (best_win_size < curr_win_size) {
+			best_win_start = curr_win_start;
+			best_win_size = curr_win_size;
+		}
+
+		curr_win_start = -1;
+		curr_win_size = 0;
+	}
+	*b_s = best_win_start;
+	*b_sz = best_win_size;
+
+	return 0;
+}
+
+static void pr_adj_info(char *name,
+		unsigned long x, u32 fir_adj, u32 div)
+{
+	int i;
+
+	pr_debug("[%s] fixed_adj_win_map:%lu\n", name, x);
+	for (i = 0; i < div; i++)
+		pr_debug("[%d]=%d\n", (fir_adj + i) % div,
+				((x >> i) & 0x1) ? 1 : 0);
+}
+
+static unsigned long _test_fixed_adj(struct mmc_host *mmc,
+		u32 opcode, u32 adj, u32 div)
+{
+	int i = 0;
+	struct meson_host *host = mmc_priv(mmc);
+	u8 *adj_print = host->adj_win;
+	u32 len = 0;
+	u32 nmatch = 0;
+	unsigned long fixed_adj_map = 0;
+
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print + len, "%s: adj_win: < ", mmc_hostname(mmc));
+	bitmap_zero(&fixed_adj_map, div);
+	for (i = 0; i < div; i++) {
+		meson_mmc_set_adjust(mmc, adj + i);
+		nmatch = meson_mmc_tuning_transfer(mmc, opcode);
+		/*get a ok adjust point!*/
+		if (nmatch == TUNING_NUM_PER_POINT) {
+			set_bit(adj + i, &fixed_adj_map);
+			len += sprintf(adj_print + len,
+				"%d ", adj + i);
+		}
+		pr_debug("%s: rx_tuning_result[%d] = %d\n",
+				mmc_hostname(mmc), adj + i, nmatch);
+	}
+	len += sprintf(adj_print + len, ">\n");
+	pr_debug("%s", host->adj_win);
+
+	return fixed_adj_map;
+}
+
+static u32 _find_fixed_adj_mid(unsigned long map,
+		u32 adj, u32 div, u32 co)
+{
+	u32 left, right, mid, size = 0;
+
+	left = find_last_bit(&map, div);
+	right = find_first_bit(&map, div);
+	/*
+	 * The lib functions don't need to be modified.
+	 */
+	/* coverity[callee_ptr_arith:SUPPRESS] */
+	mid = find_first_zero_bit(&map, div);
+	size = left - right + 1;
+	pr_debug("left:%u, right:%u, mid:%u, size:%u\n",
+			left, right, mid, size);
+	if (size >= 3 && (mid < right || mid > left)) {
+		mid = (adj + (size - 1) / 2 + (size - 1) % 2) % div;
+		if ((mid == (co - 1)) && div == 5)
+			return NO_FIXED_ADJ_MID;
+		pr_info("tuning-c:%u, tuning-s:%u\n",
+			mid, size);
+		return mid;
+	}
+	return NO_FIXED_ADJ_MID;
+}
+
+static unsigned long _swap_fixed_adj_win(unsigned long map,
+		u32 shift, u32 div)
+{
+	unsigned long left, right;
+	/*
+	 * The lib functions don't need to be modified.
+	 */
+	/* coverity[callee_ptr_arith:SUPPRESS] */
+	bitmap_shift_right(&right, &map,
+			shift, div);
+	bitmap_shift_left(&left, &map,
+			div - shift, div);
+	bitmap_or(&map, &right, &left, div);
+	return map;
+}
+
+static void set_fixed_adj_line_delay(u32 step,
+		struct meson_host *host, bool no_cmd)
+{
+	if (aml_card_type_mmc(host)) {
+		writel(aml_mv_dly1(step), host->regs + SD_EMMC_DELAY1);
+		if (no_cmd)
+			writel(aml_mv_dly2_nocmd(step),
+					host->regs + SD_EMMC_DELAY2);
+		else
+			writel(aml_mv_dly2(step),
+					host->regs + SD_EMMC_DELAY2);
+	} else {
+		writel(aml_mv_dly1_nommc(step), host->regs + SD_EMMC_DELAY1);
+		if (!no_cmd)
+			writel(AML_MV_DLY2_NOMMC_CMD(step),
+					host->regs + SD_EMMC_DELAY2);
+	}
+	pr_debug("step:%u, delay1:0x%x, delay2:0x%x\n",
+			step,
+			readl(host->regs + SD_EMMC_DELAY1),
+			readl(host->regs + SD_EMMC_DELAY2));
+}
+
+/*	1. find first removed a fixed_adj_point
+ *	2. re-range fixed adj point
+ *	3. retry
+ */
+static u32 _find_fixed_adj_valid_win(struct mmc_host *mmc,
+		u32 opcode,	unsigned long *fixed_adj_map, u32 div)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 step = 0, ret = NO_FIXED_ADJ_MID, fir_adj = 0xff;
+	unsigned long cur_map[1] = {0};
+	unsigned long prev_map[1] = {0};
+	unsigned long tmp[1] = {0};
+	unsigned long dst[1] = {0};
+//	struct mmc_phase *mmc_phase_init = &host->sd_mmc.init;
+	u32 cop, vclk;
+
+	vclk = readl(host->regs + SD_EMMC_CLOCK);
+	cop = (vclk & CLK_CORE_PHASE_MASK) >> __ffs(CLK_CORE_PHASE_MASK);
+//	cop = para->hs2.core_phase;
+
+	div = (div == AML_FIXED_ADJ_MIN) ?
+			AML_FIXED_ADJ_MIN : AML_FIXED_ADJ_MAX;
+	*prev_map = *fixed_adj_map;
+	pr_adj_info("prev_map", *prev_map, 0, div);
+	for (; step <= 63;) {
+		pr_debug("[%s]retry test fixed adj...\n", __func__);
+		step += AML_FIXADJ_STEP;
+		set_fixed_adj_line_delay(step, host, false);
+		*cur_map = _test_fixed_adj(mmc, opcode, 0, div);
+		/*pr_adj_info("cur_map", *cur_map, 0, div);*/
+		bitmap_and(tmp, prev_map, cur_map, div);
+		bitmap_xor(dst, prev_map, tmp, div);
+		if (*dst != 0) {
+			fir_adj = find_first_bit(dst, div);
+			pr_adj_info(">>>>>>>>bitmap_xor_dst", *dst, 0, div);
+			pr_debug("[%s] fir_adj:%u\n", __func__, fir_adj);
+
+			*prev_map = _swap_fixed_adj_win(*prev_map,
+					fir_adj, div);
+			pr_adj_info(">>>>>>>>prev_map_range",
+					*prev_map, fir_adj, div);
+			ret = _find_fixed_adj_mid(*prev_map, fir_adj, div, cop);
+			if (ret != NO_FIXED_ADJ_MID) {
+				/* pre adj=core phase-1="hole"&&200MHZ,all line delay+step */
+				if (((ret - 1) == (cop - 1)) && div == 5)
+					set_fixed_adj_line_delay(AML_FIXADJ_STEP, host, false);
+				else
+					set_fixed_adj_line_delay(0,	host, false);
+				return ret;
+			}
+
+			fir_adj = (fir_adj + find_next_bit(prev_map,
+				div, 1)) % div;
+		}
+		if (fir_adj == 0xff)
+			continue;
+
+		*prev_map = *cur_map;
+		*cur_map = _swap_fixed_adj_win(*cur_map, fir_adj, div);
+		pr_adj_info(">>>>>>>>cur_map_range", *cur_map, fir_adj, div);
+		ret = _find_fixed_adj_mid(*cur_map, fir_adj, div, cop);
+		if (ret != NO_FIXED_ADJ_MID) {
+			/* pre adj=core phase-1="hole"&&200MHZ,all line delay+step */
+			if (((ret - 1) == (cop - 1)) && div == 5) {
+				step += AML_FIXADJ_STEP;
+				set_fixed_adj_line_delay(step, host, false);
+			}
+			return ret;
+		}
+	}
+
+	pr_debug("[%s][%d] no fixed adj\n", __func__, __LINE__);
+	return ret;
+}
+
+static int meson_mmc_fixadj_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 nmatch = 0;
+	int adj_delay = 0;
+	u8 tuning_num = 0;
+	u32 clk_div, vclk;
+	u32 old_dly, d1_dly, dly;
+	u32 adj_delay_find =  0xff;
+	unsigned long fixed_adj_map[1];
+	bool all_flag = false;
+	int best_s = -1, best_sz = 0;
+	char rx_adj[64] = {0};
+	u8 *adj_print = NULL;
+	u32 len = 0;
+
+	old_dly = readl(host->regs + SD_EMMC_V3_ADJUST);
+	d1_dly = (old_dly >> 0x6) & 0x3F;
+	pr_debug("Data 1 aligned delay is %d\n", d1_dly);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+
+tuning:
+	/* renew */
+	best_s = -1;
+	best_sz = 0;
+	memset(rx_adj, 0, 64);
+
+	len = 0;
+	adj_print = host->adj_win;
+	memset(adj_print, 0, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN);
+	len += sprintf(adj_print + len, "%s: adj_win: < ", mmc_hostname(mmc));
+	vclk = readl(host->regs + SD_EMMC_CLOCK);
+	clk_div = vclk & CLK_DIV_MASK;
+	pr_debug("%s: clk %d div %d tuning start\n",
+			mmc_hostname(mmc), mmc->actual_clock, clk_div);
+
+	if (clk_div <= AML_FIXED_ADJ_MAX)
+		bitmap_zero(fixed_adj_map, clk_div);
+	for (adj_delay = 0; adj_delay < clk_div; adj_delay++) {
+		meson_mmc_set_adjust(mmc, adj_delay);
+		nmatch = meson_mmc_tuning_transfer(host->mmc, opcode);
+		if (nmatch == TUNING_NUM_PER_POINT) {
+			rx_adj[adj_delay]++;
+			if (clk_div <= AML_FIXED_ADJ_MAX)
+				set_bit(adj_delay, fixed_adj_map);
+			len += sprintf(adj_print + len,
+				"%d ", adj_delay);
+		}
+	}
+
+	sprintf(adj_print + len, ">\n");
+	pr_debug("%s", host->adj_win);
+
+	find_best_win(mmc, rx_adj, clk_div, &best_s, &best_sz, true);
+
+	if (best_sz <= 0) {
+		if ((tuning_num++ > MAX_TUNING_RETRY) || clk_div >= 10) {
+			pr_info("%s: final result of tuning failed\n",
+				 mmc_hostname(mmc));
+			return -1;
+		}
+		clk_div++;
+		vclk &= ~CLK_DIV_MASK;
+		vclk |= clk_div & CLK_DIV_MASK;
+		writel(vclk, host->regs + SD_EMMC_CLOCK);
+		pr_info("%s: tuning failed, reduce freq and retuning\n",
+			mmc_hostname(mmc));
+		goto tuning;
+	} else if ((best_sz < clk_div) &&
+			(clk_div <= AML_FIXED_ADJ_MAX) &&
+			(clk_div >= AML_FIXED_ADJ_MIN) &&
+			!all_flag) {
+		adj_delay_find = _find_fixed_adj_valid_win(mmc,
+				opcode, fixed_adj_map, clk_div);
+	} else if (best_sz == clk_div) {
+		all_flag = true;
+		dly = readl(host->regs + SD_EMMC_DELAY1);
+		d1_dly = (dly >> 0x6) & 0x3F;
+		pr_debug("%s() d1_dly %d, window start %d, size %d\n",
+			__func__, d1_dly, best_s, best_sz);
+		if (++d1_dly > 0x3F) {
+			pr_err("%s: tuning failed\n",
+				mmc_hostname(mmc));
+			return -1;
+		}
+		dly &= ~(0x3F << 6);
+		dly |= d1_dly << 6;
+		writel(dly, host->regs + SD_EMMC_DELAY1);
+		goto tuning;
+	} else {
+		pr_debug("%s: best_s = %d, best_sz = %d\n",
+				mmc_hostname(mmc),
+				best_s, best_sz);
+	}
+
+	if (adj_delay_find == 0xff) {
+		adj_delay_find = best_s + (best_sz - 1) / 2
+		+ (best_sz - 1) % 2;
+		writel(old_dly, host->regs + SD_EMMC_DELAY1);
+		pr_info("tuning-c:%u, tuning-s:%u\n",
+			adj_delay_find % clk_div, best_sz);
+	}
+	adj_delay_find = adj_delay_find % clk_div;
+
+	meson_mmc_set_adjust(mmc, adj_delay_find);
+
+	pr_info("%s: clk= 0x%x, adj = 0x%x, dly1 = %x, dly2 = %x\n",
+			mmc_hostname(mmc),
+			readl(host->regs + SD_EMMC_CLOCK),
+			readl(host->regs + SD_EMMC_V3_ADJUST),
+			readl(host->regs + SD_EMMC_DELAY1),
+			readl(host->regs + SD_EMMC_DELAY2));
+
+	return 0;
+}
+
+//void sdio_get_card(struct mmc_host *host, struct mmc_card *card)
+//{
+//	host->card = card;
+//}
+
+int sdio_get_device(void)
+{
+	unsigned int i, device = 0;
+
+	if (sdio_host && sdio_host->card)
+		device = sdio_host->card->cis.device;
+
+	for (i = 0; i < ARRAY_SIZE(wifi_clk); i++) {
+		if (wifi_clk[i].m_device_id == device) {
+			wifi_clk[i].m_use_flag = 1;
+			break;
+		}
+	}
+	pr_debug("sdio device is 0x%x\n", device);
+	return device;
+}
+
+static int meson_mmc_clk_set(struct meson_host *host,
+			struct mmc_ios *ios, bool ddr)
+{
+	struct mmc_host *mmc = host->mmc;
+	int ret = 0;
+	u32 cfg;
+	unsigned long rate = ios->clock;
+
+	/* Same request - bail-out */
+	if (host->ddr == ddr && host->req_rate == rate) {
+		dev_dbg(host->dev, "[%s]bail-out,clk rate: %lu Hz\n",
+				__func__, rate);
+		return 0;
+	}
+
+	/* stop clock */
+	meson_mmc_clk_gate(host);
+	host->req_rate = 0;
+	mmc->actual_clock = 0;
+
+	/* Stop the clock during rate change to avoid glitches */
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	cfg |= CFG_STOP_CLOCK;
+	cfg &= ~CFG_AUTO_CLK;
+	writel(cfg, host->regs + SD_EMMC_CFG);
+
+	if (ddr) {
+		/* DDR modes require higher module clock */
+		rate <<= 1;
+		cfg |= CFG_DDR;
+	} else {
+		cfg &= ~CFG_DDR;
+	}
+	writel(cfg, host->regs + SD_EMMC_CFG);
+	host->ddr = ddr;
+
+	if (host->run_pxp_flag == 0)
+		ret = no_pxp_clk_set(host, ios, rate);
+	else
+		pxp_clk_set(host, rate);
+
+	/* We should report the real output frequency of the controller */
+	if (ddr) {
+		host->req_rate >>= 1;
+		mmc->actual_clock >>= 1;
+	}
+
+	dev_dbg(host->dev, "clk rate: %u Hz\n", mmc->actual_clock);
+	if (rate != mmc->actual_clock)
+		dev_dbg(host->dev, "requested rate was %lu\n", rate);
+
+	/* (re)start clock */
+	meson_mmc_clk_ungate(host);
+
+	return ret;
+}
+
+static int meson_mmc_prepare_ios_clock(struct meson_host *host,
+				       struct mmc_ios *ios)
+{
+	bool ddr = false;
+	int i;
+
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_DDR52:
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_HS400:
+		ddr = true;
+		break;
+	case MMC_TIMING_UHS_SDR104:
+		for (i = 0; i < ARRAY_SIZE(wifi_clk); i++) {
+			if (wifi_clk[i].m_use_flag) {
+				ios->clock = wifi_clk[i].m_uhs_max_dtr;
+				break;
+			}
+		}
+		break;
+	default:
+		ddr = false;
+		break;
+	}
+
+	return meson_mmc_clk_set(host, ios, ddr);
+}
+
+static void meson_mmc_check_resampling(struct meson_host *host,
+				       struct mmc_ios *ios)
+{
+	struct mmc_phase *mmc_phase_set;
+	unsigned int val;
+
+	if (host->timing == ios->timing) {
+		dev_dbg(host->dev, "[%s]bail-out, timing\n",
+				__func__);
+		return;
+	}
+
+	writel(0, host->regs + SD_EMMC_DELAY1);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	writel(0, host->regs + SD_EMMC_INTF3);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+	val = readl(host->regs + SD_EMMC_IRQ_EN);
+	val &= ~CFG_CMD_SETUP;
+	writel(val, host->regs + SD_EMMC_IRQ_EN);
+	switch (ios->timing) {
+	case MMC_TIMING_MMC_HS400:
+		val = readl(host->regs + SD_EMMC_V3_ADJUST);
+		val |= DS_ENABLE;
+		writel(val, host->regs + SD_EMMC_V3_ADJUST);
+		val = readl(host->regs + SD_EMMC_IRQ_EN);
+		val |= CFG_CMD_SETUP;
+		writel(val, host->regs + SD_EMMC_IRQ_EN);
+		val = readl(host->regs + SD_EMMC_INTF3);
+		val |= SD_INTF3;
+		writel(val, host->regs + SD_EMMC_INTF3);
+		mmc_phase_set = &host->sd_mmc.hs4;
+		break;
+	case MMC_TIMING_MMC_HS:
+		val = readl(host->regs + host->data->adjust);
+		val |= CFG_ADJUST_ENABLE;
+		val &= ~CLK_ADJUST_DELAY;
+		val |= CALI_HS_50M_ADJUST << __ffs(CLK_ADJUST_DELAY);
+		writel(val, host->regs + host->data->adjust);
+		mmc_phase_set = &host->sd_mmc.init;
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		mmc_phase_set = &host->sd_mmc.init;
+		break;
+	case MMC_TIMING_SD_HS:
+		val = readl(host->regs + SD_EMMC_V3_ADJUST);
+		val |= CFG_ADJUST_ENABLE;
+		writel(val, host->regs + SD_EMMC_V3_ADJUST);
+		mmc_phase_set = &host->sd_mmc.init;
+		break;
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR50:
+	case MMC_TIMING_UHS_SDR104:
+		if (aml_card_type_sdio(host))
+			sdio_get_device();
+		mmc_phase_set = &host->sd_mmc.sdr;
+		break;
+	default:
+		mmc_phase_set = &host->sd_mmc.init;
+	}
+	meson_mmc_set_phase_delay(host, CLK_CORE_PHASE_MASK,
+				  mmc_phase_set->core_phase);
+	meson_mmc_set_phase_delay(host, CLK_TX_PHASE_MASK,
+				  mmc_phase_set->tx_phase);
+	meson_mmc_set_phase_delay(host, CLK_TX_DELAY_MASK(host),
+				  mmc_phase_set->tx_delay);
+
+	host->timing = ios->timing;
+	dev_dbg(host->dev, "[%s]set mmc timing:%u\n",
+			__func__, ios->timing);
+}
+
+static void meson_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 bus_width, val;
+	int err;
+
+	/*
+	 * GPIO regulator, only controls switching between 1v8 and
+	 * 3v3, doesn't support MMC_POWER_OFF, MMC_POWER_ON.
+	 */
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		if (!IS_ERR(mmc->supply.vmmc))
+			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);
+
+		if (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {
+			regulator_set_voltage_triplet(mmc->supply.vqmmc, 1700000, 1800000, 1950000);
+			regulator_disable(mmc->supply.vqmmc);
+			host->vqmmc_enabled = false;
+		}
+
+		break;
+
+	case MMC_POWER_UP:
+		if (!IS_ERR(mmc->supply.vmmc))
+			mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);
+
+		break;
+
+	case MMC_POWER_ON:
+		if (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {
+			int ret = regulator_enable(mmc->supply.vqmmc);
+
+			if (ret < 0)
+				dev_err(host->dev,
+					"failed to enable vqmmc regulator\n");
+			else
+				host->vqmmc_enabled = true;
+		}
+
+		break;
+	}
+
+	/* Bus width */
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+		bus_width = CFG_BUS_WIDTH_1;
+		break;
+	case MMC_BUS_WIDTH_4:
+		bus_width = CFG_BUS_WIDTH_4;
+		break;
+	case MMC_BUS_WIDTH_8:
+		bus_width = CFG_BUS_WIDTH_8;
+		break;
+	default:
+		dev_err(host->dev, "Invalid ios->bus_width: %u.  Setting to 4.\n",
+			ios->bus_width);
+		bus_width = CFG_BUS_WIDTH_4;
+	}
+
+	val = readl(host->regs + SD_EMMC_CFG);
+	val &= ~CFG_BUS_WIDTH_MASK;
+	val |= FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width);
+	writel(val, host->regs + SD_EMMC_CFG);
+
+	meson_mmc_check_resampling(host, ios);
+	err = meson_mmc_prepare_ios_clock(host, ios);
+	if (err)
+		dev_err(host->dev, "Failed to set clock: %d\n,", err);
+
+	dev_dbg(host->dev, "SD_EMMC_CFG:  0x%08x\n", val);
+}
+
+static void aml_sd_emmc_check_sdio_irq(struct meson_host *host)
+{
+	u32 vstat = readl(host->regs + SD_EMMC_STATUS);
+
+	if (host->sdio_irqen) {
+		if (((vstat & IRQ_SDIO) || (!(vstat & (1 << 17)))) &&
+		    host->mmc->sdio_irq_thread &&
+		    (!atomic_read(&host->mmc->sdio_irq_thread_abort))) {
+			/* pr_info("signalling irq 0x%x\n", vstat); */
+			mmc_signal_sdio_irq(host->mmc);
+		}
+	}
+}
+
+static void meson_mmc_request_done(struct mmc_host *mmc,
+				   struct mmc_request *mrq)
+{
+	struct meson_host *host = mmc_priv(mmc);
+
+	host->cmd = NULL;
+	if (host->needs_pre_post_req)
+		meson_mmc_post_req(mmc, mrq, 0);
+	aml_sd_emmc_check_sdio_irq(host);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void meson_mmc_set_blksz(struct mmc_host *mmc, unsigned int blksz)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 cfg, blksz_old;
+
+	cfg = readl(host->regs + SD_EMMC_CFG);
+	blksz_old = FIELD_GET(CFG_BLK_LEN_MASK, cfg);
+
+	if (!is_power_of_2(blksz))
+		dev_err(host->dev, "blksz %u is not a power of 2\n", blksz);
+
+	blksz = ilog2(blksz);
+
+	/* check if block-size matches, if not update */
+	if (blksz == blksz_old)
+		return;
+
+	dev_dbg(host->dev, "%s: update blk_len %d -> %d\n", __func__,
+		blksz_old, blksz);
+
+	cfg &= ~CFG_BLK_LEN_MASK;
+	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, blksz);
+	writel(cfg, host->regs + SD_EMMC_CFG);
+}
+
+static void meson_mmc_set_response_bits(struct mmc_command *cmd, u32 *cmd_cfg)
+{
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136)
+			*cmd_cfg |= CMD_CFG_RESP_128;
+		*cmd_cfg |= CMD_CFG_RESP_NUM;
+
+		if (!(cmd->flags & MMC_RSP_CRC))
+			*cmd_cfg |= CMD_CFG_RESP_NOCRC;
+
+		if (cmd->flags & MMC_RSP_BUSY)
+			*cmd_cfg |= CMD_CFG_R1B;
+	} else {
+		*cmd_cfg |= CMD_CFG_NO_RESP;
+	}
+}
+
+static void meson_mmc_desc_chain_transfer(struct mmc_host *mmc, u32 cmd_cfg,
+					  struct mmc_command *cmd)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	struct sd_emmc_desc *desc = host->descs;
+	struct mmc_data *data = host->cmd->data;
+	struct scatterlist *sg;
+	u32 start;
+	int i, j = 0;
+
+	if (data->flags & MMC_DATA_WRITE)
+		cmd_cfg |= CMD_CFG_DATA_WR;
+
+	if (data->blocks > 1) {
+		cmd_cfg |= CMD_CFG_BLOCK_MODE;
+		meson_mmc_set_blksz(mmc, data->blksz);
+	}
+
+	if (mmc_op_multi(cmd->opcode) && cmd->mrq->sbc) {
+		desc[j].cmd_cfg = 0;
+		desc[j].cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+					      MMC_SET_BLOCK_COUNT);
+		desc[j].cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc[j].cmd_cfg |= CMD_CFG_OWNER;
+		desc[j].cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc[j].cmd_arg = cmd->mrq->sbc->arg;
+		desc[j].cmd_resp = 0;
+		desc[j].cmd_data = 0;
+		j++;
+	}
+
+	for_each_sg(data->sg, sg, data->sg_count, i) {
+		unsigned int len = sg_dma_len(sg);
+
+		if (data->blocks > 1)
+			len /= data->blksz;
+
+		desc[i + j].cmd_cfg = cmd_cfg;
+		desc[i + j].cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, len);
+		if (i > 0)
+			desc[i + j].cmd_cfg |= CMD_CFG_NO_CMD;
+		desc[i + j].cmd_arg = host->cmd->arg;
+		desc[i + j].cmd_resp = 0;
+		desc[i + j].cmd_data = sg_dma_address(sg);
+	}
+
+	if (mmc_op_multi(cmd->opcode) && !cmd->mrq->sbc) {
+		desc[data->sg_count].cmd_cfg = 0;
+		desc[data->sg_count].cmd_cfg |=
+			FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+				   MMC_STOP_TRANSMISSION);
+		desc[data->sg_count].cmd_cfg |=
+			FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_OWNER;
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc[data->sg_count].cmd_cfg |= CMD_CFG_R1B;
+		desc[data->sg_count].cmd_resp = 0;
+		desc[data->sg_count].cmd_data = 0;
+		j++;
+	}
+
+	desc[data->sg_count + j - 1].cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+	dma_wmb(); /* ensure descriptor is written before kicked */
+	start = host->descs_dma_addr | START_DESC_BUSY;
+	writel(start, host->regs + SD_EMMC_START);
+}
+
+static void meson_mmc_quirk_transfer(struct mmc_host *mmc, u32 cmd_cfg,
+					  struct mmc_command *cmd)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	struct sd_emmc_desc *desc = host->descs;
+	struct mmc_data *data = host->cmd->data;
+	u32 start, data_len;
+
+	if (data->blocks > 1) {
+		cmd_cfg |= CMD_CFG_BLOCK_MODE;
+		meson_mmc_set_blksz(mmc, data->blksz);
+		data_len = data->blocks;
+	} else {
+		data_len = data->blksz;
+	}
+
+	if (mmc_op_multi(cmd->opcode) && cmd->mrq->sbc) {
+		desc->cmd_cfg = 0;
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+					      MMC_SET_BLOCK_COUNT);
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc->cmd_cfg |= CMD_CFG_OWNER;
+		desc->cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc->cmd_arg = cmd->mrq->sbc->arg;
+		desc->cmd_resp = 0;
+		desc->cmd_data = 0;
+		desc++;
+	}
+
+	desc->cmd_cfg = cmd_cfg;
+	desc->cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, data_len);
+	desc->cmd_arg = host->cmd->arg;
+	desc->cmd_resp = 0;
+	desc->cmd_data = host->bounce_dma_addr;
+
+	if (mmc_op_multi(cmd->opcode) && !cmd->mrq->sbc) {
+		desc++;
+		desc->cmd_cfg = 0;
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK,
+				   MMC_STOP_TRANSMISSION);
+		desc->cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK, 0xc);
+		desc->cmd_cfg |= CMD_CFG_OWNER;
+		desc->cmd_cfg |= CMD_CFG_RESP_NUM;
+		desc->cmd_cfg |= CMD_CFG_R1B;
+		desc->cmd_resp = 0;
+		desc->cmd_data = 0;
+	}
+
+	desc->cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+
+	dma_wmb(); /* ensure descriptor is written before kicked */
+	start = host->descs_dma_addr | START_DESC_BUSY | CMD_DATA_SRAM;
+	writel(start, host->regs + SD_EMMC_START);
+}
+
+static void meson_mmc_start_cmd(struct mmc_host *mmc, struct mmc_command *cmd)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	struct mmc_data *data = cmd->data;
+	u32 val, cmd_cfg = 0, cmd_data = 0;
+	unsigned int xfer_bytes = 0;
+
+	/* Setup descriptors */
+	dma_rmb();
+
+	host->cmd = cmd;
+
+	cmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK, cmd->opcode);
+	cmd_cfg |= CMD_CFG_OWNER;  /* owned by CPU */
+
+	meson_mmc_set_response_bits(cmd, &cmd_cfg);
+
+	if (cmd->opcode == SD_SWITCH_VOLTAGE) {
+		val = readl(host->regs + SD_EMMC_CFG);
+		val &= ~CFG_AUTO_CLK;
+		writel(val, host->regs + SD_EMMC_CFG);
+	}
+
+	/* data? */
+	if (data) {
+		data->bytes_xfered = 0;
+		cmd_cfg |= CMD_CFG_DATA_IO;
+		cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,
+				      ilog2(meson_mmc_get_timeout_msecs(data)));
+
+		if (meson_mmc_desc_chain_mode(data)) {
+			meson_mmc_desc_chain_transfer(mmc, cmd_cfg, cmd);
+			return;
+		}
+
+		if (data->blocks > 1) {
+			cmd_cfg |= CMD_CFG_BLOCK_MODE;
+			cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK,
+					      data->blocks);
+			meson_mmc_set_blksz(mmc, data->blksz);
+		} else {
+			cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, data->blksz);
+		}
+
+		xfer_bytes = data->blksz * data->blocks;
+		if (data->flags & MMC_DATA_WRITE) {
+			cmd_cfg |= CMD_CFG_DATA_WR;
+			WARN_ON(xfer_bytes > host->bounce_buf_size);
+			sg_copy_to_buffer(data->sg, data->sg_len,
+					  host->bounce_buf, xfer_bytes);
+			dma_wmb();
+		}
+
+		cmd_data = host->bounce_dma_addr & CMD_DATA_MASK;
+
+		if (host->dram_access_quirk) {
+			meson_mmc_quirk_transfer(mmc, cmd_cfg, cmd);
+			return;
+		}
+	} else {
+		cmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,
+				      ilog2(SD_EMMC_CMD_TIMEOUT));
+	}
+
+	/* Last descriptor */
+	cmd_cfg |= CMD_CFG_END_OF_CHAIN;
+	writel(cmd_cfg, host->regs + SD_EMMC_CMD_CFG);
+	writel(cmd_data, host->regs + SD_EMMC_CMD_DAT);
+	writel(0, host->regs + SD_EMMC_CMD_RSP);
+	wmb(); /* ensure descriptor is written before kicked */
+	writel(cmd->arg, host->regs + SD_EMMC_CMD_ARG);
+}
+
+static void meson_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct meson_host *host = mmc_priv(mmc);
+
+	host->needs_pre_post_req = mrq->data &&
+			!(mrq->data->host_cookie & SD_EMMC_PRE_REQ_DONE);
+
+	if (host->needs_pre_post_req) {
+		meson_mmc_get_transfer_mode(mmc, mrq);
+		if (!meson_mmc_desc_chain_mode(mrq->data))
+			host->needs_pre_post_req = false;
+	}
+
+	if (host->needs_pre_post_req)
+		meson_mmc_pre_req(mmc, mrq);
+
+	/* Stop execution */
+	writel(0, host->regs + SD_EMMC_START);
+
+	meson_mmc_start_cmd(mmc, mrq->cmd);
+}
+
+static int aml_sd_emmc_cali_v3(struct mmc_host *mmc,
+			       u8 opcode, u8 *blk_test, u32 blksz,
+			       u32 blocks, u8 *pattern)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_command stop = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+
+	cmd.opcode = opcode;
+	if (!strcmp(pattern, MMC_PATTERN_NAME))
+		cmd.arg = MMC_PATTERN_OFFSET;
+	else if (!strcmp(pattern, MMC_MAGIC_NAME))
+		cmd.arg = MMC_MAGIC_OFFSET;
+	else if (!strcmp(pattern, MMC_RANDOM_NAME))
+		cmd.arg = MMC_RANDOM_OFFSET;
+	else if (!strcmp(pattern, MMC_DTB_NAME))
+		cmd.arg = MMC_DTB_OFFSET;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+	stop.opcode = MMC_STOP_TRANSMISSION;
+	stop.arg = 0;
+	stop.flags = MMC_RSP_R1B | MMC_CMD_AC;
+	data.blksz = blksz;
+	data.blocks = blocks;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+	data.timeout_ns = 2048000000;
+	memset(blk_test, 0, blksz * data.blocks);
+	sg_init_one(&sg, blk_test, blksz * data.blocks);
+	mrq.cmd = &cmd;
+	mrq.stop = &stop;
+	mrq.data = &data;
+	mmc_wait_for_req(mmc, &mrq);
+	return data.error | cmd.error;
+}
+
+static int emmc_send_cmd(struct mmc_host *mmc, u32 opcode,
+			 u32 arg, unsigned int flags)
+{
+	struct mmc_command cmd = {0};
+	u32 err = 0;
+
+	cmd.opcode = opcode;
+	cmd.arg = arg;
+	cmd.flags = flags;
+	err = mmc_wait_for_cmd(mmc, &cmd, 0);
+	if (err) {
+		pr_debug("[%s][%d] cmd:0x%x send error\n",
+			 __func__, __LINE__, cmd.opcode);
+		return err;
+	}
+	return err;
+}
+
+static int aml_sd_emmc_cmd_v3(struct mmc_host *mmc)
+{
+	int i;
+
+	emmc_send_cmd(mmc, MMC_SEND_STATUS,
+		      1 << 16, MMC_RSP_R1 | MMC_CMD_AC);
+	emmc_send_cmd(mmc, MMC_SELECT_CARD,
+		      0, MMC_RSP_NONE | MMC_CMD_AC);
+	for (i = 0; i < 2; i++)
+		emmc_send_cmd(mmc, MMC_SEND_CID,
+			      1 << 16, MMC_RSP_R2 | MMC_CMD_BCR);
+	emmc_send_cmd(mmc, MMC_SELECT_CARD,
+		      1 << 16, MMC_RSP_R1 | MMC_CMD_AC);
+	return 0;
+}
+
+static int emmc_eyetest_log(struct mmc_host *mmc, u32 line_x)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 adjust = readl(host->regs + SD_EMMC_V3_ADJUST);
+	u32 eyetest_log = 0;
+	u32 eyetest_out0 = 0, eyetest_out1 = 0;
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+	int retry = 3;
+	u64 tmp = 0;
+	u32 blksz = 512;
+
+	pr_debug("delay1: 0x%x , delay2: 0x%x, line_x: %d\n",
+		 readl(host->regs + SD_EMMC_DELAY1),
+		 readl(host->regs + SD_EMMC_DELAY2), line_x);
+	adjust |= CALI_ENABLE;
+	adjust &= ~CALI_SEL_MASK;
+	adjust |= line_x << __ffs(CALI_SEL_MASK);
+	writel(adjust, host->regs + SD_EMMC_V3_ADJUST);
+	if (line_x < 9) {
+		intf3 &= ~EYETEST_EXP_MASK;
+		intf3 |= 7 << __ffs(EYETEST_EXP_MASK);
+	} else {
+		intf3 &= ~EYETEST_EXP_MASK;
+		intf3 |= 3 << __ffs(EYETEST_EXP_MASK);
+	}
+RETRY:
+	intf3 |= EYETEST_ON;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	udelay(5);
+	if (line_x < 9)
+		aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+				    host->blk_test, blksz,
+				    40, MMC_PATTERN_NAME);
+	else
+		aml_sd_emmc_cmd_v3(mmc);
+	udelay(1);
+	eyetest_log = readl(host->regs + SD_EMMC_EYETEST_LOG);
+	if (!(eyetest_log & EYETEST_DONE)) {
+		pr_debug("testing eyetest times:0x%x,out:0x%x,0x%x,line:%d\n",
+			 readl(host->regs + SD_EMMC_EYETEST_LOG),
+			 eyetest_out0, eyetest_out1, line_x);
+		intf3 &= ~EYETEST_ON;
+		writel(intf3, host->regs + SD_EMMC_INTF3);
+		retry--;
+		if (retry == 0) {
+			pr_debug("[%s][%d] retry eyetest failed-line:%d\n",
+				 __func__, __LINE__, line_x);
+			return 1;
+		}
+		goto RETRY;
+	}
+	eyetest_out0 = readl(host->regs + SD_EMMC_EYETEST_OUT0);
+	eyetest_out1 = readl(host->regs + SD_EMMC_EYETEST_OUT1);
+	intf3 &= ~EYETEST_ON;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+	host->align[line_x] = ((tmp | eyetest_out1) << 32) | eyetest_out0;
+	pr_debug("d1:0x%x,d2:0x%x,u64eyet:0x%016llx,l_x:%d\n",
+		 readl(host->regs + SD_EMMC_DELAY1),
+		 readl(host->regs + SD_EMMC_DELAY2),
+		 host->align[line_x], line_x);
+	return 0;
+}
+
+static int single_read_scan(struct mmc_host *mmc, u8 opcode,
+			    u8 *blk_test, u32 blksz,
+			    u32 blocks, u32 offset)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+
+	cmd.opcode = opcode;
+	cmd.arg = offset;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+	data.blksz = blksz;
+	data.blocks = blocks;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+	data.timeout_ns = 2048000000;
+	memset(blk_test, 0, blksz * data.blocks);
+	sg_init_one(&sg, blk_test, blksz * data.blocks);
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	mmc_wait_for_req(mmc, &mrq);
+	return data.error | cmd.error;
+}
+
+static void emmc_show_cmd_window(char *str, int repeat_times)
+{
+	int pre_status = 0;
+	int status = 0;
+	int single = 0;
+	int start = 0;
+	int i;
+
+	pr_info(">>>>>>>>>>>>>>scan command window>>>>>>>>>>>>>>>\n");
+	for (i = 0; i < 64; i++) {
+		if (str[i] == repeat_times)
+			status = 1;
+		else
+			status = -1;
+		if (i != 0 && pre_status != status) {
+			if (pre_status == 1 && single == 1)
+				pr_info(">>cmd delay [ %d ] is ok\n",
+					i - 1);
+			else if (pre_status == 1 && single != 1)
+				pr_info(">>cmd delay [ %d -- %d ] is ok\n",
+					start, i - 1);
+			else if (pre_status != 1 &&	 single == 1)
+				pr_info(">>cmd delay [ %d ] is nok\n",
+					i - 1);
+			else if (pre_status != 1 && single != 1)
+				pr_info(">>cmd delay [ %d -- %d ] is nok\n",
+					start, i - 1);
+			start = i;
+			single = 1;
+		} else {
+			single++;
+		}
+		if (i == 63) {
+			if (status == 1 && pre_status == 1)
+				pr_info(">>cmd delay [ %d -- %d ] is ok\n",
+					start, i);
+			else if (status != 1 && pre_status == -1)
+				pr_info(">>cmd delay [ %d -- %d ] is nok\n",
+					start, i);
+			else if (status == 1 && pre_status != 1)
+				pr_info(">>cmd delay [ %d ] is ok\n", i);
+			else if (status != 1 && pre_status == 1)
+				pr_info(">>cmd delay [ %d ] is nok\n", i);
+		}
+		pre_status = status;
+	}
+	pr_info("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");
+}
+
+static u32 emmc_search_cmd_delay(char *str, int repeat_times, u32 *p_size)
+{
+	int best_start = -1, best_size = -1;
+	int cur_start = -1, cur_size = 0;
+	u32 cmd_delay;
+	int i;
+
+	for (i = 0; i < 64; i++) {
+		if (str[i] == repeat_times) {
+			cur_size += 1;
+			if (cur_start == -1)
+				cur_start = i;
+		} else {
+			cur_size = 0;
+			cur_start = -1;
+		}
+		if (cur_size > best_size) {
+			best_size = cur_size;
+			best_start = cur_start;
+		}
+	}
+	cmd_delay =	 (best_start + best_size / 2) << 24;
+	if (p_size)
+		*p_size = best_size;
+	pr_info("cmd-best-c:%d, cmd-best-size:%d\n",
+		(cmd_delay >> 24), best_size);
+	return cmd_delay;
+}
+
+static u32 scan_emmc_cmd_win(struct mmc_host *mmc,
+		int send_status, u32 *pcmd_size)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay2 = readl(host->regs + SD_EMMC_DELAY2);
+	u32 cmd_delay = 0;
+	u32 delay2_bak = delay2;
+	u32 i, j, err;
+	int repeat_times = 100;
+	char str[64] = {0};
+	long long before_time;
+	long long after_time;
+	u32 capacity = 2 * SZ_1M;
+	u32 offset;
+
+	delay2 &= ~(0xff << 24);
+	host->cmd_retune = 0;
+	host->is_tuning = 1;
+	before_time = sched_clock();
+	for (i = 0; i < 64; i++) {
+		writel(delay2, host->regs + SD_EMMC_DELAY2);
+		offset = (u32)(get_random_long() % capacity);
+		for (j = 0; j < repeat_times; j++) {
+			if (send_status) {
+				err = emmc_send_cmd(mmc, MMC_SEND_STATUS,
+						    1 << 16,
+						    MMC_RSP_R1 | MMC_CMD_AC);
+			} else {
+				err = single_read_scan(mmc,
+						       MMC_READ_SINGLE_BLOCK,
+						       host->blk_test, 512, 1,
+						       offset);
+				emmc_send_cmd(mmc, MMC_STOP_TRANSMISSION,
+						    0,
+						    MMC_RSP_R1 | MMC_CMD_AC);
+				emmc_send_cmd(mmc, MMC_SEND_STATUS,
+						    1 << 16,
+						    MMC_RSP_R1 | MMC_CMD_AC);
+			}
+			if (!err)
+				str[i]++;
+			else
+				break;
+		}
+		pr_debug("delay2: 0x%x, send cmd %d times success %d times, is ok\n",
+				 delay2, repeat_times, str[i]);
+		delay2 += (1 << 24);
+	}
+	after_time = sched_clock();
+	host->is_tuning = 0;
+	host->cmd_retune = 1;
+	pr_debug("scan time distance: %llu ns\n", after_time - before_time);
+	writel(delay2_bak, host->regs + SD_EMMC_DELAY2);
+	cmd_delay = emmc_search_cmd_delay(str, repeat_times, pcmd_size);
+	if (!send_status)
+		emmc_show_cmd_window(str, repeat_times);
+	return cmd_delay;
+}
+
+ssize_t emmc_scan_cmd_win(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct meson_host *host = dev_get_drvdata(dev);
+	struct mmc_host *mmc = host->mmc;
+
+	mmc_claim_host(mmc);
+	scan_emmc_cmd_win(mmc, 1, NULL);
+	mmc_release_host(mmc);
+	return sprintf(buf, "%s\n", "Emmc scan command window.\n");
+}
+
+static void update_all_line_eyetest(struct mmc_host *mmc)
+{
+	int line_x;
+
+	for (line_x = 0; line_x < 10; line_x++) {
+		if (line_x == 8 && !(mmc->caps2 & MMC_CAP2_HS400_1_8V))
+			continue;
+		emmc_eyetest_log(mmc, line_x);
+	}
+}
+
+int emmc_clktest(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+	u32 clktest = 0, delay_cell = 0, clktest_log = 0, count = 0;
+	u32 vcfg = readl(host->regs + SD_EMMC_CFG);
+	int i = 0;
+	unsigned int cycle = 0;
+
+	writel(0, (host->regs + SD_EMMC_V3_ADJUST));
+	cycle = (1000000000 / mmc->actual_clock) * 1000;
+	vcfg &= ~(1 << 23);
+	writel(vcfg, host->regs + SD_EMMC_CFG);
+	intf3 &= ~CLKTEST_EXP_MASK;
+	intf3 |= 8 << __ffs(CLKTEST_EXP_MASK);
+	intf3 |= CLKTEST_ON_M;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	clktest_log = readl(host->regs + SD_EMMC_CLKTEST_LOG);
+	clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+	while (!(clktest_log & 0x80000000)) {
+		udelay(1);
+		i++;
+		clktest_log = readl(host->regs + SD_EMMC_CLKTEST_LOG);
+		clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+		if (i > 4000) {
+			pr_warn("[%s] [%d] emmc clktest error\n",
+				__func__, __LINE__);
+			break;
+		}
+	}
+	if (clktest_log & 0x80000000) {
+		clktest = readl(host->regs + SD_EMMC_CLKTEST_OUT);
+		count = clktest / (1 << 8);
+		if (vcfg & 0x4)
+			delay_cell = ((cycle / 2) / count);
+		else
+			delay_cell = (cycle / count);
+	}
+	pr_info("%s [%d] clktest : %u, delay_cell: %d, count: %u\n",
+		__func__, __LINE__, clktest, delay_cell, count);
+	intf3 = readl(host->regs + SD_EMMC_INTF3);
+	intf3 &= ~CLKTEST_ON_M;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	vcfg = readl(host->regs + SD_EMMC_CFG);
+	vcfg |= (1 << 23);
+	writel(vcfg, host->regs + SD_EMMC_CFG);
+	return count;
+}
+
+static unsigned int tl1_emmc_line_timing(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay1 = 0, delay2 = 0, count = 12;
+
+	delay1 = (count << 0) | (count << 6) | (count << 12) |
+		(count << 18) | (count << 24);
+	delay2 = (count << 0) | (count << 6) | (count << 12) |
+		(host->cmd_c << 24);
+	writel(delay1, host->regs + SD_EMMC_DELAY1);
+	writel(delay2, host->regs + SD_EMMC_DELAY2);
+	pr_debug("[%s], delay1: 0x%x, delay2: 0x%x\n",
+		__func__, readl(host->regs + SD_EMMC_DELAY1),
+		readl(host->regs + SD_EMMC_DELAY2));
+	return 0;
+}
+
+static int single_read_cmd_for_scan(struct mmc_host *mmc,
+		 u8 opcode, u8 *blk_test, u32 blksz, u32 blocks, u32 offset)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+
+	cmd.opcode = opcode;
+	cmd.arg = offset;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = blksz;
+	data.blocks = blocks;
+	data.flags = MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	memset(blk_test, 0, blksz * data.blocks);
+	sg_init_one(&sg, blk_test, blksz * data.blocks);
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	mmc_wait_for_req(mmc, &mrq);
+	return data.error | cmd.error;
+}
+
+static int emmc_test_bus(struct mmc_host *mmc)
+{
+	int err = 0;
+	u32 blksz = 512;
+	struct meson_host *host = mmc_priv(mmc);
+
+	err = aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+				  host->blk_test, blksz, 40, MMC_PATTERN_NAME);
+	if (err)
+		return err;
+	err = aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+				  host->blk_test, blksz, 80, MMC_RANDOM_NAME);
+	if (err)
+		return err;
+	err = aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+				  host->blk_test, blksz, 40, MMC_MAGIC_NAME);
+	if (err)
+		return err;
+	return err;
+}
+
+static int emmc_ds_manual_sht(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 val, intf3 = readl(host->regs + SD_EMMC_INTF3);
+	int i, err = 0;
+	int match[64], size = 0;
+	int best_start = -1, best_size = -1;
+	int cur_start = -1, cur_size = 0;
+
+	memset(match, -1, sizeof(match));
+	host->cmd_retune = 1;
+	for (i = 0; i < 64; i++) {
+		host->is_tuning = 1;
+		err = emmc_test_bus(mmc);
+		host->is_tuning = 0;
+		pr_debug("intf3: 0x%x, err[%d]: %d\n",
+			 readl(host->regs + SD_EMMC_INTF3), i, err);
+		if (!err) {
+			match[i] = 0;
+			++size;
+		} else {
+			match[i] = -1;
+			if (size > DELAY_CELL_COUNTS)
+				break;
+		}
+		val = intf3 & DS_SHT_M_MASK;
+		val += 1 << __ffs(DS_SHT_M_MASK);
+		intf3 &= ~DS_SHT_M_MASK;
+		intf3 |= val;
+		writel(intf3, host->regs + SD_EMMC_INTF3);
+	}
+	for (i = 0; i < 64; i++) {
+		if (match[i] == 0) {
+			if (cur_start < 0)
+				cur_start = i;
+			cur_size++;
+		} else {
+			if (cur_start >= 0) {
+				if (best_start < 0) {
+					best_start = cur_start;
+					best_size = cur_size;
+				} else {
+					if (best_size < cur_size) {
+						best_start = cur_start;
+						best_size = cur_size;
+					}
+				}
+				cur_start = -1;
+				cur_size = 0;
+			}
+		}
+	}
+	if (cur_start >= 0) {
+		if (best_start < 0) {
+			best_start = cur_start;
+			best_size = cur_size;
+		} else if (best_size < cur_size) {
+			best_start = cur_start;
+			best_size = cur_size;
+		}
+		cur_start = -1;
+		cur_size = -1;
+	}
+	intf3 &= ~DS_SHT_M_MASK;
+	intf3 &= ~DS_SHT_EXP_MASK;
+	intf3 |= (best_start + best_size / 2) << __ffs(DS_SHT_M_MASK);
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	pr_info("ds_sht:%lu, window:%d, intf3:0x%x, clock:0x%x, adjust:0x%x",
+		(intf3 & DS_SHT_M_MASK) >> __ffs(DS_SHT_M_MASK), best_size,
+		readl(host->regs + SD_EMMC_INTF3),
+		readl(host->regs + SD_EMMC_CLOCK),
+		readl(host->regs + SD_EMMC_V3_ADJUST));
+	return 0;
+}
+
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+static int emmc_data_alignment(struct mmc_host *mmc, int best_size)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay1 = readl(host->regs + SD_EMMC_DELAY1);
+	u32 delay2 = readl(host->regs + SD_EMMC_DELAY2);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+	u32 delay1_bak = delay1;
+	u32 delay2_bak = delay2;
+	u32 intf3_bak = intf3;
+	int line_x, i, err = 0, win_new, blksz = 512;
+	u32 d[8];
+
+	host->is_tuning = 1;
+	intf3 &= ~DS_SHT_M_MASK;
+	intf3 |= (host->win_start + 4) << __ffs(DS_SHT_M_MASK);
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	for (line_x = 0; line_x < 8; line_x++) {
+		for (i = 0; i < 20; i++) {
+			if (line_x < 5) {
+				delay1 += (1 << 6 * line_x);
+				writel(delay1, host->regs + SD_EMMC_DELAY1);
+			} else {
+				delay2 += (1 << 6 * (line_x - 5));
+				writel(delay2, host->regs + SD_EMMC_DELAY2);
+			}
+			err = aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+						  host->blk_test, blksz, 40,
+						  MMC_PATTERN_NAME);
+			if (err) {
+				pr_info("[%s]adjust line_x[%d]:%d\n",
+					__func__, line_x, i);
+				d[line_x] = i;
+				delay1 = delay1_bak;
+				delay2 = delay2_bak;
+				writel(delay1_bak, host->regs + SD_EMMC_DELAY1);
+				writel(delay2_bak, host->regs + SD_EMMC_DELAY2);
+				break;
+			}
+		}
+		if (i == 20) {
+			pr_info("[%s][%d] return set default value",
+				__func__, __LINE__);
+			writel(delay1_bak, host->regs + SD_EMMC_DELAY1);
+			writel(delay2_bak, host->regs + SD_EMMC_DELAY2);
+			writel(intf3_bak, host->regs + SD_EMMC_INTF3);
+			host->is_tuning = 0;
+			return -1;
+		}
+	}
+	delay1 += (d[0] << 0) | (d[1] << 6) | (d[2] << 12) |
+		(d[3] << 18) | (d[4] << 24);
+	delay2 += (d[5] << 0) | (d[6] << 6) | (d[7] << 12);
+	writel(delay1, host->regs + SD_EMMC_DELAY1);
+	writel(delay2, host->regs + SD_EMMC_DELAY2);
+	pr_info("delay1:0x%x, delay2:0x%x\n",
+		readl(host->regs + SD_EMMC_DELAY1),
+		readl(host->regs + SD_EMMC_DELAY2));
+	intf3 &= ~DS_SHT_M_MASK;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+	win_new = emmc_ds_manual_sht(mmc);
+	if (win_new < best_size) {
+		pr_info("[%s][%d] win_new:%d < win_old:%d,set default!",
+			__func__, __LINE__, win_new, best_size);
+		writel(delay1_bak, host->regs + SD_EMMC_DELAY1);
+		writel(delay2_bak, host->regs + SD_EMMC_DELAY2);
+		writel(intf3_bak, host->regs + SD_EMMC_INTF3);
+		pr_info("intf3:0x%x, delay1:0x%x, delay2:0x%x\n",
+			readl(host->regs + SD_EMMC_INTF3),
+			readl(host->regs + SD_EMMC_DELAY1),
+			readl(host->regs + SD_EMMC_DELAY2));
+	}
+	host->is_tuning = 0;
+	return 0;
+}
+#endif
+
+static u32 set_emmc_cmd_delay(struct mmc_host *mmc, int send_status)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay2 = readl(host->regs + SD_EMMC_DELAY2);
+	u32 cmd_delay = 0, cmd_size = 0;
+
+	delay2 &= ~(0xff << 24);
+	cmd_delay = scan_emmc_cmd_win(mmc, send_status, &cmd_size);
+	delay2 |= cmd_delay;
+	writel(delay2, host->regs + SD_EMMC_DELAY2);
+	return cmd_size;
+}
+
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+static void __maybe_unused aml_emmc_hs400_revb(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay2 = 0;
+	int win_size = 0;
+
+	delay2 = readl(host->regs + SD_EMMC_DELAY2);
+	delay2 += (host->cmd_c << 24);
+	writel(delay2, host->regs + SD_EMMC_DELAY2);
+	pr_info("[%s], delay1: 0x%x, delay2: 0x%x\n",
+		__func__, readl(host->regs + SD_EMMC_DELAY1),
+		readl(host->regs + SD_EMMC_DELAY2));
+	win_size = emmc_ds_manual_sht(mmc);
+	emmc_data_alignment(mmc, win_size);
+	set_emmc_cmd_delay(mmc, 0);
+}
+#endif
+
+static void aml_emmc_hs400_tl1(struct mmc_host *mmc)
+{
+	u32 cmd_size = 0;
+
+	mmc->retune_crc_disable = true;
+	tl1_emmc_line_timing(mmc);
+	cmd_size = set_emmc_cmd_delay(mmc, 1);
+	emmc_ds_manual_sht(mmc);
+	if (cmd_size >= EMMC_CMD_WIN_MAX_SIZE)
+		set_emmc_cmd_delay(mmc, 0);
+}
+
+static long long _para_checksum_calc(struct aml_tuning_para *para)
+{
+	int i = 0;
+	int size = sizeof(struct aml_tuning_para) - 6 * sizeof(unsigned int);
+	unsigned int *buffer;
+	long long checksum = 0;
+
+	if (!para)
+		return 1;
+
+	size = size >> 2;
+	buffer = (unsigned int *)para;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+/*
+ * read tuning para from reserved partition
+ * and copy it to pdata->para
+ */
+int aml_read_tuning_para(struct mmc_host *mmc)
+{
+	int off, blk;
+	int ret;
+	int para_size;
+	struct meson_host *host = mmc_priv(mmc);
+
+	if (host->save_para == 0)
+		return 0;
+
+	para_size = sizeof(struct aml_tuning_para);
+	blk = (para_size - 1) / 512 + 1;
+	off = MMC_TUNING_OFFSET;
+
+	ret = single_read_cmd_for_scan(mmc,
+				       MMC_READ_SINGLE_BLOCK,
+				       host->blk_test, 512,
+				       blk, off);
+	if (ret) {
+		pr_info("read tuning parameter failed\n");
+		return ret;
+	}
+
+	memcpy(&host->para, host->blk_test, para_size);
+	return ret;
+}
+
+/*set para on controller register*/
+static void aml_set_tuning_para(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	struct aml_tuning_para *para = &host->para;
+	int temp_index;
+	u32 delay1, delay2, intf3;
+	int cmd_delay;
+
+	if (host->compute_cmd_delay == 1) {
+		temp_index = host->first_temp_index;
+		delay1 = host->para.hs4[temp_index].delay1;
+		delay2 = host->para.hs4[temp_index].delay2;
+		intf3 = host->para.hs4[temp_index].intf3;
+
+		cmd_delay = ((10 + host->compute_coef) * (host->cur_temp_index
+				- host->first_temp_index)) / 10;
+
+		delay2 -= cmd_delay << 24;
+		pr_info("bef %d, cur %d, delay switch from 0x%x to 0x%x\n",
+				host->first_temp_index,
+				host->cur_temp_index,
+				host->para.hs4[temp_index].delay2,
+				delay2);
+
+		writel(delay1, host->regs + SD_EMMC_DELAY1);
+		writel(delay2, host->regs + SD_EMMC_DELAY2);
+		writel(intf3, host->regs + SD_EMMC_INTF3);
+	} else {
+		temp_index = para->temperature / 10000;
+		delay1 = host->para.hs4[temp_index].delay1;
+		delay2 = host->para.hs4[temp_index].delay2;
+		intf3 = host->para.hs4[temp_index].intf3;
+
+		writel(delay1, host->regs + SD_EMMC_DELAY1);
+		writel(delay2, host->regs + SD_EMMC_DELAY2);
+		writel(intf3, host->regs + SD_EMMC_INTF3);
+	}
+}
+
+/*save parameter on mmc_host pdata*/
+static void aml_save_tuning_para(struct mmc_host *mmc)
+{
+	long long checksum;
+	int temp_index;
+	struct meson_host *host = mmc_priv(mmc);
+	struct aml_tuning_para *para = &host->para;
+
+	u32 delay1 = readl(host->regs + SD_EMMC_DELAY1);
+	u32 delay2 = readl(host->regs + SD_EMMC_DELAY2);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+
+	if (host->save_para == 0)
+		return;
+
+	temp_index = para->temperature / 10000;
+	if (para->temperature < 0 || temp_index > 6) {
+		para->update = 0;
+		return;
+	}
+
+	host->para.hs4[temp_index].delay1 = delay1;
+	host->para.hs4[temp_index].delay2 = delay2;
+	host->para.hs4[temp_index].intf3 = intf3;
+	host->para.hs4[temp_index].flag = TUNED_FLAG;
+	host->para.magic = TUNED_MAGIC; /*E~K\0*/
+	host->para.version = TUNED_VERSION;
+
+	checksum = _para_checksum_calc(para);
+	host->para.checksum = checksum;
+}
+
+/*
+ * check if tuning parameter is exist
+ * check if temperature is in the 0~69
+ * check if the parameter has been tuning
+ *		under the current temperature
+ * check if the data had been broken by  checksum
+ *
+ * if all four condition above is yes, the tuning parameter
+ *		could be use directly
+ * otherwise returning and save parameter
+ */
+static int aml_para_is_exist(struct mmc_host *mmc)
+{
+	int temperature;
+	int temp_index;
+	long long checksum;
+	struct meson_host *host = mmc_priv(mmc);
+	struct aml_tuning_para *para = &host->para;
+	int i;
+
+	if (host->save_para == 0)
+		return 0;
+
+	para->update = 1;
+	temperature = -1;
+
+	if (temperature == -1) {
+		para->update = 0;
+		pr_info("get temperature failed\n");
+		return 0;
+	}
+	pr_info("current temperature is %d\n", temperature);
+
+	temp_index = temperature / 10000;
+	para->temperature = temperature;
+
+	checksum = _para_checksum_calc(para);
+	if (checksum != para->checksum) {
+		pr_info("warning: checksum is not match\n");
+		return 0;
+	}
+
+	if (para->magic != TUNED_MAGIC) {
+		pr_warn("[%s] magic is not match\n", __func__);
+		return 0;
+	}
+
+	if (para->version != TUNED_VERSION) {
+		pr_warn("[%s] VERSION is not match\n", __func__);
+		return 0;
+	}
+
+	if (host->compute_cmd_delay == 1) {
+		for (i = 0; i < 7; i++) {
+			if (para->hs4[i].flag == TUNED_FLAG) {
+				host->first_temp_index = i;
+				host->cur_temp_index = temp_index;
+				para->update = 0;
+				return 1;
+			}
+		}
+	}
+
+	/* temperature range is 0 ~ 69 */
+	if (temperature < 0 || temp_index > 6) {
+		pr_info("temperature is out of normal range\n");
+		return 0;
+	}
+
+	if (para->hs4[temp_index].flag != TUNED_FLAG) {
+		pr_info("current temperature %d degree not tuning yet\n",
+			temperature / 1000);
+		return 0;
+	}
+
+	para->update = 0;
+
+	return 1;
+}
+
+/* Insufficient number of NWR clocks in T7 EMMC Controller */
+static void set_emmc_nwr_clks(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 delay1 = 0, delay2 = 0, count = host->nwr_cnt;
+
+	delay1 = (count << 0) | (count << 6) | (count << 12) |
+		(count << 18) | (count << 24);
+	delay2 = (count << 0) | (count << 6) | (count << 12) |
+		(count << 18);
+	writel(delay1, host->regs + SD_EMMC_DELAY1);
+	writel(delay2, host->regs + SD_EMMC_DELAY2);
+	pr_info("[%s], delay1: 0x%x, delay2: 0x%x\n",
+		__func__, readl(host->regs + SD_EMMC_DELAY1),
+		readl(host->regs + SD_EMMC_DELAY2));
+}
+
+static void set_emmc_cmd_sample(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+
+	intf3 |= CFG_RX_PN;
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+}
+
+static void aml_emmc_hs400_v5(struct mmc_host *mmc)
+{
+	u32 cmd_size = 0;
+
+	mmc->retune_crc_disable = true;
+	set_emmc_nwr_clks(mmc);
+	cmd_size = set_emmc_cmd_delay(mmc, 1);
+	if (cmd_size == EMMC_CMD_WIN_FULL_SIZE) {
+		set_emmc_cmd_sample(mmc);
+		cmd_size = set_emmc_cmd_delay(mmc, 1);
+		pr_debug(">>>cmd_size:%u\n", cmd_size);
+	}
+	emmc_ds_manual_sht(mmc);
+}
+
+static void aml_get_ctrl_ver(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+
+	if (host->ignore_desc_busy)
+		aml_emmc_hs400_v5(mmc);
+	else
+		aml_emmc_hs400_tl1(mmc);
+}
+
+static void aml_post_hs400_timming(struct mmc_host *mmc)
+{
+	aml_sd_emmc_clktest(mmc);
+
+	if (aml_para_is_exist(mmc)) {
+		aml_set_tuning_para(mmc);
+		return;
+	}
+	aml_get_ctrl_ver(mmc);
+
+	aml_save_tuning_para(mmc);
+}
+
+static void aml_sd_emmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 vclkc = 0, virqc = 0;
+
+	host->sdio_irqen = enable;
+
+	virqc = readl(host->regs + SD_EMMC_IRQ_EN);
+	virqc &= ~IRQ_SDIO;
+	if (enable)
+		virqc |= IRQ_SDIO;
+	writel(virqc, host->regs + SD_EMMC_IRQ_EN);
+
+	if (!host->irq_sdio_sleep) {
+		vclkc = readl(host->regs + SD_EMMC_CLOCK);
+		vclkc |= CFG_IRQ_SDIO_SLEEP;
+		vclkc &= ~CFG_IRQ_SDIO_SLEEP_DS;
+		writel(vclkc, host->regs + SD_EMMC_CLOCK);
+		host->irq_sdio_sleep = 1;
+	}
+
+	/* check if irq already occurred */
+	aml_sd_emmc_check_sdio_irq(host);
+}
+
+static void meson_mmc_read_resp(struct mmc_host *mmc, struct mmc_command *cmd)
+{
+	struct meson_host *host = mmc_priv(mmc);
+
+	if (cmd->flags & MMC_RSP_136) {
+		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP3);
+		cmd->resp[1] = readl(host->regs + SD_EMMC_CMD_RSP2);
+		cmd->resp[2] = readl(host->regs + SD_EMMC_CMD_RSP1);
+		cmd->resp[3] = readl(host->regs + SD_EMMC_CMD_RSP);
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+		cmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP);
+	}
+}
+
+void aml_host_bus_fsm_show(struct mmc_host *mmc, int status)
+{
+	int fsm_val = 0;
+
+	fsm_val = (status & BUS_FSM_MASK) >> __ffs(BUS_FSM_MASK);
+	switch (fsm_val) {
+	case BUS_FSM_IDLE:
+		pr_err("%s: err: idle, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_SND_CMD:
+		pr_err("%s: err: send cmd, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_CMD_DONE:
+		pr_err("%s: err: wait for cmd done, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_RESP_START:
+		pr_err("%s: err: resp start, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_RESP_DONE:
+		pr_err("%s: err: wait for resp done, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_DATA_START:
+		pr_err("%s: err: data start, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_DATA_DONE:
+		pr_err("%s: err: wait for data done, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_DESC_WRITE_BACK:
+		pr_err("%s: err: wait for desc write back, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	case BUS_FSM_IRQ_SERVICE:
+		pr_err("%s: err: wait for irq service, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	default:
+		pr_err("%s: err: unknown err, bus_fsm:0x%x\n",
+				mmc_hostname(mmc), fsm_val);
+		break;
+	}
+}
+
+static irqreturn_t meson_mmc_irq(int irq, void *dev_id)
+{
+	struct meson_host *host = dev_id;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 irq_en, status, raw_status;
+	irqreturn_t ret = IRQ_NONE;
+
+	if (WARN_ON(!host))
+		return IRQ_NONE;
+
+	if (!host->cmd && (aml_card_type_mmc(host) ||
+			aml_card_type_non_sdio(host))) {
+		pr_debug("ignore irq.[%s]status:0x%x\n",
+			__func__, readl(host->regs + SD_EMMC_STATUS));
+#if IS_ENABLED(CONFIG_AMLOGIC_MMC_CQHCI)
+		if (host->mmc->cqe_on) {
+			pr_debug("[%s]Enter cqe irq\n", __func__);
+			aml_cqhci_irq(host);
+		}
+		/*
+		 * clear invalid irq,When emmc reports an error,
+		 * error_bit and end_of_chain will not be level triggered at the same
+		 * time and many invalid interrupts will be generated
+		 */
+		writel(0x7fff, host->regs + SD_EMMC_STATUS);
+#endif
+		return IRQ_HANDLED;
+	}
+
+	irq_en = readl(host->regs + SD_EMMC_IRQ_EN);
+	raw_status = readl(host->regs + SD_EMMC_STATUS);
+	status = raw_status & irq_en;
+
+	if (status & IRQ_SDIO) {
+		if (host->mmc->sdio_irq_thread &&
+		    (!atomic_read(&host->mmc->sdio_irq_thread_abort))) {
+			mmc_signal_sdio_irq(host->mmc);
+			if (!(status & 0x3fff))
+				return IRQ_HANDLED;
+		}
+	} else if (!(status & 0x3fff)) {
+		return IRQ_HANDLED;
+	}
+
+	cmd = host->cmd;
+	data = cmd->data;
+	if (WARN_ON(!host->cmd)) {
+		dev_err(host->dev, "host->cmd is NULL.\n");
+		return IRQ_HANDLED;
+	}
+
+	cmd->error = 0;
+	if (status & IRQ_CRC_ERR) {
+		if (!host->is_tuning)
+			dev_err(host->dev, "%d [0x%x], CRC[0x%04x]\n",
+				cmd->opcode, cmd->arg, status);
+		if (host->debug_flag && !host->is_tuning) {
+			dev_notice(host->dev, "clktree : 0x%x,host_clock: 0x%x\n",
+				   readl(host->clk_tree_base),
+				   readl(host->regs));
+			dev_notice(host->dev, "adjust: 0x%x,cfg: 0x%x,intf3: 0x%x\n",
+				   readl(host->regs + SD_EMMC_V3_ADJUST),
+				   readl(host->regs + SD_EMMC_CFG),
+				   readl(host->regs + SD_EMMC_INTF3));
+			dev_notice(host->dev, "irq_en: 0x%x\n",
+				   readl(host->regs + 0x4c));
+			dev_notice(host->dev, "delay1: 0x%x,delay2: 0x%x\n",
+				   readl(host->regs + SD_EMMC_DELAY1),
+				   readl(host->regs + SD_EMMC_DELAY2));
+			dev_notice(host->dev, "pinmux: 0x%x\n",
+				   readl(host->pin_mux_base));
+		}
+		cmd->error = -EILSEQ;
+		ret = IRQ_WAKE_THREAD;
+		goto out;
+	}
+
+	if (status & IRQ_TIMEOUTS) {
+		if (!host->is_tuning && !(cmd->arg == 0xc00 || cmd->arg == 0x80000c08))
+			dev_err(host->dev, "%d [0x%x], TIMEOUT[0x%04x]\n",
+				cmd->opcode, cmd->arg, status);
+		if (host->debug_flag && !host->is_tuning) {
+			dev_notice(host->dev, "clktree : 0x%x,host_clock: 0x%x\n",
+				   readl(host->clk_tree_base),
+				   readl(host->regs));
+			dev_notice(host->dev, "adjust: 0x%x,cfg: 0x%x,intf3: 0x%x\n",
+				   readl(host->regs + SD_EMMC_V3_ADJUST),
+				   readl(host->regs + SD_EMMC_CFG),
+				   readl(host->regs + SD_EMMC_INTF3));
+			dev_notice(host->dev, "delay1: 0x%x,delay2: 0x%x\n",
+				   readl(host->regs + SD_EMMC_DELAY1),
+				   readl(host->regs + SD_EMMC_DELAY2));
+			dev_notice(host->dev, "pinmux: 0x%x\n",
+				   readl(host->pin_mux_base));
+			dev_notice(host->dev, "irq_en: 0x%x\n",
+				   readl(host->regs + 0x4c));
+		}
+		cmd->error = -ETIMEDOUT;
+		ret = IRQ_WAKE_THREAD;
+		goto out;
+	}
+
+	if (status & (IRQ_CRC_ERR | IRQ_TIMEOUTS))
+		aml_host_bus_fsm_show(host->mmc, status);
+
+	meson_mmc_read_resp(host->mmc, cmd);
+
+	if (status & IRQ_SDIO) {
+		dev_dbg(host->dev, "IRQ: SDIO TODO.\n");
+		ret = IRQ_HANDLED;
+	}
+
+	if (status & (IRQ_END_OF_CHAIN | IRQ_RESP_STATUS)) {
+		if (data && !cmd->error)
+			data->bytes_xfered = data->blksz * data->blocks;
+		if (meson_mmc_bounce_buf_read(data))
+			ret = IRQ_WAKE_THREAD;
+		else
+			ret = IRQ_HANDLED;
+	}
+
+out:
+	/* ack all raised interrupts */
+	writel(0x7fff, host->regs + SD_EMMC_STATUS);
+	if (cmd->error) {
+		/* Stop desc in case of errors */
+		u32 start = readl(host->regs + SD_EMMC_START);
+
+		if (!host->ignore_desc_busy && (start & START_DESC_BUSY)) {
+			start &= ~START_DESC_BUSY;
+			writel(start, host->regs + SD_EMMC_START);
+		}
+	}
+
+	if (ret == IRQ_HANDLED) {
+		meson_mmc_read_resp(host->mmc, cmd);
+		if (cmd->error && !host->is_tuning)
+			pr_err("cmd = %d, arg = 0x%x, dev_status = 0x%x\n",
+					cmd->opcode, cmd->arg, cmd->resp[0]);
+		meson_mmc_request_done(host->mmc, cmd->mrq);
+	} else if (ret == IRQ_NONE) {
+		dev_warn(host->dev,
+				"Unexpected IRQ! status=0x%08x, irq_en=0x%08x\n",
+				raw_status, irq_en);
+	}
+
+	return ret;
+}
+
+static int meson_mmc_wait_desc_stop(struct meson_host *host)
+{
+	u32 status;
+
+	/*
+	 * It may sometimes take a while for it to actually halt. Here, we
+	 * are giving it 5ms to comply
+	 *
+	 * If we don't confirm the descriptor is stopped, it might raise new
+	 * IRQs after we have called mmc_request_done() which is bad.
+	 */
+
+	return readl_poll_timeout(host->regs + SD_EMMC_STATUS, status,
+				  !(status & (STATUS_BUSY | STATUS_DESC_BUSY)),
+				  100, 10000);
+}
+
+static irqreturn_t meson_mmc_irq_thread(int irq, void *dev_id)
+{
+	struct meson_host *host = dev_id;
+	struct mmc_command *cmd = host->cmd;
+	struct mmc_data *data;
+	unsigned int xfer_bytes;
+
+	if (WARN_ON(!cmd))
+		return IRQ_NONE;
+
+	if (cmd->error) {
+		meson_mmc_wait_desc_stop(host);
+		meson_mmc_request_done(host->mmc, cmd->mrq);
+
+		return IRQ_HANDLED;
+	}
+
+	data = cmd->data;
+	if (meson_mmc_bounce_buf_read(data)) {
+		xfer_bytes = data->blksz * data->blocks;
+		WARN_ON(xfer_bytes > host->bounce_buf_size);
+		sg_copy_from_buffer(data->sg, data->sg_len,
+				    host->bounce_buf, xfer_bytes);
+	}
+
+	meson_mmc_read_resp(host->mmc, cmd);
+	meson_mmc_request_done(host->mmc, cmd->mrq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * NOTE: we only need this until the GPIO/pinctrl driver can handle
+ * interrupts.  For now, the MMC core will use this for polling.
+ */
+static int meson_mmc_get_cd(struct mmc_host *mmc)
+{
+	int status = mmc_gpio_get_cd(mmc);
+
+	if (status == -EINVAL)
+		return 1; /* assume present */
+
+	return !status;
+}
+
+static void meson_mmc_cfg_init(struct meson_host *host)
+{
+	u32 cfg = 0;
+
+	cfg |= FIELD_PREP(CFG_RESP_TIMEOUT_MASK,
+			  ilog2(SD_EMMC_CFG_RESP_TIMEOUT));
+	cfg |= FIELD_PREP(CFG_RC_CC_MASK, ilog2(SD_EMMC_CFG_CMD_GAP));
+	cfg |= FIELD_PREP(CFG_BLK_LEN_MASK, ilog2(SD_EMMC_CFG_BLK_SIZE));
+
+	/* abort chain on R/W errors */
+
+	writel(cfg, host->regs + SD_EMMC_CFG);
+
+	/* The resp returned by cmd19 and cmd52/3 can't use the same mask */
+	writel(0x0, host->regs + 0x150);
+
+	host->timing = -1;
+}
+
+static int meson_mmc_card_busy(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 regval, val;
+
+	regval = readl(host->regs + SD_EMMC_STATUS);
+	if (!aml_card_type_mmc(host) && host->sd_sdio_switch_volat_done) {
+		val = readl(host->regs + SD_EMMC_CFG);
+		val |= CFG_AUTO_CLK;
+		writel(val, host->regs + SD_EMMC_CFG);
+		host->sd_sdio_switch_volat_done = 0;
+	}
+
+	/* We are only interrested in lines 0 to 3, so mask the other ones */
+	return !(FIELD_GET(STATUS_DATI, regval) & 0xf);
+}
+
+static int meson_mmc_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	int err;
+
+	if (IS_ERR(mmc->supply.vqmmc) && IS_ERR(mmc->supply.vmmc))
+		return 0;
+	/* vqmmc regulator is available */
+	if (!IS_ERR(mmc->supply.vqmmc)) {
+		/*
+		 * The usual amlogic setup uses a GPIO to switch from one
+		 * regulator to the other. While the voltage ramp up is
+		 * pretty fast, care must be taken when switching from 3.3v
+		 * to 1.8v. Please make sure the regulator framework is aware
+		 * of your own regulator constraints
+		 */
+		err = mmc_regulator_set_vqmmc(mmc, ios);
+
+		if (!err && ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)
+			host->sd_sdio_switch_volat_done = 1;
+
+		return err;
+	}
+
+	/* no vqmmc regulator, assume fixed regulator at 3/3.3V */
+	if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+		return 0;
+
+	return -EINVAL;
+}
+
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+int __maybe_unused aml_emmc_hs200_tl1(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 vclkc = readl(host->regs + SD_EMMC_CLOCK);
+	struct para_e *para = &host->sd_mmc;
+	u32 clk_bak = 0;
+	u32 delay2 = 0, count = 0;
+	int i, j, txdelay, err = 0;
+	int retry_times = 0;
+
+	aml_sd_emmc_clktest(mmc);
+	clk_bak = vclkc;
+	vclkc &= ~CLK_TX_PHASE_MASK;
+	vclkc &= ~CLK_CORE_PHASE_MASK;
+	vclkc &= ~CLK_V3_TX_DELAY_MASK;
+	vclkc |= para->hs4.tx_phase << __ffs(CLK_TX_PHASE_MASK);
+	vclkc |= para->hs4.core_phase << __ffs(CLK_CORE_PHASE_MASK);
+	vclkc |= para->hs4.tx_delay << __ffs(CLK_V3_TX_DELAY_MASK);
+	txdelay = para->hs4.tx_delay;
+
+	writel(vclkc, host->regs + SD_EMMC_CLOCK);
+	pr_info("[%s][%d] clk config:0x%x\n",
+		__func__, __LINE__, readl(host->regs + SD_EMMC_CLOCK));
+
+	for (i = 0; i < 63; i++) {
+		retry_times = 0;
+		delay2 += (1 << 24);
+		writel(delay2, host->regs + SD_EMMC_DELAY2);
+retry:
+		err = emmc_eyetest_log(mmc, 9);
+		if (err)
+			continue;
+
+		count = __ffs(host->align[9]);
+		if ((count >= 14 && count <= 20) ||
+		    (count >= 48 && count <= 54)) {
+			if (retry_times != 3) {
+				retry_times++;
+				goto retry;
+			} else {
+				break;
+			}
+		}
+	}
+	if (i == 63) {
+		for (j = 0; j < 6; j++) {
+			txdelay++;
+			vclkc &= ~CLK_V3_TX_DELAY_MASK;
+			vclkc |= para->hs4.tx_delay <<
+				__ffs(CLK_V3_TX_DELAY_MASK);
+			pr_info("modify tx delay to %d\n", txdelay);
+			writel(vclkc, host->regs + SD_EMMC_CLOCK);
+			err = emmc_eyetest_log(mmc, 9);
+			if (err)
+				continue;
+			count = __ffs(host->align[9]);
+			if ((count >= 14 && count <= 20) ||
+			    (count >= 48 && count <= 54))
+				break;
+		}
+	}
+
+	host->cmd_c = (delay2 >> 24);
+	pr_info("cmd->u64eyet:0x%016llx\n", host->align[9]);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	writel(clk_bak, host->regs + SD_EMMC_CLOCK);
+
+	delay2 = 0;
+	for (i = 0; i < 63; i++) {
+		retry_times = 0;
+		delay2 += (1 << 24);
+		writel(delay2, host->regs + SD_EMMC_DELAY2);
+retry1:
+		err = emmc_eyetest_log(mmc, 9);
+		if (err)
+			continue;
+
+		count = __ffs(host->align[9]);
+		if (count >= 8 && count <= 56) {
+			if (retry_times != 3) {
+				retry_times++;
+				goto retry1;
+			} else {
+				break;
+			}
+		}
+	}
+
+	pr_info("[%s][%d] clk config:0x%x\n",
+		__func__, __LINE__, readl(host->regs + SD_EMMC_CLOCK));
+	return 0;
+}
+#endif
+
+static int intf3_scan(struct mmc_host *mmc, u32 opcode)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 intf3;
+	u32 i, j, err;
+	char rx_r[64] = {0}, rx_f[64] = {0};
+	u32 vclk = readl(host->regs + SD_EMMC_CLOCK);
+	int best_s1 = -1, best_sz1 = 0;
+	int best_s2 = -1, best_sz2 = 0;
+
+	intf3 = readl(host->regs + SD_EMMC_INTF3);
+	intf3 |= SD_INTF3;
+	intf3 &= ~EYETEST_SEL;
+
+	host->cmd_retune = 0;
+	for (i = 0; i < 2; i++) {
+		if (i)
+			intf3 |= RESP_SEL;
+		else
+			intf3 &= ~RESP_SEL;
+		writel(intf3, (host->regs + SD_EMMC_INTF3));
+		for (j = 0; j < 64; j++) {
+			vclk &= ~CLK_V3_RX_DELAY_MASK;
+			vclk |= j << __ffs(CLK_V3_RX_DELAY_MASK);
+			writel(vclk, host->regs + SD_EMMC_CLOCK);
+			if (aml_card_type_mmc(host)) {
+				err = emmc_test_bus(mmc);
+				if (!err) {
+					if (i)
+						rx_f[j]++;
+					else
+						rx_r[j]++;
+				}
+			} else {
+				err = meson_mmc_tuning_transfer(mmc, opcode);
+				if (err == TUNING_NUM_PER_POINT) {
+					if (i)
+						rx_f[j]++;
+					else
+						rx_r[j]++;
+				}
+			}
+		}
+	}
+	host->cmd_retune = 1;
+	find_best_win(mmc, rx_r, 64, &best_s1, &best_sz1, false);
+	find_best_win(mmc, rx_f, 64, &best_s2, &best_sz2, false);
+	if (host->debug_flag) {
+		emmc_show_cmd_window(rx_r, 1);
+		emmc_show_cmd_window(rx_f, 1);
+	}
+	pr_info("r: b_s = %x, b_sz = %x, f: b_s = %x, b_sz = %x\n",
+		best_s1, best_sz1, best_s2, best_sz2);
+
+	if (!best_sz1 && !best_sz2)
+		return -1;
+
+	vclk &= ~CLK_V3_RX_DELAY_MASK;
+	if (best_sz1 >= best_sz2) {
+		intf3 &= ~RESP_SEL;
+		vclk |= (best_s1 + best_sz1 / 2) << __ffs(CLK_V3_RX_DELAY_MASK);
+	} else {
+		intf3 |= RESP_SEL;
+		vclk |= (best_s2 + best_sz2 / 2) << __ffs(CLK_V3_RX_DELAY_MASK);
+	}
+	pr_info("the final result: sel = %lx, rx = %lx\n",
+		(intf3 & SD_INTF3) >> __ffs(SD_INTF3),
+		(vclk & CLK_V3_RX_DELAY_MASK) >> __ffs(CLK_V3_RX_DELAY_MASK));
+	writel(vclk, host->regs + SD_EMMC_CLOCK);
+	writel(intf3, host->regs + SD_EMMC_INTF3);
+
+	return 0;
+}
+
+static int mmc_intf3_win_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 vclk, ret = -1;
+
+	vclk = readl(host->regs + SD_EMMC_CLOCK);
+
+	if ((vclk & CLK_DIV_MASK) > 8) {
+		pr_err("clk div is too big.\n");
+		return -1;
+	}
+
+	vclk &= ~CLK_V3_RX_DELAY_MASK;
+	writel(vclk, host->regs + SD_EMMC_CLOCK);
+	writel(0, host->regs + SD_EMMC_DELAY1);
+	writel(0, host->regs + SD_EMMC_DELAY2);
+	writel(0, host->regs + SD_EMMC_V3_ADJUST);
+	writel(0, host->regs + SD_EMMC_INTF3);
+
+	ret = intf3_scan(mmc, opcode);
+	if (ret)
+		pr_err("scan intf3 rx window fail.\n");
+
+	return ret;
+}
+
+static int meson_mmc_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	int err = 0;
+
+	host->is_tuning = 1;
+	if (host->use_intf3_tuning)
+		err = mmc_intf3_win_tuning(mmc, opcode);
+	else
+		err = meson_mmc_fixadj_tuning(mmc, opcode);
+
+	host->is_tuning = 0;
+
+	return err;
+}
+
+
+static void sdio_rescan(struct mmc_host *mmc)
+{
+	int ret;
+
+	mmc->rescan_entered = 0;
+	//mmc->host_rescan_disable = false;
+	mmc_detect_change(mmc, 0);
+	// start the delayed_work
+	ret = flush_work(&mmc->detect.work);
+	// wait for the delayed_work to finish
+	if (!ret)
+		pr_info("Error: delayed_work mmc_rescan() already idle!\n");
+}
+
+static void sdio_reset_comm(struct mmc_card *card)
+{
+	int i = 0, err = 0;
+
+	while (i < SDIO_MAX_FUNCS && !card->sdio_func[i])
+		i++;
+	if (WARN_ON(i == SDIO_MAX_FUNCS))
+		return;
+	sdio_claim_host(card->sdio_func[i]);
+	err = mmc_sw_reset(card);
+	sdio_release_host(card->sdio_func[i]);
+	if (err)
+		pr_info("%s Failed, error = %d\n", __func__, err);
+	return;
+}
+
+void sdio_reinit(void)
+{
+	if (sdio_host) {
+		struct mmc_ios *ios = &sdio_host->ios;
+
+		if (sdio_host->card) {
+			if (ios)
+				ios->timing = 0;
+			sdio_reset_comm(sdio_host->card);
+		}
+		else
+			sdio_rescan(sdio_host);
+	} else {
+		pr_info("Error: sdio_host is NULL\n");
+	}
+
+	pr_debug("[%s] finish\n", __func__);
+}
+EXPORT_SYMBOL(sdio_reinit);
+
+void sdio_clk_always_on(bool clk_aws_on)
+{
+	struct meson_host *host = NULL;
+	u32 conf = 0;
+
+	if (sdio_host) {
+		host = mmc_priv(sdio_host);
+		conf = readl(host->regs + SD_EMMC_CFG);
+		if (clk_aws_on)
+			conf &= ~CFG_AUTO_CLK;
+		else
+			conf |= CFG_AUTO_CLK;
+		writel(conf, host->regs + SD_EMMC_CFG);
+		pr_info("[%s] clk:0x%x, cfg:0x%x\n",
+				__func__, readl(host->regs + SD_EMMC_CLOCK),
+				readl(host->regs + SD_EMMC_CFG));
+	} else {
+		pr_info("Error: sdio_host is NULL\n");
+	}
+
+	pr_info("[%s] finish\n", __func__);
+}
+EXPORT_SYMBOL(sdio_clk_always_on);
+
+void sdio_set_max_regs(unsigned int size)
+{
+	if (sdio_host) {
+		sdio_host->max_req_size = size;
+		sdio_host->max_seg_size = sdio_host->max_req_size;
+	} else {
+		pr_info("Error: sdio_host is NULL\n");
+	}
+
+	pr_info("[%s] finish\n", __func__);
+}
+EXPORT_SYMBOL(sdio_set_max_regs);
+
+/*this function tells wifi is using sd(sdiob) or sdio(sdioa)*/
+const char *get_wifi_inf(void)
+{
+	if (sdio_host)
+		return mmc_hostname(sdio_host);
+	else
+		return "sdio";
+}
+EXPORT_SYMBOL(get_wifi_inf);
+
+int sdio_get_vendor(void)
+{
+	int vendor = 0;
+
+	if (sdio_host && sdio_host->card)
+		vendor = sdio_host->card->cis.vendor;
+
+	pr_info("sdio vendor is 0x%x\n", vendor);
+	return vendor;
+}
+EXPORT_SYMBOL(sdio_get_vendor);
+
+static struct pinctrl * __must_check aml_pinctrl_select(struct meson_host *host,
+							const char *name)
+{
+	struct pinctrl *p = host->pinctrl;
+	struct pinctrl_state *s;
+	int ret = 1;
+
+	if (!p) {
+		dev_err(host->dev, "%s NULL POINT!!\n", __func__);
+		return ERR_PTR(ret);
+	}
+
+	s = pinctrl_lookup_state(p, name);
+	if (IS_ERR(s)) {
+		pr_err("lookup %s fail\n", name);
+		devm_pinctrl_put(p);
+		return ERR_CAST(s);
+	}
+
+	ret = pinctrl_select_state(p, s);
+	if (ret < 0) {
+		pr_err("select %s fail\n", name);
+		devm_pinctrl_put(p);
+		return ERR_PTR(ret);
+	}
+	return p;
+}
+
+static int aml_uart_switch(struct meson_host *host, bool on)
+{
+	struct pinctrl *pc;
+	char *name[2] = {
+		"sd_to_ao_uart_pins",
+		"ao_to_sd_uart_pins",
+	};
+
+	pc = aml_pinctrl_select(host, name[on]);
+	return on;
+}
+
+static int aml_is_sduart(struct meson_host *host)
+{
+	int in = 0, i;
+	int high_cnt = 0, low_cnt = 0;
+	u32 vstat = 0;
+
+	if (host->is_uart)
+		return 0;
+	//if (!host->sd_uart_init) {
+	//	aml_uart_switch(host, 0);
+	//} else {
+	//	in = (readl(host->pin_mux_base) & DATA3_PINMUX_MASK) >>
+	//		__ffs(DATA3_PINMUX_MASK);
+	//	if (in == 2)
+	//		return 1;
+	//	else
+	//		return 0;
+	//}
+	for (i = 0; ; i++) {
+		mdelay(1);
+		vstat = readl(host->regs + SD_EMMC_STATUS) & 0xffffffff;
+		if (vstat & 0x80000) {
+			high_cnt++;
+			low_cnt = 0;
+		} else {
+			low_cnt++;
+			high_cnt = 0;
+		}
+		if (high_cnt > 100 || low_cnt > 100)
+			break;
+	}
+	if (low_cnt > 100)
+		in = 1;
+	return in;
+}
+
+static int aml_is_card_insert(struct mmc_gpio *ctx)
+{
+	int ret = 0, in_count = 0, out_count = 0, i;
+
+	if (ctx->cd_gpio) {
+		for (i = 0; i < 200; i++) {
+			ret = gpiod_get_value(ctx->cd_gpio);
+			if (ret)
+				out_count++;
+			in_count++;
+			if (out_count > 100 || in_count > 100)
+				break;
+		}
+		if (out_count > 100)
+			ret = 1;
+		else if (in_count > 100)
+			ret = 0;
+	}
+//        if (ctx->override_cd_active_level)
+  //              ret = !ret; /* reverse, so ---- 0: no inserted  1: inserted */
+
+	return ret;
+}
+
+int meson_mmc_cd_detect(struct mmc_host *mmc)
+{
+	int gpio_val, val, ret;
+	struct meson_host *host = mmc_priv(mmc);
+	struct mmc_gpio *ctx = mmc->slot.handler_priv;
+
+	gpio_val = aml_is_card_insert(ctx);
+	dev_dbg(host->dev, "card %s\n", gpio_val ? "OUT" : "IN");
+	mmc->trigger_card_event = true;
+	if (!gpio_val) {//card insert
+		if (host->card_insert)
+			return 0;
+		host->card_insert = 1;
+		val = aml_is_sduart(host);
+		dev_notice(host->dev, " %s insert\n", val ? "UART" : "SDCARD");
+		if (val) {//uart insert
+			host->is_uart = 1;
+			aml_uart_switch(host, 1);
+			mmc->caps &= ~MMC_CAP_4_BIT_DATA;
+			host->pins_default = pinctrl_lookup_state(host->pinctrl,
+								  "sd_1bit_pins");
+			if (IS_ERR(host->pins_default)) {
+				ret = PTR_ERR(host->pins_default);
+				return ret;
+			}
+		} else {//sdcard insert
+			aml_uart_switch(host, 0);
+			mmc->caps |= MMC_CAP_4_BIT_DATA;
+			host->pins_default = pinctrl_lookup_state(host->pinctrl,
+								  "sd_default");
+		}
+	} else { //card out
+		if (!host->card_insert)
+			return 0;
+		if (host->is_uart) {
+			host->is_uart = 0;
+			devm_free_irq(mmc->parent, host->cd_irq, mmc);
+		}
+		host->card_insert = 0;
+		aml_uart_switch(host, 0);
+	}
+	if (!host->is_uart)
+		mmc_detect_change(mmc, msecs_to_jiffies(200));
+	return 0;
+}
+
+static void scan_emmc_tx_win(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 vclk = readl(host->regs + SD_EMMC_CLOCK);
+	u32 dly1 = readl(host->regs + SD_EMMC_DELAY1);
+	u32 dly2 = readl(host->regs + SD_EMMC_DELAY2);
+	u32 intf3 = readl(host->regs + SD_EMMC_INTF3);
+	u32 clk_bak = vclk, dly1_bak = dly1, dly2_bak = dly2;
+	u32 intf3_bak = intf3;
+	u32 i, j, err;
+	u8 tx_delay = (vclk & CLK_V3_TX_DELAY_MASK) >>
+		__ffs(CLK_V3_TX_DELAY_MASK);
+	int repeat_times = 100;
+	char str[64] = {0};
+
+	aml_sd_emmc_cali_v3(mmc, MMC_READ_MULTIPLE_BLOCK,
+			    host->blk_test, 512, 40, MMC_RANDOM_NAME);
+	host->is_tuning = 1;
+	tx_delay = 0;
+	vclk &= ~CLK_V3_TX_DELAY_MASK;
+	vclk |= tx_delay << __ffs(CLK_V3_TX_DELAY_MASK);
+	writel(vclk, host->regs + SD_EMMC_CLOCK);
+	for (i = tx_delay; i < 64; i++) {
+		writel(0, host->regs + SD_EMMC_DELAY1);
+		writel(0, host->regs + SD_EMMC_DELAY2);
+		writel(SD_INTF3, host->regs + SD_EMMC_INTF3);
+		aml_get_ctrl_ver(mmc);
+		for (j = 0; j < repeat_times; j++) {
+			err = mmc_write_internal(mmc->card, MMC_RANDOM_OFFSET,
+						 40, host->blk_test);
+			if (!err)
+				str[i]++;
+			else
+				break;
+		}
+		tx_delay += 1;
+		vclk &= ~CLK_V3_TX_DELAY_MASK;
+		vclk |= tx_delay << __ffs(CLK_V3_TX_DELAY_MASK);
+		writel(vclk, host->regs + SD_EMMC_CLOCK);
+		pr_debug("tx_delay: 0x%x, send cmd %d times success %d times, is ok\n",
+			 tx_delay, repeat_times, str[i]);
+	}
+	host->is_tuning = 0;
+
+	writel(clk_bak, host->regs + SD_EMMC_CLOCK);
+	writel(dly1_bak, host->regs + SD_EMMC_DELAY1);
+	writel(dly2_bak, host->regs + SD_EMMC_DELAY2);
+	writel(intf3_bak, host->regs + SD_EMMC_INTF3);
+	emmc_search_cmd_delay(str, repeat_times, NULL);
+	pr_info(">>>>>>>>>>>>>>>>>>>>this is tx window>>>>>>>>>>>>>>>>>>>>>>\n");
+	emmc_show_cmd_window(str, repeat_times);
+}
+
+void emmc_eyetestlog(struct mmc_host *mmc)
+{
+	struct meson_host *host = mmc_priv(mmc);
+	u32 dly, dly1_bak, dly2_bak;
+	int i = 0;
+
+	dly1_bak = readl(host->regs + SD_EMMC_DELAY1);
+	dly2_bak = readl(host->regs + SD_EMMC_DELAY2);
+	for (i = 0; i < 64; i++) {
+		dly = (i << 0) | (i << 6) | (i << 12) | (i << 18) | (i << 24);
+		writel(dly, host->regs + SD_EMMC_DELAY1);
+		writel(dly, host->regs + SD_EMMC_DELAY2);
+		update_all_line_eyetest(mmc);
+	}
+	writel(dly1_bak, host->regs + SD_EMMC_DELAY1);
+	writel(dly2_bak, host->regs + SD_EMMC_DELAY2);
+}
+
+static const struct mmc_host_ops meson_mmc_ops = {
+	.request	= meson_mmc_request,
+	.set_ios	= meson_mmc_set_ios,
+	.enable_sdio_irq = aml_sd_emmc_enable_sdio_irq,
+	.get_cd         = meson_mmc_get_cd,
+	.pre_req	= meson_mmc_pre_req,
+	.post_req	= meson_mmc_post_req,
+	.execute_tuning = meson_mmc_execute_tuning,
+	.hs400_complete = aml_post_hs400_timming,
+	.card_busy	= meson_mmc_card_busy,
+	.start_signal_voltage_switch = meson_mmc_voltage_switch,
+//	.init_card      = sdio_get_card,
+};
+
+static int mmc_clktest_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*host = s->private;
+	int count = 0;
+
+	mmc_claim_host(host);
+	count = emmc_clktest(host);
+	mmc_release_host(host);
+
+	seq_puts(s, "mmc clktest done\n");
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mmc_clktest);
+
+static int mmc_eyetest_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*host = s->private;
+
+	mmc_claim_host(host);
+	update_all_line_eyetest(host);
+	mmc_release_host(host);
+
+	seq_puts(s, "mmc eyetest done\n");
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mmc_eyetest);
+
+static int mmc_tx_win_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*host = s->private;
+
+	mmc_claim_host(host);
+	scan_emmc_tx_win(host);
+	mmc_release_host(host);
+
+	seq_puts(s, "mmc tx win done\n");
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mmc_tx_win);
+
+static int mmc_cmd_rx_win_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*host = s->private;
+
+	mmc_claim_host(host);
+	scan_emmc_cmd_win(host, 0, NULL);
+	mmc_release_host(host);
+
+	seq_puts(s, "mmc cmd rx win done\n");
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mmc_cmd_rx_win);
+
+static int mmc_eyetestlog_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*host = s->private;
+
+	mmc_claim_host(host);
+	emmc_eyetestlog(host);
+	mmc_release_host(host);
+
+	seq_puts(s, "mmc eyetestlog done\n");
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mmc_eyetestlog);
+
+/* To provide Total Write Size which is cumulative written data
+ * size from Host to e-MMC. The unit is MByte.
+ *
+ * The Total Write Size counts total blocks written by Write Multiple
+ * Block(CMD25). The other CMDs such as CMD24 or CMDQ are not counted.
+ */
+static int write_size_get(void *data, u64 *val)
+{
+	struct mmc_host *mmc = data;
+	unsigned char *buf = NULL;
+	u32 err;
+
+	buf = kmalloc(512, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mmc_claim_host(mmc);
+	err = single_read_scan(mmc, MMC_GEN_CMD, buf, 512, 1, 0x42535491);
+	if (err || buf[0] != 0x91 || buf[1] != 0x50) {
+		pr_err("%s: read error", __func__);
+		return -EINVAL;
+	}
+	mmc_release_host(mmc);
+
+	*val = buf[19] << 0
+		| (u64)buf[18] << 8
+		| (u64)buf[17] << 16
+		| (u64)buf[16] << 24;
+	kfree(buf);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_write_size, write_size_get,
+			 NULL, "%llu\n");
+
+/* Check the average erase count including average value of erase
+ * count in TLC area and average value of erase count in pseudo
+ * SLC area.
+ */
+static int erase_count_show(struct seq_file *s, void *data)
+{
+	struct mmc_host	*mmc = s->private;
+	unsigned char *buf = NULL;
+	u32 err, tlc, slc;
+
+	buf = kmalloc(512, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mmc_claim_host(mmc);
+	err = single_read_scan(mmc, MMC_GEN_CMD, buf, 512, 1, 0x42535493);
+	if (err || buf[0] != 0x93 || buf[1] != 0x50) {
+		pr_err("%s: read error", __func__);
+		return -EINVAL;
+	}
+
+	mmc_release_host(mmc);
+	tlc = buf[27] << 0
+		| (u32)buf[26] << 8
+		| (u32)buf[25] << 16
+		| (u32)buf[24] << 24;
+
+	slc = buf[43] << 0
+		| (u32)buf[42] << 8
+		| (u32)buf[41] << 16
+		| (u32)buf[40] << 24;
+
+	seq_printf(s, "tlc: 0x%x slc: 0x%x", tlc, slc);
+	seq_putc(s, '\n');
+	kfree(buf);
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(erase_count);
+
+static int card_proc_show(struct seq_file *m, void *v)
+{
+	seq_puts(m, "null node\n");
+
+	return 0;
+}
+
+static int card_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, card_proc_show, NULL);
+}
+
+static const struct proc_ops card_proc_fops = {
+	.proc_open = card_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+
+static ssize_t get_bootloader_offset(const struct class *class,
+		const struct class_attribute *attr, char *buf)
+{
+	int offset = 0;
+
+	offset = 512;
+	return sprintf(buf, "%d", offset);
+}
+
+static struct class_attribute bootloader_offset =
+__ATTR(bl_off_bytes, 0444, get_bootloader_offset, NULL);
+
+int add_emmc_attr(void)
+{
+	int ret = 0;
+	struct class *aml_store_class = NULL;
+
+	if (!proc_create("inand", 0444, NULL, &card_proc_fops)) {
+		pr_info("[%s] create /proc/inand fail.\n", __func__);
+		ret = -1;
+		goto out;
+	}
+
+	aml_store_class = class_create("aml_store");
+	if (IS_ERR(aml_store_class)) {
+		pr_info("[%s] create aml_store_class class fail.\n", __func__);
+		ret = -1;
+		goto out;
+	}
+
+	ret = class_create_file(aml_store_class, &bootloader_offset);
+	if (ret) {
+		pr_info("[%s] can't create aml_store_class file .\n", __func__);
+		goto out_class;
+	}
+
+	return ret;
+
+out_class:
+	class_destroy(aml_store_class);
+out:
+	return ret;
+}
+
+void add_dtbkey(struct work_struct *work)
+{
+	int ret;
+	struct meson_host *host =
+		container_of(work, struct meson_host, dtbkey.work);
+	struct mmc_host *mmc = mmc_from_priv(host);
+
+	if (mmc->card) {
+		emmc_key_init(mmc->card, &ret);
+		if (ret)
+			pr_err("%s:%d,emmc_key_init fail\n", __func__, __LINE__);
+
+		amlmmc_dtb_init(mmc->card, &ret);
+		if (ret)
+			pr_err("%s:%d,amlmmc_dtb_init fail\n", __func__, __LINE__);
+		add_emmc_attr();
+	} else {
+		schedule_delayed_work(&host->dtbkey, 50);
+	}
+}
+
+static int meson_mmc_probe(struct platform_device *pdev)
+{
+	struct meson_host *host;
+	struct mmc_host *mmc;
+	int ret;
+	u32 val;
+
+	mmc = mmc_alloc_host(sizeof(struct meson_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, host);
+
+	/* The G12A SDIO Controller needs an SRAM bounce buffer */
+	host->dram_access_quirk = device_property_read_bool(&pdev->dev,
+					"amlogic,dram-access-quirk");
+
+	/* Get regulators and the supported OCR mask */
+	host->vqmmc_enabled = false;
+	ret = mmc_regulator_get_supply(mmc);
+	if (ret) {
+		dev_warn(&pdev->dev, "power regulator get failed!\n");
+		goto free_host;
+	}
+
+	ret = mmc_of_parse(mmc);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_warn(&pdev->dev, "error parsing DT: %d\n", ret);
+		goto free_host;
+	}
+	amlogic_of_parse(mmc);
+	mmc->hold_retune = 1;
+
+	if (aml_card_type_non_sdio(host)) {
+		if (!IS_ERR(mmc->supply.vqmmc))
+			regulator_set_voltage_triplet(mmc->supply.vqmmc, 1700000, 1800000, 1950000);
+	}
+
+	/* caps2 qurik for eMMC */
+	if (aml_card_type_mmc(host) && caps2_quirks &&
+		!strncmp(caps2_quirks,
+		"mmc-hs400", strlen(caps2_quirks))) {
+		dev_warn(&pdev->dev, "Force HS400\n");
+		mmc->caps2 |= MMC_CAP2_HS400_1_8V | MMC_CAP2_HS200_1_8V_SDR;
+	}
+
+	host->data = (struct meson_mmc_data *)
+		of_device_get_match_data(&pdev->dev);
+	if (!host->data) {
+		ret = -EINVAL;
+		goto free_host;
+	}
+
+	ret = device_reset_optional(&pdev->dev);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "device reset failed: %d\n", ret);
+
+		return ret;
+	}
+
+	host->res[0] = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->regs = devm_ioremap_resource(&pdev->dev, host->res[0]);
+	if (IS_ERR(host->regs)) {
+		ret = PTR_ERR(host->regs);
+		goto free_host;
+	}
+
+	host->res[1] = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	host->clk_tree_base = ioremap(host->res[1]->start, resource_size(host->res[1]));
+	if (IS_ERR(host->clk_tree_base)) {
+		ret = PTR_ERR(host->clk_tree_base);
+		goto free_host;
+	}
+
+	val = readl(host->clk_tree_base);
+	if (aml_card_type_non_sdio(host))
+		val &= EMMC_SDIO_CLOCK_FELD;
+	else
+		val &= ~EMMC_SDIO_CLOCK_FELD;
+	writel(val, host->clk_tree_base);
+
+	host->res[2] = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	host->pin_mux_base = ioremap(host->res[2]->start, resource_size(host->res[2]));
+	if (IS_ERR(host->pin_mux_base)) {
+		ret = PTR_ERR(host->pin_mux_base);
+		goto free_host;
+	}
+
+	host->irq = platform_get_irq(pdev, 0);
+	if (host->irq <= 0) {
+		ret = -EINVAL;
+		goto free_host;
+	}
+
+	host->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(host->pinctrl)) {
+		ret = PTR_ERR(host->pinctrl);
+		goto free_host;
+	}
+
+	if (aml_card_type_non_sdio(host))
+		host->pins_default = pinctrl_lookup_state(host->pinctrl,
+							  "sd_1bit_pins");
+	else
+		host->pins_default = pinctrl_lookup_state(host->pinctrl,
+							  "default");
+	if (IS_ERR(host->pins_default)) {
+		ret = PTR_ERR(host->pins_default);
+		goto free_host;
+	}
+
+	host->pins_clk_gate = pinctrl_lookup_state(host->pinctrl,
+						   "clk-gate");
+	if (IS_ERR(host->pins_clk_gate)) {
+		dev_warn(&pdev->dev,
+			 "can't get clk-gate pinctrl, using clk_stop bit\n");
+		host->pins_clk_gate = NULL;
+	}
+
+	if (host->run_pxp_flag == 0) {
+		host->core_clk = devm_clk_get(&pdev->dev, "core");
+		if (IS_ERR(host->core_clk)) {
+			ret = PTR_ERR(host->core_clk);
+			goto free_host;
+		}
+
+		ret = clk_prepare_enable(host->core_clk);
+		if (ret)
+			goto free_host;
+
+		ret = meson_mmc_clk_init(host);
+		if (ret)
+			goto err_core_clk;
+	} else {
+		meson_mmc_pxp_clk_init(host);
+	}
+
+	/* set config to sane default */
+	meson_mmc_cfg_init(host);
+
+	/* Stop execution */
+	writel(0, host->regs + SD_EMMC_START);
+
+	/* clear, ack and enable interrupts */
+	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
+	       host->regs + SD_EMMC_STATUS);
+	writel(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN,
+	       host->regs + SD_EMMC_IRQ_EN);
+
+	if (host->enable_hwcq) {
+		irq_set_affinity_hint(host->irq, cpumask_of(1));
+		ret = request_threaded_irq(host->irq, meson_mmc_irq,
+				   meson_mmc_irq_thread, IRQF_ONESHOT | IRQF_TRIGGER_HIGH,
+				   dev_name(&pdev->dev), host);
+	} else {
+		ret = request_threaded_irq(host->irq, meson_mmc_irq,
+				   meson_mmc_irq_thread, IRQF_ONESHOT,
+				   dev_name(&pdev->dev), host);
+	}
+	if (ret)
+		goto err_init_clk;
+	if (aml_card_type_mmc(host))
+		mmc->caps |= MMC_CAP_CMD23;
+	if (host->dram_access_quirk) {
+		/* Limit segments to 1 due to low available sram memory */
+		mmc->max_segs = 1;
+		/* Limit to the available sram memory */
+		mmc->max_blk_count = SD_EMMC_SRAM_DATA_BUF_LEN /
+				     mmc->max_blk_size;
+	} else {
+		mmc->max_blk_count = CMD_CFG_LENGTH_MASK;
+		mmc->max_segs = SD_EMMC_MAX_SEGS;
+	}
+	mmc->max_req_size = SD_EMMC_MAX_REQ_SIZE;
+	mmc->max_seg_size = mmc->max_req_size;
+	mmc->ocr_avail = 0x200080;
+	mmc->max_current_180 = 300; /* 300 mA in 1.8V */
+	mmc->max_current_330 = 300; /* 300 mA in 3.3V */
+
+	/*
+	 * At the moment, we don't know how to reliably enable HS400.
+	 * From the different datasheets, it is not even clear if this mode
+	 * is officially supported by any of the SoCs
+	 */
+
+	if (host->dram_access_quirk) {
+		/*
+		 * The MMC Controller embeds 1,5KiB of internal SRAM
+		 * that can be used to be used as bounce buffer.
+		 * In the case of the G12A SDIO controller, use these
+		 * instead of the DDR memory
+		 */
+		host->bounce_buf_size = SD_EMMC_SRAM_DATA_BUF_LEN;
+		host->bounce_buf = host->regs + SD_EMMC_SRAM_DATA_BUF_OFF;
+		host->bounce_dma_addr = host->res[0]->start + SD_EMMC_SRAM_DATA_BUF_OFF;
+
+		host->descs = host->regs + SD_EMMC_SRAM_DESC_BUF_OFF;
+		host->descs_dma_addr = host->res[0]->start + SD_EMMC_SRAM_DESC_BUF_OFF;
+
+	} else {
+		/* data bounce buffer */
+		host->bounce_buf_size = mmc->max_req_size;
+		host->bounce_buf =
+			dma_alloc_coherent(host->dev, host->bounce_buf_size,
+					   &host->bounce_dma_addr, GFP_KERNEL);
+		if (!host->bounce_buf) {
+			dev_err(host->dev, "Unable to map allocate DMA bounce buffer.\n");
+			ret = -ENOMEM;
+			goto err_free_irq;
+		}
+
+		host->descs = dma_alloc_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,
+			      &host->descs_dma_addr, GFP_KERNEL);
+		if (!host->descs) {
+			ret = -ENOMEM;
+			goto err_bounce_buf;
+		}
+	}
+
+	host->adj_win = devm_kzalloc(host->dev, sizeof(u8) * ADJ_WIN_PRINT_MAXLEN, GFP_KERNEL);
+	if (!host->adj_win) {
+		ret = -ENOMEM;
+		goto err_free_irq;
+	}
+
+	if (aml_card_type_sdio(host)) {
+		/* do NOT run mmc_rescan for the first time */
+		mmc->rescan_entered = 1;
+	} else {
+		mmc->rescan_entered = 0;
+	}
+	if (aml_card_type_non_sdio(host))
+		host->pins_default = pinctrl_lookup_state(host->pinctrl, "sd_default");
+
+	mmc->ops = &meson_mmc_ops;
+#if IS_ENABLED(CONFIG_AMLOGIC_MMC_CQHCI)
+	amlogic_add_host(host);
+#else
+	mmc_add_host(mmc);
+#endif
+
+	if (aml_card_type_sdio(host)) {/* if sdio_wifi */
+		sdio_host = mmc;
+	}
+
+	if (aml_card_type_mmc(host)) {
+		INIT_DELAYED_WORK(&host->dtbkey, add_dtbkey);
+		schedule_delayed_work(&host->dtbkey, 50);
+	}
+
+// #if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+// #ifdef CONFIG_ANDROID_VENDOR_HOOKS
+// 	if (aml_card_type_non_sdio(host)) {
+// 		ret =
+// 		register_trace_android_vh_mmc_sd_update_cmdline_timing(SD_CMD_TIMING,
+// 			NULL);
+// 		if (ret)
+// 			pr_err("register update_cmdline_timing failed, err:%d\n", ret);
+// 		ret =
+// 		register_trace_android_vh_mmc_sd_update_dataline_timing(SD_DATA_TIMING,
+// 			NULL);
+// 		if (ret)
+// 			pr_err("register update_dataline timing failed, err:%d\n", ret);
+// 	}
+// #endif
+// #endif
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	if (mmc->debugfs_root && aml_card_type_mmc(host)) {
+		host->debugfs_root = debugfs_create_dir(dev_name(&pdev->dev), mmc->debugfs_root);
+		if (IS_ERR_OR_NULL(host->debugfs_root))
+			pr_err("mmc debugfs creat failed\n");
+
+		debugfs_create_file("clktest", 0400, host->debugfs_root, mmc,
+				&mmc_clktest_fops);
+		debugfs_create_file("eyetest", 0400, host->debugfs_root, mmc,
+				&mmc_eyetest_fops);
+		debugfs_create_file("eyetestlog", 0400, host->debugfs_root, mmc,
+				&mmc_eyetestlog_fops);
+		debugfs_create_file("tx_win", 0400, host->debugfs_root, mmc,
+				&mmc_tx_win_fops);
+		debugfs_create_file("cmd_rx_win", 0400, host->debugfs_root, mmc,
+				&mmc_cmd_rx_win_fops);
+		debugfs_create_file("write_size", 0400, host->debugfs_root, mmc,
+				&fops_write_size);
+		debugfs_create_file("erase_count", 0400, host->debugfs_root,
+				mmc, &erase_count_fops);
+	}
+#endif
+
+	host->blk_test = devm_kzalloc(host->dev, 512 * CALI_BLK_CNT, GFP_KERNEL);
+
+	if (!host->blk_test) {
+		ret = -ENOMEM;
+		goto err_bounce_buf;
+	}
+
+	dev_dbg(host->dev, "host probe success!\n");
+	return 0;
+
+err_bounce_buf:
+	if (!host->dram_access_quirk)
+		dma_free_coherent(host->dev, host->bounce_buf_size,
+				  host->bounce_buf, host->bounce_dma_addr);
+err_free_irq:
+	devm_kfree(host->dev, host->adj_win);
+	free_irq(host->irq, host);
+err_init_clk:
+	clk_disable_unprepare(host->mmc_clk);
+err_core_clk:
+	clk_disable_unprepare(host->core_clk);
+free_host:
+	dev_notice(host->dev, "host probe failed!\n");
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int meson_mmc_remove(struct platform_device *pdev)
+{
+	struct meson_host *host = dev_get_drvdata(&pdev->dev);
+
+	mmc_remove_host(host->mmc);
+
+	/* disable interrupts */
+	writel(0, host->regs + SD_EMMC_IRQ_EN);
+	free_irq(host->irq, host);
+
+	dma_free_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,
+			  host->descs, host->descs_dma_addr);
+
+	if (!host->dram_access_quirk)
+		dma_free_coherent(host->dev, host->bounce_buf_size,
+				  host->bounce_buf, host->bounce_dma_addr);
+
+	clk_disable_unprepare(host->mmc_clk);
+	clk_disable_unprepare(host->core_clk);
+
+	devm_kfree(host->dev, host->adj_win);
+	mmc_free_host(host->mmc);
+	return 0;
+}
+
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+static const struct meson_mmc_data meson_gx_data = {
+	.tx_delay_mask	= CLK_V2_TX_DELAY_MASK,
+	.rx_delay_mask	= CLK_V2_RX_DELAY_MASK,
+	.always_on	= CLK_V2_ALWAYS_ON,
+	.adjust		= SD_EMMC_ADJUST,
+};
+#endif
+
+static const struct meson_mmc_data meson_axg_data = {
+	.tx_delay_mask	= CLK_V3_TX_DELAY_MASK,
+	.rx_delay_mask	= CLK_V3_RX_DELAY_MASK,
+	.always_on	= CLK_V3_ALWAYS_ON,
+	.adjust		= SD_EMMC_V3_ADJUST,
+};
+
+static const struct of_device_id meson_mmc_of_match[] = {
+#ifndef CONFIG_AMLOGIC_REMOVE_OLD
+	{ .compatible = "amlogic,meson-gx-mmc",		.data = &meson_gx_data },
+	{ .compatible = "amlogic,meson-gxbb-mmc",	.data = &meson_gx_data },
+	{ .compatible = "amlogic,meson-gxl-mmc",	.data = &meson_gx_data },
+	{ .compatible = "amlogic,meson-gxm-mmc",	.data = &meson_gx_data },
+#endif
+	{ .compatible = "amlogic,meson-axg-mmc",	.data = &meson_axg_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, meson_mmc_of_match);
+
+static struct platform_driver meson_mmc_driver = {
+	.probe		= meson_mmc_probe,
+	.remove		= meson_mmc_remove,
+	.driver		= {
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(meson_mmc_of_match),
+	},
+};
+
+static int caps2_setup(char *p)
+{
+	caps2_quirks = p;
+	return 0;
+}
+
+__setup("meson-gx-mmc.caps2_quirks=", caps2_setup);
+
+int __init meson_mmc_init(void)
+{
+	return platform_driver_register(&meson_mmc_driver);
+}
+
+void __exit meson_mmc_exit(void)
+{
+	platform_driver_unregister(&meson_mmc_driver);
+}
+
+//__module_param(caps2_quirks, charp, 0444);
+//MODULE_PARM_DESC(caps2_quirks, "Force certain caps2.");
+
+//MODULE_DESCRIPTION("Amlogic S905*/GX*/AXG SD/eMMC driver");
+//MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
+//MODULE_LICENSE("GPL v2");
diff --git a/drivers/amlogic/mmc/host/meson-mmc-main.c b/drivers/amlogic/mmc/host/meson-mmc-main.c
new file mode 100644
index 000000000..d283484e3
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-mmc-main.c
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/module.h>
+#include <linux/amlogic/module_merge.h>
+#include "meson-mmc-main.h"
+
+static int __init mmc_main_init(void)
+{
+	pr_debug("### %s() start\n", __func__);
+	call_sub_init(g12a_mmc_init);
+	call_sub_init(meson_mmc_init);
+	pr_debug("### %s() end\n", __func__);
+	return 0;
+}
+
+static void __exit mmc_main_exit(void)
+{
+	g12a_mmc_exit();
+	meson_mmc_exit();
+}
+
+module_init(mmc_main_init);
+module_exit(mmc_main_exit);
+
+MODULE_DESCRIPTION("Amlogic Meson SD/eMMC driver");
+MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/amlogic/mmc/host/meson-mmc-main.h b/drivers/amlogic/mmc/host/meson-mmc-main.h
new file mode 100644
index 000000000..5894b58f2
--- /dev/null
+++ b/drivers/amlogic/mmc/host/meson-mmc-main.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __MMC_MAIN_H_
+#define __MMC_MAIN_H_
+
+int g12a_mmc_init(void);
+void g12a_mmc_exit(void);
+
+int meson_mmc_init(void);
+void meson_mmc_exit(void);
+
+#endif /*_MMC_MAIN_H__*/
diff --git a/drivers/amlogic/mmc/host/mmc_common.h b/drivers/amlogic/mmc/host/mmc_common.h
new file mode 100644
index 000000000..606fea3b5
--- /dev/null
+++ b/drivers/amlogic/mmc/host/mmc_common.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _MMC_COMMON_H_
+#define _MMC_COMMON_H_
+
+int mmc_check_result(struct mmc_request *mrq);
+
+int mmc_transfer(struct mmc_card *card, unsigned int dev_addr,
+					unsigned int blocks, void *buf, int write);
+
+int mmc_read_internal(struct mmc_card *card, unsigned int dev_addr,
+						unsigned int blocks, void *buf);
+
+int mmc_write_internal(struct mmc_card *card, unsigned int dev_addr,
+						unsigned int blocks, void *buf);
+
+void mmc_prepare_mrq(struct mmc_card *card,
+						struct mmc_request *mrq, struct scatterlist *sg,
+						unsigned int sg_len, unsigned int dev_addr,
+						unsigned int blocks,
+						unsigned int blksz, int write);
+
+int get_reserve_partition_off_from_tbl(void);
+
+int aml_disable_mmc_cqe(struct mmc_card *card);
+
+int aml_enable_mmc_cqe(struct mmc_card *card);
+
+#endif
+
diff --git a/drivers/amlogic/mmc/host/mmc_dtb.c b/drivers/amlogic/mmc/host/mmc_dtb.c
new file mode 100644
index 000000000..b678179bd
--- /dev/null
+++ b/drivers/amlogic/mmc/host/mmc_dtb.c
@@ -0,0 +1,460 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+#include <linux/scatterlist.h>
+#include <linux/swap.h>		/* For nr_free_buffer_pages() */
+#include <linux/list.h>
+
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+#include <linux/module.h>
+
+#include "core.h"
+#include "card.h"
+#include "host.h"
+#include "bus.h"
+#include "mmc_ops.h"
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/blkdev.h>
+#include <linux/scatterlist.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#include <linux/amlogic/aml_sd.h>
+#include "mmc_common.h"
+
+static dev_t amlmmc_dtb_no;
+struct cdev amlmmc_dtb;
+struct device *dtb_dev;
+struct class *amlmmc_dtb_class;
+static char *glb_dtb_buf;
+struct mmc_card *card_dtb;
+struct aml_dtb_info {
+	unsigned int stamp[2];
+	u8 valid[2];
+};
+
+static struct aml_dtb_info dtb_infos = {{0, 0}, {0, 0} };
+struct mmc_partitions_fmt *pt_fmt;
+struct mmc_dtb {
+	struct mmc_card		*card;		/* the host this device belongs to */
+	struct device		dev;		/* the device */
+};
+
+#define stamp_after(a, b)	((int)(b) - (int)(a)  < 0)
+#define CONFIG_DTB_SIZE  (256 * 1024U)
+#define DTB_CELL_SIZE   (16 * 1024U)
+
+#define DTB_NAME		"dtb"
+#define	SZ_1M			0x00100000
+#define	MMC_DTB_PART_OFFSET	(40 * SZ_1M)
+#define	EMMC_BLOCK_SIZE		(0x100)
+#define	MAX_EMMC_BLOCK_SIZE	(128 * 1024)
+
+#define DTB_RESERVE_OFFSET	(4 * SZ_1M)
+#define	DTB_BLK_SIZE		(0x200)
+#define	DTB_BLK_CNT		(512)
+#define	DTB_SIZE		(DTB_BLK_CNT * DTB_BLK_SIZE)
+#define DTB_COPIES		(2)
+#define DTB_AREA_BLK_CNT	(DTB_BLK_CNT * DTB_COPIES)
+/* pertransfer for internal operations. */
+#define MAX_TRANS_BLK		(256)
+#define	MAX_TRANS_SIZE		(MAX_TRANS_BLK * DTB_BLK_SIZE)
+
+struct aml_dtb_rsv {
+	u8 data[DTB_BLK_SIZE * DTB_BLK_CNT - 4 * sizeof(unsigned int)];
+	unsigned int magic;
+	unsigned int version;
+	unsigned int timestamp;
+	unsigned int checksum;
+};
+
+static CLASS_ATTR_STRING(emmcdtb, 0644, NULL);
+
+int mmc_dtb_open(struct inode *node, struct file *file)
+{
+	return 0;
+}
+
+static int _dtb_write(struct mmc_card *mmc, int blk, unsigned char *buf)
+{
+	int ret = 0;
+	unsigned char *src = NULL;
+	int bit = mmc->csd.read_blkbits;
+	int cnt = CONFIG_DTB_SIZE >> bit;
+
+	src = (unsigned char *)buf;
+
+	mmc_claim_host(mmc->host);
+	do {
+		ret = mmc_write_internal(mmc, blk, MAX_TRANS_BLK, src);
+		if (ret) {
+			pr_err("%s: save dtb error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		src = (unsigned char *)buf + MAX_TRANS_SIZE;
+	} while (cnt != 0);
+	mmc_release_host(mmc->host);
+
+	return ret;
+}
+
+static unsigned int _calc_dtb_checksum(struct aml_dtb_rsv *dtb)
+{
+	int i = 0;
+	int size = sizeof(struct aml_dtb_rsv) - sizeof(unsigned int);
+	unsigned int *buffer;
+	unsigned int checksum = 0;
+
+	size = size >> 2;
+	buffer = (unsigned int *)dtb;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+static int _verify_dtb_checksum(struct aml_dtb_rsv *dtb)
+{
+	unsigned int checksum;
+
+	checksum = _calc_dtb_checksum(dtb);
+	pr_debug("calc %x, store %x\n", checksum, dtb->checksum);
+
+	return !(checksum == dtb->checksum);
+}
+
+int amlmmc_dtb_write(struct mmc_card *mmc, unsigned char *buf, int len)
+{
+	int ret = 0, blk;
+	int bit = mmc->csd.read_blkbits;
+	int cpy, valid;
+	struct aml_dtb_rsv *dtb = (struct aml_dtb_rsv *)buf;
+	struct aml_dtb_info *info = &dtb_infos;
+
+	if (len > CONFIG_DTB_SIZE) {
+		pr_err("%s dtb data len too much", __func__);
+		return -EFAULT;
+	}
+	/* set info */
+	valid = info->valid[0] + info->valid[1];
+	if (valid == 0) {
+		dtb->timestamp = 0;
+	} else if (valid == 1) {
+		dtb->timestamp = 1 + info->stamp[info->valid[0] ? 0 : 1];
+	} else {
+		/* both are valid */
+		if (info->stamp[0] != info->stamp[1]) {
+			pr_info("timestamp are not same %d:%d\n",
+				info->stamp[0], info->stamp[1]);
+			dtb->timestamp = 1 +
+				(stamp_after(info->stamp[1], info->stamp[0]) ?
+				info->stamp[1] : info->stamp[0]);
+		} else {
+			dtb->timestamp = 1 + info->stamp[0];
+		}
+	}
+	/*setting version and magic*/
+	dtb->version = 1; /* base version */
+	dtb->magic = 0x00447e41; /*A~D\0*/
+	dtb->checksum = _calc_dtb_checksum(dtb);
+	pr_info("stamp %d, checksum 0x%x, version %d, magic %s\n",
+		dtb->timestamp, dtb->checksum,
+		dtb->version, (char *)&dtb->magic);
+	/* write down... */
+	for (cpy = 0; cpy < DTB_COPIES; cpy++) {
+		blk = ((get_reserve_partition_off_from_tbl()
+					+ DTB_RESERVE_OFFSET) >> bit)
+			+ cpy * DTB_BLK_CNT;
+		ret |= _dtb_write(mmc, blk, buf);
+	}
+
+	return ret;
+}
+
+int amlmmc_dtb_read(struct mmc_card *card, unsigned char *buf, int len)
+{
+	int ret = 0, start_blk, size, blk_cnt;
+	int bit = card->csd.read_blkbits;
+	unsigned char *dst = NULL;
+	unsigned char *buffer = NULL;
+
+	if (len > CONFIG_DTB_SIZE) {
+		pr_err("%s dtb data len too much", __func__);
+		return -EFAULT;
+	}
+	memset(buf, 0x0, len);
+
+	start_blk = MMC_DTB_PART_OFFSET;
+	buffer = kmalloc(DTB_CELL_SIZE, GFP_KERNEL | __GFP_RECLAIM);
+	if (!buffer)
+		return -ENOMEM;
+
+	start_blk >>= bit;
+	size = CONFIG_DTB_SIZE;
+	blk_cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+	while (blk_cnt != 0) {
+		memset(buffer, 0x0, DTB_CELL_SIZE);
+		ret = mmc_read_internal(card, start_blk, (DTB_CELL_SIZE >> bit), dst);
+		if (ret) {
+			pr_err("%s read dtb error", __func__);
+			ret = -EFAULT;
+			kfree(buffer);
+			return ret;
+		}
+		start_blk += (DTB_CELL_SIZE >> bit);
+		blk_cnt -= (DTB_CELL_SIZE >> bit);
+		memcpy(buf, dst, DTB_CELL_SIZE);
+		buf += DTB_CELL_SIZE;
+	}
+	kfree(buffer);
+	return ret;
+}
+
+ssize_t mmc_dtb_read(struct file *file, char __user *buf,
+		     size_t count, loff_t *ppos)
+{
+	unsigned char *dtb_ptr = NULL;
+	ssize_t read_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		pr_err("%s: out of space!", __func__);
+		return -EFAULT;
+	}
+
+	dtb_ptr = glb_dtb_buf;
+	if (!dtb_ptr)
+		return -ENOMEM;
+
+	mmc_claim_host(card_dtb->host);
+	aml_disable_mmc_cqe(card_dtb);
+	ret = amlmmc_dtb_read(card_dtb, (unsigned char *)dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		pr_err("%s: read failed:%d", __func__, ret);
+		ret = -EFAULT;
+		goto exit;
+	}
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		read_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		read_size = count;
+	ret = copy_to_user(buf, (dtb_ptr + *ppos), read_size);
+	*ppos += read_size;
+
+exit:
+	aml_enable_mmc_cqe(card_dtb);
+	mmc_release_host(card_dtb->host);
+	return read_size;
+}
+
+ssize_t mmc_dtb_write(struct file *file,
+			const char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned char *dtb_ptr = NULL;
+	ssize_t write_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		pr_err("%s: out of space!", __func__);
+		return -EFAULT;
+	}
+	dtb_ptr = glb_dtb_buf;
+	if (!dtb_ptr)
+		return -ENOMEM;
+
+	mmc_claim_host(card_dtb->host);
+	aml_disable_mmc_cqe(card_dtb);
+
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		write_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		write_size = count;
+
+	ret = copy_from_user((dtb_ptr + *ppos), buf, write_size);
+
+	ret = amlmmc_dtb_write(card_dtb,
+			       dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		pr_err("%s: write dtb failed", __func__);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	*ppos += write_size;
+exit:
+	aml_enable_mmc_cqe(card_dtb);
+	mmc_release_host(card_dtb->host);
+	return write_size;
+}
+
+long mmc_dtb_ioctl(struct file *file, unsigned int cmd, unsigned long args)
+{
+	return 0;
+}
+
+static const struct file_operations dtb_ops = {
+	.open = mmc_dtb_open,
+	.read = mmc_dtb_read,
+	.write = mmc_dtb_write,
+	.unlocked_ioctl = mmc_dtb_ioctl,
+};
+
+int get_reserve_partition_off_from_tbl(void)
+{
+	return 0x2400000;
+}
+
+static int _dtb_read(struct mmc_card *mmc, int blk, unsigned char *buf)
+{
+	int ret = 0;
+	unsigned char *dst = NULL;
+	int bit = mmc->csd.read_blkbits;
+	int cnt = CONFIG_DTB_SIZE >> bit;
+
+	dst = (unsigned char *)buf;
+	mmc_claim_host(mmc->host);
+	aml_disable_mmc_cqe(mmc);
+	do {
+		ret = mmc_read_internal(mmc, blk, MAX_TRANS_BLK, dst);
+		if (ret) {
+			pr_err("%s: save dtb error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		dst = (unsigned char *)buf + MAX_TRANS_SIZE;
+	} while (cnt != 0);
+	aml_enable_mmc_cqe(mmc);
+	mmc_release_host(mmc->host);
+	return ret;
+}
+
+static int _dtb_init(struct mmc_card *mmc)
+{
+	int ret = 0;
+	struct aml_dtb_rsv *dtb;
+	struct aml_dtb_info *info = &dtb_infos;
+	int cpy = 1, valid = 0;
+	int bit = mmc->csd.read_blkbits;
+	int blk;
+
+	if (!glb_dtb_buf) {
+		glb_dtb_buf = kmalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+		if (!glb_dtb_buf)
+			return -ENOMEM;
+	}
+	dtb = (struct aml_dtb_rsv *)glb_dtb_buf;
+
+	/* read dtb2 1st, for compatibility without checksum. */
+	while (cpy >= 0) {
+		blk = ((get_reserve_partition_off_from_tbl()
+				+ DTB_RESERVE_OFFSET) >> bit)
+				+ cpy * DTB_BLK_CNT;
+		if (_dtb_read(mmc, blk, (unsigned char *)dtb)) {
+			pr_err("%s: block # %#x ERROR!\n", __func__, blk);
+		} else {
+			ret = _verify_dtb_checksum(dtb);
+			if (!ret) {
+				info->stamp[cpy] = dtb->timestamp;
+				info->valid[cpy] = 1;
+			} else {
+				pr_debug("cpy %d is not valid\n", cpy);
+			}
+		}
+		valid += info->valid[cpy];
+		cpy--;
+	}
+	pr_debug("total valid %d\n", valid);
+
+	return ret;
+}
+
+void amlmmc_dtb_init(struct mmc_card *card, int *retp)
+{
+	*retp = 0;
+	mmc_claim_host(card->host);
+
+	card_dtb = card;
+	pr_debug("%s: register dtb chardev", __func__);
+
+	_dtb_init(card);
+
+	*retp = alloc_chrdev_region(&amlmmc_dtb_no, 0, 1, DTB_NAME);
+	if (*retp < 0) {
+		pr_err("alloc dtb dev_t no failed");
+		*retp = -1;
+		goto exit;
+	}
+
+	cdev_init(&amlmmc_dtb, &dtb_ops);
+	amlmmc_dtb.owner = THIS_MODULE;
+	*retp = cdev_add(&amlmmc_dtb, amlmmc_dtb_no, 1);
+	if (*retp) {
+		pr_err("dtb dev add failed");
+		*retp = -1;
+		goto exit_err1;
+	}
+
+	amlmmc_dtb_class = class_create(DTB_NAME);
+	if (IS_ERR(amlmmc_dtb_class)) {
+		pr_err("dtb dev add failed");
+		*retp = -1;
+		goto exit_err2;
+	}
+
+	*retp = class_create_file(amlmmc_dtb_class, &class_attr_emmcdtb.attr);
+	if (*retp) {
+		pr_err("dtb dev add failed");
+		*retp = -1;
+		goto exit_err2;
+	}
+
+	dtb_dev = device_create(amlmmc_dtb_class, NULL, amlmmc_dtb_no, NULL, DTB_NAME);
+	if (IS_ERR(dtb_dev)) {
+		pr_err("dtb dev add failed");
+		*retp = -1;
+		goto exit_err3;
+	}
+
+	pr_info("%s: register dtb chardev OK", __func__);
+	goto exit;
+
+exit_err3:
+	class_remove_file(amlmmc_dtb_class, &class_attr_emmcdtb.attr);
+	class_destroy(amlmmc_dtb_class);
+exit_err2:
+	cdev_del(&amlmmc_dtb);
+exit_err1:
+	unregister_chrdev_region(amlmmc_dtb_no, 1);
+exit:
+	mmc_release_host(card->host);
+}
+
diff --git a/drivers/amlogic/mmc/host/mmc_dtb.h b/drivers/amlogic/mmc/host/mmc_dtb.h
new file mode 100644
index 000000000..5d6c7eb04
--- /dev/null
+++ b/drivers/amlogic/mmc/host/mmc_dtb.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _MMC_DTB_H_
+#define _MMC_DTB_H_
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+
+void amlmmc_dtb_init(struct mmc_card *card_dtbkey, int *retp);
+
+#endif
diff --git a/drivers/amlogic/mmc/host/mmc_key.c b/drivers/amlogic/mmc/host/mmc_key.c
new file mode 100644
index 000000000..db0eeb34a
--- /dev/null
+++ b/drivers/amlogic/mmc/host/mmc_key.c
@@ -0,0 +1,572 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+
+#include <linux/scatterlist.h>
+#include <linux/swap.h>         /* For nr_free_buffer_pages() */
+#include <linux/list.h>
+
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/seq_file.h>
+#include <linux/module.h>
+
+#include "mmc_key.h"
+#include "core.h"
+#include "card.h"
+#include "host.h"
+#include "bus.h"
+#include "mmc_ops.h"
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/blkdev.h>
+#include <linux/scatterlist.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#include <linux/amlogic/key_manage.h>
+#include <linux/amlogic/aml_sd.h>
+#include "mmc_common.h"
+
+struct task_struct      *thread_dtb_key_task;
+unsigned int    key_stamp;
+#define		EMMC_BLOCK_SIZE		(0x100)
+#define		MAX_EMMC_BLOCK_SIZE	(128 * 1024)
+
+#define     MAX_TRANS_BLK        (256)
+
+#define stamp_after(a, b)	((int)(b) - (int)(a)  < 0)
+#define KEY_BACKUP
+
+/*
+ * kernel head file
+ *
+ */
+static struct mmc_card *mmc_card_key;
+static struct aml_emmckey_info_t *emmckey_info;
+#ifdef KEY_BACKUP
+static struct aml_key_info key_infos[2] = { {0, 0, 0}, {0, 0, 0} };
+
+/* key read&write operation with backup updates */
+static u64 _calc_key_checksum(void *addr, int size)
+{
+	int i = 0;
+	u32 *buffer;
+	u64 checksum = 0;
+
+	buffer = (u32 *)addr;
+	size = size >> 2;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+static int _verify_key_checksum(struct mmc_card *mmc, void *addr, int cpy)
+{
+	u64 checksum;
+	int ret = 0;
+	u64 blk;
+	char *checksum_info;
+	int bit = mmc->csd.read_blkbits;
+
+	blk = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET +
+		EMMC_KEYAREA_SIZE * 2;
+	blk = (blk >> bit) + cpy;
+	checksum_info = kmalloc(512, GFP_KERNEL);
+	if (!checksum_info)
+		return -1;
+
+	mmc_claim_host(mmc->host);
+	aml_disable_mmc_cqe(mmc);
+	ret =  mmc_read_internal(mmc, blk, 1, checksum_info);
+	aml_enable_mmc_cqe(mmc);
+	mmc_release_host(mmc->host);
+	if (ret) {
+		pr_err("%s, block # %#llx, ERROR!\n", __func__, blk);
+		kfree(checksum_info);
+		return ret;
+	}
+
+	memcpy(&key_infos[cpy], checksum_info, sizeof(struct aml_key_info));
+	checksum = _calc_key_checksum(addr, EMMC_KEYAREA_SIZE);
+	pr_debug("calc %llx, store %llx\n", checksum, key_infos[cpy].checksum);
+
+	kfree(checksum_info);
+	return !(checksum == key_infos[cpy].checksum);
+}
+
+static int _amlmmc_read(struct mmc_card *mmc,
+		     int blk, unsigned char *buf, int cnt)
+{
+	int ret = 0;
+	unsigned char *dst = NULL;
+
+	dst = (unsigned char *)buf;
+	mmc_claim_host(mmc->host);
+	aml_disable_mmc_cqe(mmc);
+	do {
+		ret = mmc_read_internal(mmc, blk, MAX_TRANS_BLK, dst);
+		if (ret) {
+			pr_err("%s: save key error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		dst = (unsigned char *)buf + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	aml_enable_mmc_cqe(mmc);
+	mmc_release_host(mmc->host);
+	return ret;
+}
+
+static int update_key_info(struct mmc_card *mmc, unsigned char *addr)
+{
+	int ret = 0;
+	int cpy = 1;
+	int bit = mmc->csd.read_blkbits;
+	int blk;
+	int cnt = EMMC_KEYAREA_SIZE >> bit;
+	int valid_flag = 0;
+
+	/* read key2 1st, for compatibility without checksum. */
+	while (cpy >= 0) {
+		blk = ((get_reserve_partition_off_from_tbl()
+					+ EMMCKEY_RESERVE_OFFSET)
+			+ cpy * EMMC_KEYAREA_SIZE) >> bit;
+		if (_amlmmc_read(mmc, blk, addr, cnt)) {
+			pr_err("%s: block # %#x ERROR!\n",
+					__func__, blk);
+		} else {
+			ret = _verify_key_checksum(mmc, addr, cpy);
+			if (!ret && key_infos[cpy].magic != 0)
+				valid_flag += cpy + 1;
+			else
+				pr_debug("cpy %d is not valid\n", cpy);
+		}
+		cpy--;
+	}
+
+	if (key_infos[0].stamp > key_infos[1].stamp)
+		key_stamp = key_infos[0].stamp;
+	else
+		key_stamp = key_infos[1].stamp;
+
+	return valid_flag;
+}
+
+int32_t emmc_write_one_key(void *buffer, int valid_flag)
+{
+	int ret;
+	u64 blk, cnt, key_glb_offset;
+	unsigned char *src = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+	unsigned char *checksum_info;
+
+	checksum_info = kmalloc(512, GFP_KERNEL);
+	if (!checksum_info)
+		return -1;
+
+	memset(checksum_info, 0, 512);
+	key_glb_offset = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = (key_glb_offset + (valid_flag % 2) * EMMC_KEYAREA_SIZE) >> bit;
+	cnt = EMMC_KEYAREA_SIZE >> bit;
+	src = (unsigned char *)buffer;
+	memcpy(checksum_info, &key_infos[valid_flag - 1], sizeof(struct aml_key_info));
+	mmc_claim_host(card->host);
+	aml_disable_mmc_cqe(card);
+	do {
+		ret = mmc_write_internal(card, blk, EMMC_BLOCK_SIZE, src);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+				__func__, __LINE__);
+			goto exit_err;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		src = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+		pr_info("cnt %llu\n", cnt);
+	} while (cnt != 0);
+
+	blk = ((key_glb_offset + 2 * (EMMC_KEYAREA_SIZE)) >> bit) + (valid_flag % 2);
+	ret = mmc_write_internal(card, blk, 1, checksum_info);
+	if (ret)
+		pr_err("%s: block # %#llx, ERROR!\n", __func__, blk);
+
+	pr_info("%s:%d, write %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	aml_enable_mmc_cqe(card);
+	mmc_release_host(card->host);
+
+exit_err:
+		kfree(checksum_info);
+		return ret;
+}
+
+int32_t emmc_read_valid_key(void *buffer, int valid_flag)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *dst = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = EMMC_KEYAREA_SIZE;
+
+	/*
+	 * The lib functions don't need to be modified.
+	 */
+	/* coverity[overflow_before_widen:SUPPRESS] */
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET
+			+ (valid_flag - 1) * EMMC_KEYAREA_SIZE;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+
+	mmc_claim_host(card->host);
+	aml_disable_mmc_cqe(card);
+	do {
+		ret = mmc_read_internal(card, blk, EMMC_BLOCK_SIZE, dst);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+					__func__, __LINE__);
+			break;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		dst = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	pr_info("%s:%d, read %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	aml_enable_mmc_cqe(card);
+	mmc_release_host(card->host);
+
+	return ret;
+}
+#endif
+
+#ifdef KEY_BACKUP
+int32_t emmc_key_write(u8 *buffer,
+	u32 length, u32 *actual_length)
+{
+	int ret;
+	int cpy = 1, index;
+	//struct mmc_card *card = mmc_card_key;
+
+	do {
+		index = cpy - 1;
+		key_infos[index].stamp = key_stamp + 1;
+		key_infos[index].checksum = _calc_key_checksum(buffer, length);
+		key_infos[index].magic = 9;
+		pr_info("new stamp %d, checksum 0x%llx, magic %d\n",
+				key_infos[index].stamp,
+				key_infos[index].checksum,
+				key_infos[index].magic);
+
+		ret = emmc_write_one_key(buffer, cpy);
+		if (ret) {
+			pr_info("write %d failed\n", cpy);
+			return ret;
+		}
+		cpy++;
+	} while (cpy < 3);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_write);
+#else
+int32_t emmc_key_write(u8 *buffer, u32 length, u32 *actual_length)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *src = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = length;
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	src = (unsigned char *)buffer;
+	mmc_claim_host(card->host);
+	aml_disable_mmc_cqe(card);
+	do {
+		ret = mmc_write_internal(card, blk, EMMC_BLOCK_SIZE, src);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n", __func__, __LINE__);
+			return ret;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		src = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	pr_info("%s:%d, write %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	aml_enable_mmc_cqe(card);
+	mmc_release_host(card->host);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_write);
+#endif
+
+static int write_invalid_key(void *addr, int valid_flag)
+{
+	int ret;
+
+	if (valid_flag > 2 || valid_flag < 1)
+		return -1;
+
+	ret = emmc_read_valid_key(addr, valid_flag);
+	if (ret) {
+		pr_err("read valid key failed\n");
+		return ret;
+	}
+	ret = emmc_write_one_key(addr, valid_flag);
+	if (ret) {
+		pr_err("write invalid key failed\n");
+		return ret;
+	}
+	return ret;
+}
+
+int update_old_key(struct mmc_card *mmc, void *addr)
+{
+	int ret = 0;
+	int valid_flag;
+
+	if (stamp_after(key_infos[1].stamp, key_infos[0].stamp)) {
+		memcpy(&key_infos[1], &key_infos[0], sizeof(struct aml_key_info));
+		valid_flag = 2;
+	} else if (stamp_after(key_infos[0].stamp, key_infos[1].stamp)) {
+		memcpy(&key_infos[0], &key_infos[1], sizeof(struct aml_key_info));
+		valid_flag = 1;
+	} else {
+		pr_debug("do nothing\n");
+		return ret;
+	}
+
+	ret = emmc_write_one_key(addr, valid_flag);
+	if (ret)
+		return ret;
+	key_stamp = key_infos[0].stamp;
+	return ret;
+}
+
+static int _key_init(struct mmc_card *mmc)
+{
+	int ret = 0;
+	void *key;
+	int valid = 0;
+
+	/*malloc 256k byte to key */
+	key = kmalloc(EMMC_KEYAREA_SIZE, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	valid = update_key_info(mmc, key);
+
+	switch (valid) {
+	case 0:
+	break;
+	case 1:
+		write_invalid_key(key, 1);
+	break;
+	case 2:
+		write_invalid_key(key, 2);
+	break;
+	case 3:
+		update_old_key(mmc, key);
+	break;
+	default:
+		pr_err("impossible valid values.\n");
+	break;
+	}
+
+	kfree(key);
+	return ret;
+}
+
+static int aml_emmc_key_check(void)
+{
+	u8 keypart_cnt;
+	u64 part_size;
+	struct emmckey_valid_node_t *emmckey_valid_node, *temp_valid_node;
+
+	emmckey_info->key_part_count =
+		emmckey_info->keyarea_phy_size / EMMC_KEYAREA_SIZE;
+
+	if (emmckey_info->key_part_count
+			> EMMC_KEYAREA_COUNT) {
+		emmckey_info->key_part_count = EMMC_KEYAREA_COUNT;
+	}
+	keypart_cnt = 0;
+	part_size = EMMC_KEYAREA_SIZE;
+	do {
+		emmckey_valid_node = kmalloc(sizeof(*emmckey_valid_node),
+				GFP_KERNEL);
+
+		if (!emmckey_valid_node) {
+			pr_info("%s:%d,kmalloc memory fail\n",
+				__func__, __LINE__);
+			return -ENOMEM;
+		}
+		emmckey_valid_node->phy_addr = emmckey_info->keyarea_phy_addr
+						+ part_size * keypart_cnt;
+		emmckey_valid_node->phy_size = EMMC_KEYAREA_SIZE;
+		emmckey_valid_node->next = NULL;
+		emmckey_info->key_valid = 0;
+		if (!emmckey_info->key_valid_node) {
+			emmckey_info->key_valid_node = emmckey_valid_node;
+
+		} else {
+			temp_valid_node = emmckey_info->key_valid_node;
+
+			while (temp_valid_node->next)
+				temp_valid_node = temp_valid_node->next;
+
+			temp_valid_node->next = emmckey_valid_node;
+		}
+	} while (++keypart_cnt < emmckey_info->key_part_count);
+
+	emmckey_info->key_valid = 1;
+	return 0;
+}
+
+void emmc_key_init(struct mmc_card *card, int *retp)
+{
+	u64  addr = 0;
+	u32  size = 0;
+	u64  lba_start = 0, lba_end = 0;
+	int bit = 0;
+	struct unifykey_type *uk_type = NULL;
+	struct unifykey_storage_ops ops;
+
+	mmc_claim_host(card->host);
+	bit = card->csd.read_blkbits;
+	pr_debug("card key: card_blk_probe.\n");
+	emmckey_info = kmalloc(sizeof(*emmckey_info), GFP_KERNEL);
+	if (!emmckey_info) {
+		pr_info("%s:%d,kmalloc memory fail\n", __func__, __LINE__);
+		*retp = -ENOMEM;
+		goto exit;
+	}
+	uk_type = kmalloc(sizeof(*uk_type), GFP_KERNEL);
+	if (!uk_type) {
+		*retp = -ENOMEM;
+		goto exit_err;
+	}
+	memset(emmckey_info, 0, sizeof(*emmckey_info));
+	emmckey_info->key_init = 0;
+#ifdef KEY_BACKUP
+	size = EMMCKEY_AREA_PHY_SIZE + (512 * 2);
+#else
+	size = EMMCKEY_AREA_PHY_SIZE;
+#endif
+	if (get_reserve_partition_off_from_tbl() < 0) {
+		*retp = -EINVAL;
+		goto exit_err1;
+	}
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	lba_start = addr >> bit;
+	lba_end = (addr + size) >> bit;
+	emmckey_info->key_init = 1;
+
+	pr_debug("%s:%d emmc key lba_start:0x%llx,lba_end:0x%llx\n",
+			__func__, __LINE__, lba_start, lba_end);
+
+	if (!emmckey_info->key_init) {
+		*retp = -EINVAL;
+
+		pr_info("%s:%d,emmc key init fail\n", __func__, __LINE__);
+		goto exit_err1;
+	}
+	emmckey_info->keyarea_phy_addr = addr;
+	emmckey_info->keyarea_phy_size = size;
+	emmckey_info->lba_start = lba_start;
+	emmckey_info->lba_end   = lba_end;
+	mmc_card_key = card;
+#ifdef KEY_BACKUP
+	_key_init(card);
+#endif
+	*retp = aml_emmc_key_check();
+	if (*retp) {
+		pr_info("%s:%d,emmc key check fail\n", __func__, __LINE__);
+		goto exit_err1;
+	}
+
+	uk_type->storage_type = UNIFYKEY_STORAGE_TYPE_EMMC;
+	uk_type->ops = &ops;
+	uk_type->ops->read = emmc_key_read;
+	uk_type->ops->write = emmc_key_write;
+
+	// if (register_unifykey_types(uk_type)) {
+	// 	*retp = -EINVAL;
+	// 	pr_info("%s:%d,emmc key check fail\n", __func__, __LINE__);
+	// 	goto exit_err1;
+	// }
+	// pr_info("emmc key: %s:%d ok.\n", __func__, __LINE__);
+
+	// auto_attach();
+
+exit_err1:
+		kfree(uk_type);
+exit_err:
+		kfree(emmckey_info);
+exit:
+		mmc_release_host(card->host);
+}
+
+int32_t emmc_key_read(u8 *buffer,
+	u32 length, u32 *actual_length)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *dst = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = length;
+	*actual_length = length;
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+	mmc_claim_host(card->host);
+	aml_disable_mmc_cqe(card);
+	do {
+		ret = mmc_read_internal(card, blk,
+					min(EMMC_BLOCK_SIZE, cnt), dst);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+			       __func__, __LINE__);
+			break;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		dst = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt > 0);
+
+	pr_info("%s:%d, read %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+
+	aml_enable_mmc_cqe(card);
+	mmc_release_host(card->host);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_read);
+
diff --git a/drivers/amlogic/mmc/host/mmc_key.h b/drivers/amlogic/mmc/host/mmc_key.h
new file mode 100644
index 000000000..33d7c7329
--- /dev/null
+++ b/drivers/amlogic/mmc/host/mmc_key.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _MMC_KEY_H_
+#define _MMC_KEY_H_
+
+#include <linux/mmc/core.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+
+#define EMMC_KEY_AREA_SIGNAL		"emmckeys"
+#define EMMC_KEY_AREA_SIGNAL_LEN	16
+
+#define EMMC_KEYAREA_SIZE		(256 * 1024)
+#define EMMC_KEYAREA_COUNT		2
+
+/* we store partition table in the previous 16KB space */
+#define EMMCKEY_RESERVE_OFFSET          0x4000
+#define EMMCKEY_AREA_PHY_SIZE           (EMMC_KEYAREA_COUNT * EMMC_KEYAREA_SIZE)
+struct emmckey_valid_node_t {
+	u64 phy_addr;
+	u64 phy_size;
+	struct emmckey_valid_node_t *next;
+};
+
+struct aml_emmckey_info_t {
+	/* struct memory_card *card; */
+	struct	emmckey_valid_node_t *key_valid_node;
+	u64	keyarea_phy_addr;
+	u64	keyarea_phy_size;
+	u64	lba_start;
+	u64	lba_end;
+	u32	blk_size;
+	u32	blk_shift;
+	u8	key_init;
+	u8	key_valid;
+	u8	key_part_count;
+};
+
+struct aml_key_info {
+	u64 checksum;
+	u32 stamp;
+	u32 magic;
+};
+
+#define EMMCKEY_DATA_VALID_LEN		\
+	(EMMC_KEYAREA_SIZE - EMMC_KEY_AREA_SIGNAL_LEN - 4 - 4 - 4)
+
+struct emmckey_data_t {
+	u8	keyarea_mark[EMMC_KEY_AREA_SIGNAL_LEN];
+	u32	keyarea_mark_checksum;
+	u32	checksum;
+	u32	reserve;
+	u8	data[EMMCKEY_DATA_VALID_LEN];
+};
+
+int32_t emmc_key_read(u8 *buffer,
+		      u32 length, u32 *actual_length);
+int32_t emmc_key_write(u8 *buffer,
+		       u32 length, u32 *actual_length);
+
+void register_key_dtb(void);
+
+void emmc_key_init(struct mmc_card *card, int *retp);
+
+extern struct task_struct      *thread_dtb_key_task;
+
+#endif
+
diff --git a/drivers/amlogic/wifi/Kconfig b/drivers/amlogic/wifi/Kconfig
new file mode 100644
index 000000000..b1695b5ac
--- /dev/null
+++ b/drivers/amlogic/wifi/Kconfig
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+menuconfig AMLOGIC_WIFI
+	bool "WiFi support"
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	default y
+	help
+		select y to support wifi
+
+if AMLOGIC_WIFI
+
+config AMLOGIC_PWM_32K
+	bool "amlogic soc pwm 32k support"
+	depends on AMLOGIC_PWM_MESON
+	default n
+	help
+		WiFi usually needs a 32K frequency clock signal.
+		There are three possibilities:
+		using the internal 32K clock or using the 32K input from our SOC,
+		or using the onboard active 32K crystal oscillator.
+		By default,32K of SOC input is enabled,
+		if not, you can disable it by selecting n.
+
+endif
diff --git a/drivers/amlogic/wifi/Makefile b/drivers/amlogic/wifi/Makefile
new file mode 100644
index 000000000..025a5f82f
--- /dev/null
+++ b/drivers/amlogic/wifi/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+MODULE_NAME = aml_wifi
+
+ccflags-y += -I$(srctree)/drivers/gpio
+
+obj-y = $(MODULE_NAME).o
+$(MODULE_NAME)-y += wifi_dt.o dhd_static_buf.o
diff --git a/drivers/amlogic/wifi/dhd_static_buf.c b/drivers/amlogic/wifi/dhd_static_buf.c
new file mode 100644
index 000000000..fa3676693
--- /dev/null
+++ b/drivers/amlogic/wifi/dhd_static_buf.c
@@ -0,0 +1,659 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/skbuff.h>
+#include <linux/amlogic/wlan_plat.h>
+#include <linux/amlogic/dhd_buf.h>
+
+#define	DHD_STATIC_VERSION_STR		"101.10.361.31 (wlan=r892223-20230427-1)"
+#define STATIC_ERROR_LEVEL	BIT(0)
+#define STATIC_TRACE_LEVEL	BIT(1)
+#define STATIC_MSG_LEVEL	BIT(0)
+uint static_msg_level = STATIC_ERROR_LEVEL | STATIC_MSG_LEVEL;
+
+#define DHD_STATIC_MSG(x, args...) \
+do { \
+	if (static_msg_level & STATIC_MSG_LEVEL) { \
+		pr_err("[dhd] STATIC-MSG) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+#define DHD_STATIC_ERROR(x, args...) \
+do { \
+	if (static_msg_level & STATIC_ERROR_LEVEL) { \
+		pr_err("[dhd] STATIC-ERROR) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+#define DHD_STATIC_TRACE(x, args...) \
+do { \
+	if (static_msg_level & STATIC_TRACE_LEVEL) { \
+		pr_err("[dhd] STATIC-TRACE) %s : " x, __func__, ## args); \
+	} \
+} while (0)
+
+#ifndef DHD_STATIC_IN_DRIVER
+#ifndef BCMSDIO
+#define BCMSDIO
+#endif
+#ifndef BCMPCIE
+#define BCMPCIE
+#endif
+#ifndef BCMDBUS
+#define BCMDBUS
+#endif
+#ifndef DHD_USE_STATIC_MEMDUMP
+#define DHD_USE_STATIC_MEMDUMP { : = y}
+#endif
+//#define BCMDHD_UNUSE_MEM
+#endif
+
+#ifndef MAX_NUM_ADAPTERS
+#define MAX_NUM_ADAPTERS	1
+#endif
+
+enum dhd_prealloc_index {
+	DHD_PREALLOC_PROT = 0,
+#if defined(BCMSDIO)
+	DHD_PREALLOC_RXBUF = 1,
+	DHD_PREALLOC_DATABUF = 2,
+#endif /* BCMSDIO */
+	DHD_PREALLOC_OSL_BUF = 3,
+	DHD_PREALLOC_SKB_BUF = 4,
+	DHD_PREALLOC_WIPHY_ESCAN0 = 5,
+	DHD_PREALLOC_WIPHY_ESCAN1 = 6,
+	DHD_PREALLOC_DHD_INFO = 7,
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	DHD_PREALLOC_DHD_WLFC_INFO = 8,
+#endif /* BCMSDIO | BCMDBUS */
+#ifdef BCMPCIE
+	DHD_PREALLOC_IF_FLOW_LKUP = 9,
+#endif /* BCMPCIE */
+	DHD_PREALLOC_MEMDUMP_BUF = 10,
+#if defined(DHD_USE_STATIC_MEMDUMP) || defined(BCMDBUS)
+	DHD_PREALLOC_MEMDUMP_RAM = 11,
+#endif /* DHD_USE_STATIC_MEMDUMP | BCMDBUS */
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	DHD_PREALLOC_DHD_WLFC_HANGER = 12,
+#endif /* BCMSDIO | BCMDBUS */
+	DHD_PREALLOC_PKTID_MAP = 13,
+	DHD_PREALLOC_PKTID_MAP_IOCTL = 14,
+#ifdef DHD_USE_STATIC_MEMDUMP
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF = 15,
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX = 16,
+#endif /* DHD_USE_STATIC_MEMDUMP */
+	DHD_PREALLOC_DHD_PKTLOG_DUMP_BUF = 17,
+	DHD_PREALLOC_STAT_REPORT_BUF = 18,
+	DHD_PREALLOC_WL_ESCAN = 19,
+	DHD_PREALLOC_FW_VERBOSE_RING = 20,
+	DHD_PREALLOC_FW_EVENT_RING = 21,
+	DHD_PREALLOC_DHD_EVENT_RING = 22,
+#if defined(BCMDHD_UNUSE_MEM)
+	DHD_PREALLOC_NAN_EVENT_RING = 23,
+#endif /* BCMDHD_UNUSE_MEM */
+	DHD_PREALLOC_MAX
+};
+
+#define STATIC_BUF_MAX_NUM	20
+#define STATIC_BUF_SIZE	(PAGE_SIZE * 2)
+
+#ifndef CUSTOM_LOG_DUMP_BUFSIZE_MB
+/* DHD_LOG_DUMP_BUF_SIZE 4 MB static memory in kernel */
+#define CUSTOM_LOG_DUMP_BUFSIZE_MB	4
+#endif /* CUSTOM_LOG_DUMP_BUFSIZE_MB */
+
+#define DHD_PREALLOC_PROT_SIZE	(16 * 1024)
+#define DHD_PREALLOC_RXBUF_SIZE	(24 * 1024)
+#define DHD_PREALLOC_DATABUF_SIZE	(64 * 1024)
+#define DHD_PREALLOC_OSL_BUF_SIZE	(STATIC_BUF_MAX_NUM * STATIC_BUF_SIZE)
+#define DHD_PREALLOC_WIPHY_ESCAN0_SIZE	(64 * 1024)
+#define DHD_PREALLOC_DHD_INFO_SIZE	(44 * 1024)
+#define DHD_PREALLOC_MEMDUMP_RAM_SIZE	(1290 * 1024)
+#define DHD_PREALLOC_DHD_WLFC_HANGER_SIZE	(73 * 1024)
+#ifdef DHD_USE_STATIC_MEMDUMP
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE \
+	(1024 * 1024 * CUSTOM_LOG_DUMP_BUFSIZE_MB)
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE (8 * 1024)
+#endif /* DHD_USE_STATIC_MEMDUMP */
+#define DHD_PREALLOC_WL_ESCAN_SIZE	(70 * 1024)
+#ifdef CONFIG_64BIT
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024 * 2)
+#else
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif
+#define FW_VERBOSE_RING_SIZE		(256 * 1024)
+#define FW_EVENT_RING_SIZE		(64 * 1024)
+#define DHD_EVENT_RING_SIZE		(64 * 1024)
+#define NAN_EVENT_RING_SIZE		(64 * 1024)
+
+#if defined(CONFIG_64BIT)
+#define WLAN_DHD_INFO_BUF_SIZE	(24 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(64 * 1024)
+#else
+#define WLAN_DHD_INFO_BUF_SIZE	(16 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif /* CONFIG_64BIT */
+#define WLAN_DHD_MEMDUMP_SIZE	(800 * 1024)
+
+#define DHD_SKB_1PAGE_BUFSIZE	(PAGE_SIZE * 1)
+#define DHD_SKB_2PAGE_BUFSIZE	(PAGE_SIZE * 2)
+#define DHD_SKB_4PAGE_BUFSIZE	(PAGE_SIZE * 4)
+
+#ifdef BCMPCIE
+#define DHD_SKB_1PAGE_BUF_NUM	0
+#define DHD_SKB_2PAGE_BUF_NUM	192
+#elif defined(BCMSDIO)
+#define DHD_SKB_1PAGE_BUF_NUM	8
+#define DHD_SKB_2PAGE_BUF_NUM	8
+#endif /* BCMPCIE */
+#define DHD_SKB_4PAGE_BUF_NUM	1
+
+/* The number is defined in linux_osl.c
+ * WLAN_SKB_1_2PAGE_BUF_NUM => STATIC_PKT_1_2PAGE_NUM
+ * WLAN_SKB_BUF_NUM => STATIC_PKT_MAX_NUM
+ */
+#if defined(BCMSDIO) || defined(BCMPCIE)
+#define WLAN_SKB_1_2PAGE_BUF_NUM ((DHD_SKB_1PAGE_BUF_NUM) + \
+		(DHD_SKB_2PAGE_BUF_NUM))
+#define WLAN_SKB_BUF_NUM ((WLAN_SKB_1_2PAGE_BUF_NUM) + (DHD_SKB_4PAGE_BUF_NUM))
+#endif
+
+void *wlan_static_prot[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_rxbuf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_databuf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_osl_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_scan_buf0[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_scan_buf1[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_info_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_wlfc_info_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_if_flow_lkup[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_memdump_ram_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_wlfc_hanger_buf[MAX_NUM_ADAPTERS] = {};
+#ifdef DHD_USE_STATIC_MEMDUMP
+void *wlan_static_dhd_log_dump_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_log_dump_buf_ex[MAX_NUM_ADAPTERS] = {};
+#endif /* DHD_USE_STATIC_MEMDUMP */
+void *wlan_static_wl_escan_info_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_fw_verbose_ring_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_fw_event_ring_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_dhd_event_ring_buf[MAX_NUM_ADAPTERS] = {};
+void *wlan_static_nan_event_ring_buf[MAX_NUM_ADAPTERS] = {};
+
+#if defined(BCMSDIO) || defined(BCMPCIE)
+static struct sk_buff *wlan_static_skb[MAX_NUM_ADAPTERS][WLAN_SKB_BUF_NUM] = {};
+#endif /* BCMSDIO | BCMPCIE */
+
+#if defined(BCMDHD_MDRIVER) && !defined(DHD_STATIC_IN_DRIVER)
+void *bcmdhd_mem_prealloc(uint bus_type, int index, int section, unsigned long size)
+#else
+void *bcmdhd_mem_prealloc(int section, unsigned long size)
+#endif
+{
+#if !defined(BCMDHD_MDRIVER) || defined(DHD_STATIC_IN_DRIVER)
+	int index = 0;
+#endif
+
+#if defined(BCMDHD_MDRIVER) && !defined(DHD_STATIC_IN_DRIVER)
+	DHD_STATIC_MSG("bus_type %d, index %d, section %d, size %ld\n",
+		bus_type, index, section, size);
+#else
+	DHD_STATIC_MSG("section %d, size %ld\n", section, size);
+#endif
+
+	if (section == DHD_PREALLOC_PROT)
+		return wlan_static_prot[index];
+
+#if defined(BCMSDIO)
+	if (section == DHD_PREALLOC_RXBUF)
+		return wlan_static_rxbuf[index];
+
+	if (section == DHD_PREALLOC_DATABUF)
+		return wlan_static_databuf[index];
+#endif /* BCMSDIO */
+
+#if defined(BCMSDIO) || defined(BCMPCIE)
+	if (section == DHD_PREALLOC_SKB_BUF)
+		return wlan_static_skb[index];
+#endif /* BCMSDIO | BCMPCIE */
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN0)
+		return wlan_static_scan_buf0[index];
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN1)
+		return wlan_static_scan_buf1[index];
+
+	if (section == DHD_PREALLOC_OSL_BUF) {
+		if (size > DHD_PREALLOC_OSL_BUF_SIZE) {
+			DHD_STATIC_ERROR("request OSL_BUF(%lu) > %ld\n",
+				size, DHD_PREALLOC_OSL_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_osl_buf[index];
+	}
+
+	if (section == DHD_PREALLOC_DHD_INFO) {
+		if (size > DHD_PREALLOC_DHD_INFO_SIZE) {
+			DHD_STATIC_ERROR("request DHD_INFO(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_INFO_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_info_buf[index];
+	}
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	if (section == DHD_PREALLOC_DHD_WLFC_INFO) {
+		if (size > WLAN_DHD_WLFC_BUF_SIZE) {
+			DHD_STATIC_ERROR("request DHD_WLFC_INFO(%lu) > %d\n",
+				size, WLAN_DHD_WLFC_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_info_buf[index];
+	}
+#endif /* BCMSDIO | BCMDBUS */
+#ifdef BCMPCIE
+	if (section == DHD_PREALLOC_IF_FLOW_LKUP)  {
+		if (size > DHD_PREALLOC_IF_FLOW_LKUP_SIZE) {
+			DHD_STATIC_ERROR("request DHD_IF_FLOW_LKUP(%lu) > %d\n",
+				size, DHD_PREALLOC_IF_FLOW_LKUP_SIZE);
+			return NULL;
+		}
+		return wlan_static_if_flow_lkup[index];
+	}
+#endif /* BCMPCIE */
+#if defined(DHD_USE_STATIC_MEMDUMP) || defined(BCMDBUS)
+	if (section == DHD_PREALLOC_MEMDUMP_RAM) {
+		if (size > DHD_PREALLOC_MEMDUMP_RAM_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_MEMDUMP_RAM(%lu) > %d\n",
+				size, DHD_PREALLOC_MEMDUMP_RAM_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_memdump_ram_buf[index];
+	}
+#endif /* DHD_USE_STATIC_MEMDUMP | BCMDBUS */
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	if (section == DHD_PREALLOC_DHD_WLFC_HANGER) {
+		if (size > DHD_PREALLOC_DHD_WLFC_HANGER_SIZE) {
+			DHD_STATIC_ERROR("request DHD_WLFC_HANGER(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_hanger_buf[index];
+	}
+#endif /* BCMSDIO | BCMDBUS */
+#ifdef DHD_USE_STATIC_MEMDUMP
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_DHD_LOG_DUMP_BUF(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_log_dump_buf[index];
+	}
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_log_dump_buf_ex[index];
+	}
+#endif /* DHD_USE_STATIC_MEMDUMP */
+	if (section == DHD_PREALLOC_WL_ESCAN) {
+		if (size > DHD_PREALLOC_WL_ESCAN_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_WL_ESCAN(%lu) > %d\n",
+				size, DHD_PREALLOC_WL_ESCAN_SIZE);
+			return NULL;
+		}
+		return wlan_static_wl_escan_info_buf[index];
+	}
+	if (section == DHD_PREALLOC_FW_VERBOSE_RING) {
+		if (size > FW_VERBOSE_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_FW_VERBOSE_RING(%lu) > %d\n",
+				size, FW_VERBOSE_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_fw_verbose_ring_buf[index];
+	}
+	if (section == DHD_PREALLOC_FW_EVENT_RING) {
+		if (size > FW_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_FW_EVENT_RING(%lu) > %d\n",
+				size, FW_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_fw_event_ring_buf[index];
+	}
+	if (section == DHD_PREALLOC_DHD_EVENT_RING) {
+		if (size > DHD_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_DHD_EVENT_RING(%lu) > %d\n",
+				size, DHD_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_event_ring_buf[index];
+	}
+#if defined(BCMDHD_UNUSE_MEM)
+	if (section == DHD_PREALLOC_NAN_EVENT_RING) {
+		if (size > NAN_EVENT_RING_SIZE) {
+			DHD_STATIC_ERROR("request DHD_PREALLOC_NAN_EVENT_RING(%lu) > %d\n",
+				size, NAN_EVENT_RING_SIZE);
+			return NULL;
+		}
+		return wlan_static_nan_event_ring_buf[index];
+	}
+#endif /* BCMDHD_UNUSE_MEM */
+	if (section < 0 || section > DHD_PREALLOC_MAX)
+		DHD_STATIC_ERROR("request section id(%d) is out of max index %d\n",
+			section, DHD_PREALLOC_MAX);
+
+	DHD_STATIC_ERROR("failed to alloc section %d, size=%ld\n",
+		section, size);
+
+	return NULL;
+}
+
+#ifndef DHD_STATIC_IN_DRIVER
+EXPORT_SYMBOL(bcmdhd_mem_prealloc);
+#endif
+
+static void
+dhd_deinit_wlan_mem(int index)
+{
+#if defined(BCMSDIO) || defined(BCMPCIE)
+	int i;
+#endif /* BCMSDIO | BCMPCIE */
+
+	kfree(wlan_static_prot[index]);
+#if defined(BCMSDIO)
+	kfree(wlan_static_rxbuf[index]);
+	kfree(wlan_static_databuf[index]);
+#endif /* BCMSDIO */
+	kfree(wlan_static_osl_buf[index]);
+	kfree(wlan_static_scan_buf0[index]);
+	kfree(wlan_static_scan_buf1[index]);
+	kfree(wlan_static_dhd_info_buf[index]);
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	kfree(wlan_static_dhd_wlfc_info_buf[index]);
+#endif /* BCMSDIO | BCMDBUS */
+#ifdef BCMPCIE
+	kfree(wlan_static_if_flow_lkup[index]);
+#endif /* BCMPCIE */
+#if defined(DHD_USE_STATIC_MEMDUMP) || defined(BCMDBUS)
+	kfree(wlan_static_dhd_memdump_ram_buf[index]);
+#endif /* DHD_USE_STATIC_MEMDUMP | BCMDBUS */
+#if defined(BCMSDIO) || defined(BCMDBUS)
+	kfree(wlan_static_dhd_wlfc_hanger_buf[index]);
+#endif /* BCMSDIO | BCMDBUS */
+#ifdef DHD_USE_STATIC_MEMDUMP
+	kfree(wlan_static_dhd_log_dump_buf[index]);
+	kfree(wlan_static_dhd_log_dump_buf_ex[index]);
+#endif /* DHD_USE_STATIC_MEMDUMP */
+	kfree(wlan_static_wl_escan_info_buf[index]);
+	kfree(wlan_static_fw_verbose_ring_buf[index]);
+	kfree(wlan_static_fw_event_ring_buf[index]);
+	kfree(wlan_static_dhd_event_ring_buf[index]);
+#if defined(BCMDHD_UNUSE_MEM)
+	kfree(wlan_static_nan_event_ring_buf[index]);
+#endif /* BCMDHD_UNUSE_MEM */
+
+#if defined(BCMSDIO) || defined(BCMPCIE)
+	for (i = 0; i < WLAN_SKB_BUF_NUM; i++) {
+		if (wlan_static_skb[index][i])
+			dev_kfree_skb(wlan_static_skb[index][i]);
+	}
+#endif /* BCMSDIO | BCMPCIE */
+
+	return;
+}
+
+static int
+dhd_init_wlan_mem(int index, unsigned int buf_level)
+{
+#if defined(BCMSDIO) || defined(BCMPCIE)
+	int i;
+#endif
+	unsigned long size = 0;
+
+	if (buf_level > 0) {
+#if defined(BCMSDIO) || defined(BCMPCIE)
+		for (i = 0; i < WLAN_SKB_BUF_NUM; i++)
+			wlan_static_skb[index][i] = NULL;
+#if DHD_SKB_1PAGE_BUF_NUM > 0
+		for (i = 0; i < DHD_SKB_1PAGE_BUF_NUM; i++) {
+			wlan_static_skb[index][i] = dev_alloc_skb(DHD_SKB_1PAGE_BUFSIZE);
+			if (!wlan_static_skb[index][i])
+				goto err_mem_alloc;
+			size += DHD_SKB_1PAGE_BUFSIZE;
+			DHD_STATIC_TRACE("section %d skb[%d], size=%ld\n",
+				DHD_PREALLOC_SKB_BUF, i, DHD_SKB_1PAGE_BUFSIZE);
+		}
+#endif
+		for (i = DHD_SKB_1PAGE_BUF_NUM; i < WLAN_SKB_1_2PAGE_BUF_NUM; i++) {
+			wlan_static_skb[index][i] = dev_alloc_skb(DHD_SKB_2PAGE_BUFSIZE);
+			if (!wlan_static_skb[index][i])
+				goto err_mem_alloc;
+			size += DHD_SKB_2PAGE_BUFSIZE;
+			DHD_STATIC_TRACE("section %d skb[%d], size=%ld\n",
+				DHD_PREALLOC_SKB_BUF, i, DHD_SKB_2PAGE_BUFSIZE);
+		}
+#endif /* BCMSDIO | BCMPCIE */
+
+#if defined(BCMSDIO)
+		wlan_static_skb[index][i] = dev_alloc_skb(DHD_SKB_4PAGE_BUFSIZE);
+		if (!wlan_static_skb[index][i])
+			goto err_mem_alloc;
+		size += DHD_SKB_4PAGE_BUFSIZE;
+		DHD_STATIC_TRACE("section %d skb[%d], size=%ld\n",
+			DHD_PREALLOC_SKB_BUF, i, DHD_SKB_4PAGE_BUFSIZE);
+#endif /* BCMSDIO */
+
+		wlan_static_prot[index] = kmalloc(DHD_PREALLOC_PROT_SIZE, GFP_KERNEL);
+		if (!wlan_static_prot[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_PROT_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_PROT, DHD_PREALLOC_PROT_SIZE);
+
+#if defined(BCMSDIO)
+		wlan_static_rxbuf[index] = kmalloc(DHD_PREALLOC_RXBUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_rxbuf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_RXBUF_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_RXBUF, DHD_PREALLOC_RXBUF_SIZE);
+
+		wlan_static_databuf[index] = kmalloc(DHD_PREALLOC_DATABUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_databuf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DATABUF_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_DATABUF, DHD_PREALLOC_DATABUF_SIZE);
+#endif /* BCMSDIO */
+
+		wlan_static_osl_buf[index] = kmalloc(DHD_PREALLOC_OSL_BUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_osl_buf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_OSL_BUF_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%ld\n",
+			DHD_PREALLOC_OSL_BUF, DHD_PREALLOC_OSL_BUF_SIZE);
+
+		wlan_static_scan_buf0[index] = kmalloc(DHD_PREALLOC_WIPHY_ESCAN0_SIZE, GFP_KERNEL);
+		if (!wlan_static_scan_buf0[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_WIPHY_ESCAN0_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_WIPHY_ESCAN0, DHD_PREALLOC_WIPHY_ESCAN0_SIZE);
+
+		wlan_static_dhd_info_buf[index] = kmalloc(DHD_PREALLOC_DHD_INFO_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_info_buf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_INFO_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_DHD_INFO, DHD_PREALLOC_DHD_INFO_SIZE);
+
+#if defined(BCMSDIO) || defined(BCMDBUS)
+		wlan_static_dhd_wlfc_info_buf[index] = kmalloc(WLAN_DHD_WLFC_BUF_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_wlfc_info_buf[index])
+			goto err_mem_alloc;
+		size += WLAN_DHD_WLFC_BUF_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_DHD_WLFC_INFO, WLAN_DHD_WLFC_BUF_SIZE);
+#endif /* BCMSDIO | BCMDBUS */
+
+#ifdef BCMPCIE
+		wlan_static_if_flow_lkup[index] =
+			kmalloc(DHD_PREALLOC_IF_FLOW_LKUP_SIZE, GFP_KERNEL);
+		if (!wlan_static_if_flow_lkup[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_IF_FLOW_LKUP_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_IF_FLOW_LKUP, DHD_PREALLOC_IF_FLOW_LKUP_SIZE);
+#endif /* BCMPCIE */
+	}
+
+#if defined(DHD_USE_STATIC_MEMDUMP) || defined(BCMDBUS)
+	wlan_static_dhd_memdump_ram_buf[index] = kmalloc(DHD_PREALLOC_MEMDUMP_RAM_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_memdump_ram_buf[index])
+		goto err_mem_alloc;
+	size += DHD_PREALLOC_MEMDUMP_RAM_SIZE;
+	DHD_STATIC_TRACE("section %d, size=%d\n",
+		DHD_PREALLOC_MEMDUMP_RAM, DHD_PREALLOC_MEMDUMP_RAM_SIZE);
+#endif /* DHD_USE_STATIC_MEMDUMP | BCMDBUS */
+
+	if (buf_level > 0) {
+#if defined(BCMSDIO) || defined(BCMDBUS)
+		wlan_static_dhd_wlfc_hanger_buf[index] =
+			kmalloc(DHD_PREALLOC_DHD_WLFC_HANGER_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_wlfc_hanger_buf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_DHD_WLFC_HANGER_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_DHD_WLFC_HANGER, DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
+#endif /* BCMSDIO | BCMDBUS */
+
+		if (buf_level > 1) {
+#ifdef DHD_USE_STATIC_MEMDUMP
+			wlan_static_dhd_log_dump_buf[index] =
+				kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE, GFP_KERNEL);
+			if (!wlan_static_dhd_log_dump_buf[index])
+				goto err_mem_alloc;
+			size += DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE;
+			DHD_STATIC_TRACE("section %d, size=%d\n",
+				DHD_PREALLOC_DHD_LOG_DUMP_BUF, DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE);
+
+			wlan_static_dhd_log_dump_buf_ex[index] =
+				kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE, GFP_KERNEL);
+			if (!wlan_static_dhd_log_dump_buf_ex[index])
+				goto err_mem_alloc;
+			size += DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE;
+			DHD_STATIC_TRACE("section %d, size=%d\n",
+				DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX,
+				DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE);
+#endif /* DHD_USE_STATIC_MEMDUMP */
+		}
+
+		wlan_static_wl_escan_info_buf[index] =
+			kmalloc(DHD_PREALLOC_WL_ESCAN_SIZE, GFP_KERNEL);
+		if (!wlan_static_wl_escan_info_buf[index])
+			goto err_mem_alloc;
+		size += DHD_PREALLOC_WL_ESCAN_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_WL_ESCAN, DHD_PREALLOC_WL_ESCAN_SIZE);
+	}
+
+	wlan_static_fw_verbose_ring_buf[index] = kmalloc(FW_VERBOSE_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_fw_verbose_ring_buf[index])
+		goto err_mem_alloc;
+	size += FW_VERBOSE_RING_SIZE;
+	DHD_STATIC_TRACE("section %d, size=%d\n",
+		DHD_PREALLOC_FW_VERBOSE_RING, FW_VERBOSE_RING_SIZE);
+
+	if (buf_level > 0) {
+		wlan_static_fw_event_ring_buf[index] = kmalloc(FW_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_fw_event_ring_buf[index])
+			goto err_mem_alloc;
+		size += FW_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_FW_EVENT_RING, FW_EVENT_RING_SIZE);
+
+		wlan_static_dhd_event_ring_buf[index] = kmalloc(DHD_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_dhd_event_ring_buf[index])
+			goto err_mem_alloc;
+		size += DHD_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_DHD_EVENT_RING, DHD_EVENT_RING_SIZE);
+
+#if defined(BCMDHD_UNUSE_MEM)
+		wlan_static_nan_event_ring_buf[index] = kmalloc(NAN_EVENT_RING_SIZE, GFP_KERNEL);
+		if (!wlan_static_nan_event_ring_buf[index])
+			goto err_mem_alloc;
+		size += NAN_EVENT_RING_SIZE;
+		DHD_STATIC_TRACE("section %d, size=%d\n",
+			DHD_PREALLOC_NAN_EVENT_RING, NAN_EVENT_RING_SIZE);
+#endif /* BCMDHD_UNUSE_MEM */
+	}
+
+	DHD_STATIC_MSG("prealloc ok for index %d: %ld(%ldK)\n", index, size, size / 1024);
+	return 0;
+
+err_mem_alloc:
+	DHD_STATIC_ERROR("Failed to allocate memory for index %d\n", index);
+
+	return -ENOMEM;
+}
+
+#ifdef DHD_STATIC_IN_DRIVER
+int
+#else
+int
+#endif
+bcmdhd_init_wlan_mem(unsigned int all_buf)
+{
+	int i, ret = 0;
+
+	DHD_STATIC_MSG("%s\n", DHD_STATIC_VERSION_STR);
+
+	for (i = 0; i < MAX_NUM_ADAPTERS; i++) {
+		ret = dhd_init_wlan_mem(i, all_buf);
+		if (ret)
+			break;
+	}
+
+#ifndef DHD_STATIC_IN_DRIVER
+	if (ret) {
+		for (i = 0; i < MAX_NUM_ADAPTERS; i++)
+			dhd_deinit_wlan_mem(i);
+	}
+#endif
+
+	return ret;
+}
+
+#ifdef DHD_STATIC_USE_DEINIT
+#ifdef DHD_STATIC_IN_DRIVER
+void
+#else
+static void __exit
+#endif
+dhd_static_buf_exit(void)
+{
+	int i;
+
+	DHD_STATIC_MSG("Enter\n");
+
+	for (i = 0; i < MAX_NUM_ADAPTERS; i++)
+		dhd_deinit_wlan_mem(i);
+}
+#endif
+
+#ifndef DHD_STATIC_IN_DRIVER
+EXPORT_SYMBOL(bcmdhd_init_wlan_mem);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("wifi device tree driver");
+#endif
diff --git a/drivers/amlogic/wifi/wifi_dt.c b/drivers/amlogic/wifi/wifi_dt.c
new file mode 100644
index 000000000..8a91555dc
--- /dev/null
+++ b/drivers/amlogic/wifi/wifi_dt.c
@@ -0,0 +1,1120 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+//#define DEBUG
+#include <linux/amlogic/wifi_dt.h>
+#include <linux/amlogic/dhd_buf.h>
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/io.h>
+#include <linux/amlogic/pm.h>
+#include <linux/uaccess.h>
+#include <linux/pci.h>
+#include <linux/amlogic/aml_sd.h>
+#include <linux/printk.h>
+#ifdef CONFIG_AMLOGIC_PWM_32K
+#include <linux/pwm.h>
+#include <linux/amlogic/pwm-meson.h>
+#endif
+#include <gpiolib-of.h>
+#define OWNER_NAME "sdio_wifi"
+
+static char aml_wifi_chip_type[10] = "NULL";
+
+struct pcie_wifi_chip {
+	unsigned int vendor;
+	unsigned int device;
+};
+
+static const struct pcie_wifi_chip pcie_wifi[] = {
+	{0x16c3, 0xabcd}
+};
+
+int wifi_power_gpio;
+int wifi_power_gpio2;
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+/*
+ *there are two pwm channel outputs using one gpio
+ *for gxtvbb and the follows soc
+ */
+struct pwm_double_data {
+	struct pwm_device *pwm;
+	unsigned int duty_cycle;
+	unsigned int pwm_times;
+};
+
+struct pwm_double_datas {
+	int num_pwm;
+	struct pwm_double_data pwms[2];
+};
+
+struct pwm_single_data {
+	struct pwm_device *pwm;
+	unsigned int duty_cycle;
+};
+#endif
+
+struct wifi_plat_info {
+	int interrupt_pin;
+	int irq_num;
+	int irq_trigger_type;
+
+	int power_on_pin;
+	int power_on_pin_level;
+	int power_on_pin_OD;
+	int power_on_pin2;
+	int chip_en_pin;
+	int power_init_off;
+
+	int clock_32k_pin;
+	struct gpio_desc *interrupt_desc;
+	struct gpio_desc *powe_desc;
+
+	int plat_info_valid;
+	struct pinctrl *p;
+	struct device		*dev;
+#ifdef CONFIG_AMLOGIC_PWM_32K
+	struct pwm_double_datas ddata;
+	struct pwm_single_data sdata;
+#endif
+};
+
+#define WIFI_POWER_MODULE_NAME	"wifi_power"
+#define WIFI_POWER_DRIVER_NAME	"wifi_power"
+#define WIFI_POWER_DEVICE_NAME	"wifi_power"
+#define WIFI_POWER_CLASS_NAME	"wifi_power"
+
+#define WIFI_MAC_MODULE_NAME	"wifi_mac"
+#define WIFI_MAC_DRIVER_NAME	"wifi_mac"
+#define WIFI_MAC_DEVICE_NAME	"wifi_mac"
+#define WIFI_MAC_CLASS_NAME	"wifi_mac"
+
+#define USB_POWER_UP    _IO('m', 1)
+#define USB_POWER_DOWN  _IO('m', 2)
+#define WIFI_POWER_UP    _IO('m', 3)
+#define WIFI_POWER_DOWN  _IO('m', 4)
+#define SDIO_GET_DEV_TYPE  _IO('m', 5)
+#define CLR_BT_POWER_BIT   _IO('m', 6)
+#define GET_AML_WIFI_MODULE  _IO('m', 7)
+static struct wifi_plat_info wifi_info;
+static dev_t wifi_power_devno;
+static struct cdev *wifi_power_cdev;
+static struct device *devp;
+struct wifi_power_platform_data *pdata;
+
+static dev_t wifi_mac_devno;
+static struct cdev *wifi_mac_cdev;
+static struct device *wifi_mac_devp;
+
+static int usb_power;
+#define BT_BIT	0
+#define WIFI_BIT	1
+static DEFINE_MUTEX(wifi_bt_mutex);
+
+#define WIFI_INFO(fmt, args...)	\
+	pr_info("[%s] " fmt, __func__, ##args)
+
+#define WIFI_DEBUG(fmt, args...)	\
+	pr_debug("[%s] " fmt, __func__, ##args)
+
+#ifdef CONFIG_OF
+static const struct of_device_id wifi_match[] = {
+	{
+		.compatible = "amlogic, aml-wifi",
+		.data		= (void *)&wifi_info
+	},
+	{},
+};
+
+static struct wifi_plat_info *wifi_get_driver_data
+	(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+
+	match = of_match_node(wifi_match, pdev->dev.of_node);
+	if (!match)
+		return NULL;
+	return (struct wifi_plat_info *)match->data;
+}
+#else
+#define wifi_match NULL
+#endif
+
+#define SHOW_PIN_OWN(pin_str, pin_num)	\
+	WIFI_DEBUG("%s(%d)\n", pin_str, pin_num)
+
+#ifdef CONFIG_PCI
+int is_pcie_wifi(void)
+{
+	struct pci_dev *device = NULL;
+	int n = 0;
+	int i = 0;
+
+	n = (int)(sizeof(pcie_wifi) / sizeof(struct pcie_wifi_chip));
+	for (i = 0; i < n; i++) {
+		device = pci_get_device(pcie_wifi[i].vendor,
+			pcie_wifi[i].device, NULL);
+		if (device) {
+			WIFI_INFO("found device 0x%x:0x%x!\n",
+				pcie_wifi[i].vendor, pcie_wifi[i].device);
+			return 1;
+		}
+	}
+	return 0;
+}
+#else
+int is_pcie_wifi(void)
+{
+	return 0;
+}
+#endif
+
+static int set_power(int value)
+{
+	if (!wifi_info.power_on_pin_OD) {
+		if (wifi_info.power_on_pin_level)
+			return gpio_direction_output(wifi_info.power_on_pin,
+					!value);
+		else
+			return gpio_direction_output(wifi_info.power_on_pin,
+					value);
+	} else {
+		if (wifi_info.power_on_pin_level) {
+			if (value)
+				gpio_direction_input(wifi_info.power_on_pin);
+			else
+				gpio_direction_output(wifi_info.power_on_pin,
+						      0);
+		} else {
+			if (value)
+				gpio_direction_output(wifi_info.power_on_pin,
+						      0);
+			else
+				gpio_direction_input(wifi_info.power_on_pin);
+		}
+	}
+	return 0;
+}
+
+static int set_power2(int value)
+{
+	if (wifi_info.power_on_pin_level)
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				!value);
+	else
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				value);
+}
+
+static int set_wifi_power(int is_power)
+{
+	int ret = 0;
+
+	WIFI_DEBUG("pid: %d comm: %s, power %s!\n", current->pid,
+		current->comm, is_power ? "UP" : "DOWN");
+
+	if (is_power) {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(1);
+			if (ret)
+				WIFI_INFO("power up failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(1);
+			if (ret)
+				WIFI_INFO("power2 up failed(%d)\n", ret);
+		}
+	} else {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(0);
+			if (ret)
+				WIFI_INFO("power down failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(0);
+			if (ret)
+				WIFI_INFO("power2 down failed(%d)\n", ret);
+		}
+	}
+	return ret;
+}
+
+static void usb_power_control(int is_power, int shift)
+{
+	mutex_lock(&wifi_bt_mutex);
+	if (is_power) {
+		if (!usb_power) {
+			set_wifi_power(is_power);
+			WIFI_INFO("Set %s power on !\n",
+				  (shift ? "WiFi" : "BT"));
+			msleep(200);
+			sdio_reinit();
+		}
+		usb_power |= (1 << shift);
+		WIFI_INFO("Set %s power on !\n",
+			  (shift ? "WiFi" : "BT"));
+	} else {
+		usb_power &= ~(1 << shift);
+		if (!usb_power) {
+			set_wifi_power(is_power);
+			msleep(200);
+			WIFI_INFO("Set %s power down\n",
+				  (shift ? "WiFi" : "BT"));
+		}
+	}
+	mutex_unlock(&wifi_bt_mutex);
+}
+
+void set_usb_bt_power(int is_power)
+{
+	if (!is_pcie_wifi())
+		usb_power_control(is_power, BT_BIT);
+}
+EXPORT_SYMBOL(set_usb_bt_power);
+
+void set_usb_wifi_power(int is_power)
+{
+	usb_power_control(is_power, WIFI_BIT);
+}
+EXPORT_SYMBOL(set_usb_wifi_power);
+static int  wifi_power_open(struct inode *inode, struct file *file)
+{
+	struct cdev *cdevp = inode->i_cdev;
+
+	file->private_data = cdevp;
+	return 0;
+}
+
+static int  wifi_power_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_remove(void)
+{
+	struct pci_dev *device = NULL;
+	struct pci_dev *devicebus = NULL;
+	int n = 0;
+	int i = 0;
+
+	WIFI_INFO("pci remove!\n");
+	n = (int)(sizeof(pcie_wifi) / sizeof(struct pcie_wifi_chip));
+	for (i = 0; i < n; i++) {
+		device = pci_get_device(pcie_wifi[i].vendor,
+			pcie_wifi[i].device, NULL);
+		if (device) {
+			WIFI_INFO("found device 0x%x:0x%x, remove it!\n",
+				pcie_wifi[i].vendor, pcie_wifi[i].device);
+			devicebus = device->bus->self;
+			pci_stop_and_remove_bus_device_locked(device);
+			if (devicebus) {
+				WIFI_INFO("remove bus!\n");
+				pci_stop_and_remove_bus_device_locked(devicebus);
+			}
+		}
+	}
+}
+EXPORT_SYMBOL(pci_remove);
+
+void pci_reinit(void)
+{
+	struct pci_bus *bus = NULL;
+	int cnt = 20;
+
+	WIFI_INFO("pci wifi reinit!\n");
+
+	pci_lock_rescan_remove();
+	while ((bus = pci_find_next_bus(bus)) != NULL) {
+		pci_rescan_bus(bus);
+		WIFI_INFO("rescanning pci device\n");
+		cnt--;
+		if (cnt <= 0)
+			break;
+	}
+	pci_unlock_rescan_remove();
+}
+#else
+void pci_remove(void)
+{
+	WIFI_INFO("PCI removed!\n");
+}
+
+void pci_reinit(void)
+{
+	WIFI_INFO("PCI disabled!\n");
+}
+#endif
+EXPORT_SYMBOL(pci_reinit);
+
+#ifdef CONFIG_PCI
+void pci_remove_reinit(unsigned int vid, unsigned int pid, unsigned int del_bus)
+{
+	struct pci_bus *bus = NULL;
+	struct pci_dev *dev_device = NULL;
+	struct pci_dev *dev_bus = NULL;
+	int cnt = 20;
+
+	WIFI_INFO("pci wifi remove and reinit\n");
+	dev_device = pci_get_device(vid, pid, NULL);
+
+	if (dev_device) {
+		WIFI_INFO("device 0x%x:0x%x found, remove it\n", vid, pid);
+		dev_bus = dev_device->bus->self;
+		pci_stop_and_remove_bus_device_locked(dev_device);
+
+		if (del_bus > 0 && dev_bus) {
+			WIFI_INFO("remove ths bus this device on!\n");
+			pci_stop_and_remove_bus_device_locked(dev_bus);
+		}
+	} else {
+		WIFI_INFO("target pci device not found 0x%x:0x%x\n", vid, pid);
+	}
+
+	set_usb_wifi_power(0);
+	set_usb_wifi_power(1);
+
+	pci_lock_rescan_remove();
+	while ((bus = pci_find_next_bus(bus)) != NULL) {
+		pci_rescan_bus(bus);
+		WIFI_INFO("rescanning pci device\n");
+		cnt--;
+		if (cnt <= 0)
+			break;
+	}
+	pci_unlock_rescan_remove();
+}
+#else
+void pci_remove_reinit(unsigned int vid, unsigned int pid, unsigned int del_bus)
+{
+	WIFI_INFO("PCI disabled!\n");
+}
+#endif
+EXPORT_SYMBOL(pci_remove_reinit);
+
+static long wifi_power_ioctl(struct file *filp,
+			     unsigned int cmd, unsigned long arg)
+{
+	char dev_type[10] = {'\0'};
+
+	switch (cmd) {
+	case USB_POWER_UP:
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		WIFI_INFO(KERN_INFO "ioctl Set usb_sdio wifi power up!\n");
+		break;
+	case USB_POWER_DOWN:
+		set_usb_wifi_power(0);
+		WIFI_INFO(KERN_INFO "ioctl Set usb_sdio wifi power down!\n");
+		break;
+	case WIFI_POWER_UP:
+		pci_remove();
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		pci_reinit();
+		WIFI_INFO("Set sdio wifi power up!\n");
+		break;
+	case WIFI_POWER_DOWN:
+		set_usb_wifi_power(0);
+		WIFI_INFO("ioctl Set sdio wifi power down!\n");
+		break;
+	case SDIO_GET_DEV_TYPE:
+		if (strlen(get_wifi_inf()) >= sizeof(dev_type))
+			memcpy(dev_type, get_wifi_inf(),
+			       (sizeof(dev_type) - 1));
+		else
+			memcpy(dev_type, get_wifi_inf(),
+			       strlen(get_wifi_inf()));
+		WIFI_INFO("wifi interface dev type: %s, length = %d\n",
+			  dev_type, (int)strlen(dev_type));
+		if (copy_to_user((char __user *)arg,
+				 dev_type, strlen(dev_type)))
+			return -ENOTTY;
+		break;
+	case GET_AML_WIFI_MODULE:
+		if (memcmp(aml_wifi_chip_type, "NULL", 4))
+			WIFI_INFO("aml module chip is %s", aml_wifi_chip_type);
+		if (copy_to_user((char __user *)arg,
+					aml_wifi_chip_type, 10))
+			return -ENOTTY;
+		break;
+	case CLR_BT_POWER_BIT:
+		usb_power &= ~(1 << BT_BIT);
+		WIFI_INFO("CUR status: %d\n", usb_power);
+		break;
+	default:
+		WIFI_INFO("usb %s: default !!!\n", __func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct class *wifi_dt_class;
+static ssize_t power_show(const struct class *class,
+			const struct class_attribute *attr,
+			char *_buf)
+{
+	if (!_buf)
+		return -EINVAL;
+
+	return sprintf(_buf, "%s%s%s",
+		"wifi power ctrl:\n",
+		"1=power on\n",
+		"2=power down\n");
+}
+
+static ssize_t power_store(const struct class *class,
+			const struct class_attribute *attr,
+			const char *buf, size_t count)
+{
+	int ret = -EINVAL;
+	unsigned char cmd = 0;
+
+	if (!buf || 0 != kstrtou8(buf, 0, &cmd))
+		return ret;
+
+	WIFI_INFO("wifi power ctrl: cmd = %d\n", (int)cmd);
+	switch (cmd) {
+	case 1:
+		pci_remove();
+		set_usb_wifi_power(0);
+		set_usb_wifi_power(1);
+		pci_reinit();
+		WIFI_INFO("set wifi power up!\n");
+		break;
+	case 2:
+		set_usb_wifi_power(0);
+		WIFI_INFO("set wifi power down!\n");
+		break;
+	default:
+		WIFI_INFO("wifi power ctrl: Invalid parameter!!!\n");
+		return ret;
+	}
+
+	return count;
+}
+static CLASS_ATTR_RW(power);
+
+static int wifi_mac_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t wifi_mac_write(struct file *file, const char __user *buf,
+				size_t count, loff_t *ppos);
+
+static const struct file_operations wifi_power_fops = {
+	.unlocked_ioctl = wifi_power_ioctl,
+	.compat_ioctl = wifi_power_ioctl,
+	.open	= wifi_power_open,
+	.release	= wifi_power_release,
+};
+
+static const struct file_operations wifi_mac_fops = {
+	.open = wifi_mac_open,
+	.write = wifi_mac_write,
+};
+
+static struct class wifi_power_class = {
+	.name		= WIFI_POWER_CLASS_NAME,
+};
+
+static int wifi_setup_dt(void)
+{
+	int ret;
+
+	WIFI_DEBUG("[%s] is enter\n", __func__);
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("%s : invalid device tree setting\n", __func__);
+		return -1;
+	}
+
+	/* setup irq */
+	if (wifi_info.interrupt_pin) {
+		ret = gpio_request(wifi_info.interrupt_pin,
+				   OWNER_NAME);
+		if (ret)
+			WIFI_INFO("interrupt_pin request failed(%d)\n", ret);
+
+		ret = gpio_direction_input(wifi_info.interrupt_pin);
+		if (ret)
+			WIFI_INFO("set interrupt_pin input failed(%d)\n", ret);
+
+		wifi_info.irq_num = gpio_to_irq(wifi_info.interrupt_pin);
+		if (wifi_info.irq_num)
+			WIFI_DEBUG("irq num is:(%d)\n", wifi_info.irq_num);
+
+		SHOW_PIN_OWN("interrupt_pin", wifi_info.interrupt_pin);
+	}
+
+	/* setup power */
+	if (wifi_info.chip_en_pin) {
+		ret = gpio_request(wifi_info.chip_en_pin, OWNER_NAME);
+		if (ret)
+			WIFI_INFO("chip_en_pin request failed(%d)\n", ret);
+		ret = gpio_direction_output(wifi_info.chip_en_pin, 0);
+		if (ret)
+			WIFI_INFO("chip_en_pin output 0 failed(%d)\n", ret);
+		msleep(20);
+		ret = gpio_direction_output(wifi_info.chip_en_pin, 1);
+		if (ret)
+			WIFI_INFO("chip_en_pin output 1 failed(%d)\n", ret);
+		SHOW_PIN_OWN("chip_en_pin", wifi_info.chip_en_pin);
+	}
+
+	if (wifi_info.power_on_pin) {
+		ret = gpio_request(wifi_info.power_on_pin, OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin request failed(%d)\n", ret);
+		if (wifi_info.power_init_off) {
+			if (wifi_info.power_on_pin_level)
+				ret = set_power(1);
+			else
+				ret = set_power(0);
+		} else {
+			if (wifi_info.power_on_pin_level)
+				ret = set_power(0);
+			else
+				ret = set_power(1);
+		}
+		if (ret)
+			WIFI_INFO("power_on_pin output failed(%d)\n", ret);
+		SHOW_PIN_OWN("power_on_pin", wifi_info.power_on_pin);
+	}
+
+	if (wifi_info.power_on_pin2) {
+		ret = gpio_request(wifi_info.power_on_pin2,
+				   OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin2 request failed(%d)\n", ret);
+		if (wifi_info.power_on_pin_level)
+			ret = set_power2(1);
+		else
+			ret = set_power2(0);
+		if (ret)
+			WIFI_INFO("power_on_pin2 output failed(%d)\n", ret);
+		SHOW_PIN_OWN("power_on_pin2", wifi_info.power_on_pin2);
+	}
+
+	return 0;
+}
+
+static void wifi_teardown_dt(void)
+{
+	WIFI_INFO("%s is enter\n", __func__);
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("%s : invalid device tree setting\n", __func__);
+		return;
+	}
+
+	if (wifi_info.power_on_pin)
+		gpio_free(wifi_info.power_on_pin);
+
+	if (wifi_info.power_on_pin2)
+		gpio_free(wifi_info.power_on_pin2);
+
+	if (wifi_info.interrupt_pin)
+		gpio_free(wifi_info.interrupt_pin);
+}
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+/*
+ * for gxb ,m8b soc
+ * single pwm channel
+ */
+int pwm_single_channel_conf(struct wifi_plat_info *plat)
+{
+	struct pwm_device *pwm = plat->sdata.pwm;
+	struct pwm_state pstate;
+	int duty_value;
+	int ret;
+
+	/* get pwm duty_cycle property */
+	ret = of_property_read_u32(plat->dev->of_node, "duty_cycle",
+				   &duty_value);
+	if (ret) {
+		pr_err("not config pwm duty_cycle");
+		return ret;
+	}
+	/* get pwm device */
+	pwm = devm_pwm_get(plat->dev, NULL);
+	if (IS_ERR(pwm)) {
+		ret = PTR_ERR(pwm);
+		dev_err(plat->dev, "Failed to get PWM: %d\n", ret);
+		return ret;
+	}
+	/* config pwm */
+	pwm_init_state(pwm, &pstate);
+	pwm_config(pwm, duty_value, pstate.period);
+	pwm_enable(pwm);
+
+	WIFI_DEBUG("pwm period val=%lld, pwm duty val=%lld\n",
+		  pstate.period, pstate.duty_cycle);
+	WIFI_INFO("wifi pwm conf ok\n");
+
+	return 0;
+}
+
+int pwm_double_channel_conf_dt(struct wifi_plat_info *plat)
+{
+	int ret;
+	struct fwnode_handle *fwnode;
+
+	/*request for pwm device */
+	device_for_each_child_node(plat->dev, fwnode) {
+		struct pwm_double_data *pdata =
+			&plat->ddata.pwms[plat->ddata.num_pwm];
+
+		//KV_TODO: modify
+		pdata->pwm = devm_fwnode_pwm_get(plat->dev, fwnode, NULL);
+		if (IS_ERR(pdata->pwm)) {
+			ret = PTR_ERR(pdata->pwm);
+			dev_err(plat->dev, "unable to request PWM%d, ret = %d\n",
+				plat->ddata.num_pwm, ret);
+			return ret;
+		}
+		ret = fwnode_property_read_u32(fwnode, "duty-cycle",
+					   &pdata->duty_cycle);
+		if (ret) {
+			pr_err("not %d duty_cycle parameters\n",
+			       plat->ddata.num_pwm);
+			return ret;
+		}
+		ret = fwnode_property_read_u32(fwnode, "times",
+					   &pdata->pwm_times);
+		if (ret) {
+			pr_err("not %d pwm_times parameters\n",
+			       plat->ddata.num_pwm);
+			return ret;
+		}
+		plat->ddata.num_pwm++;
+	}
+	WIFI_DEBUG("wifi pwm dt ok\n");
+
+	return 0;
+}
+
+/*
+ *configuration for double pwm
+ */
+int pwm_double_channel_conf(struct wifi_plat_info *plat)
+{
+	struct pwm_double_data pwm_data1 = plat->ddata.pwms[0];
+	struct pwm_double_data pwm_data2 = plat->ddata.pwms[1];
+	struct pwm_device *pwm1 = pwm_data1.pwm;
+	struct pwm_device *pwm2 = pwm_data2.pwm;
+	struct meson_pwm *meson1 = to_meson_pwm(pwm1->chip);
+	struct meson_pwm *meson2 = to_meson_pwm(pwm2->chip);
+	struct pwm_state pstate1;
+	struct pwm_state pstate2;
+	unsigned int pwm1_duty = pwm_data1.duty_cycle;
+	unsigned int pwm1_times = pwm_data1.pwm_times;
+	unsigned int pwm2_duty = pwm_data2.duty_cycle;
+	unsigned int pwm2_times = pwm_data2.pwm_times;
+	int ret = 0;
+
+	/*init for pwm2 device*/
+	pwm_init_state(pwm1, &pstate1);
+	pwm_init_state(pwm2, &pstate2);
+
+	pwm_config(pwm1, pwm1_duty, pstate1.period);
+	pwm_config(pwm2, pwm2_duty, pstate2.period);
+
+	ret = pwm_set_times(meson1, pwm1->hwpwm, pwm1_times);
+	if (ret) {
+		pr_err("[%s][%d]wifi: pwm_set_times filed\n",
+		       __func__, __LINE__);
+		return ret;
+	}
+	ret = pwm_set_times(meson2, pwm2->hwpwm, pwm2_times);
+	if (ret) {
+		pr_err("[%s][%d]wifi: pwm_set_times filed\n",
+		       __func__, __LINE__);
+		return ret;
+	}
+	pwm_enable(pwm1);
+	pwm_enable(pwm2);
+	WIFI_DEBUG("wifi pwm conf ok\n");
+
+	return 0;
+}
+#endif
+
+static int wifi_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+
+#ifdef CONFIG_OF
+	struct wifi_plat_info *plat;
+	const char *value;
+	int buf_level = 0;
+	//struct gpio_desc *desc;
+#else
+	struct wifi_plat_info *plat =
+	 (struct wifi_plat_info *)(pdev->dev.platform_data);
+#endif
+
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		plat = wifi_get_driver_data(pdev);
+		plat->plat_info_valid = 0;
+		plat->dev = &pdev->dev;
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "interrupt-gpios", &value);
+		if (ret) {
+			WIFI_INFO("no interrupt pin");
+			plat->interrupt_pin = 0;
+		} else {
+			plat->interrupt_pin = of_get_named_gpio
+							(pdev->dev.of_node,
+							"interrupt-gpios",
+							0);
+			ret = of_property_read_string(pdev->dev.of_node,
+						      "irq_trigger_type",
+						      &value);
+			if (ret) {
+				WIFI_INFO("no irq_trigger_type");
+				plat->irq_trigger_type = 0;
+				return -1;
+			}
+
+			if (strcmp(value, "IRQF_TRIGGER_HIGH") == 0) {
+				plat->irq_trigger_type = IRQF_TRIGGER_HIGH;
+			} else if (strcmp(value, "IRQF_TRIGGER_LOW") == 0) {
+				plat->irq_trigger_type = IRQF_TRIGGER_LOW;
+			} else if (strcmp(value, "IRQF_TRIGGER_RISING") == 0) {
+				plat->irq_trigger_type = IRQF_TRIGGER_RISING;
+			} else if (strcmp(value, "IRQF_TRIGGER_FALLING") == 0) {
+				plat->irq_trigger_type = IRQF_TRIGGER_FALLING;
+			} else {
+				WIFI_INFO("unknown irq trigger type-%s\n",
+					  value);
+				return -1;
+			}
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "power_on-gpios", &value);
+		if (ret) {
+			WIFI_DEBUG("no power_on_pin");
+			plat->power_on_pin = 0;
+			plat->power_on_pin_OD = 0;
+		} else {
+			wifi_power_gpio = 1;
+			plat->power_on_pin = of_get_named_gpio
+							(pdev->dev.of_node,
+							"power_on-gpios",
+							0);
+		}
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_on_pin_level",
+					   &plat->power_on_pin_level);
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					   "power_on_pin_OD",
+					   &plat->power_on_pin_OD);
+		if (ret)
+			plat->power_on_pin_OD = 0;
+		pr_debug("wifi: power_on_pin_OD = %d;\n", plat->power_on_pin_OD);
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "power_on_2-gpios", &value);
+		if (ret) {
+			WIFI_DEBUG("no power_on_pin2");
+			plat->power_on_pin2 = 0;
+		} else {
+			wifi_power_gpio2 = 1;
+			plat->power_on_pin2 = of_get_named_gpio
+							(pdev->dev.of_node,
+							"power_on_2-gpios",
+							0);
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node,
+					      "chip_en-gpios", &value);
+		if (ret) {
+			WIFI_DEBUG("no chip_en_pin");
+			plat->chip_en_pin = 0;
+		} else {
+			plat->chip_en_pin = of_get_named_gpio
+							(pdev->dev.of_node,
+							"chip_en-gpios",
+							0);
+		}
+
+#ifdef CONFIG_AMLOGIC_PWM_32K
+		if (!of_get_property(pdev->dev.of_node, "disable-wifi-32k", NULL)) {
+			if (of_get_property(pdev->dev.of_node, "single_pwm", NULL)) {
+				WIFI_INFO("use single channel\n");
+				ret = pwm_single_channel_conf(plat);
+				if (ret)
+					pr_err("pwm config err\n");
+			} else {
+				WIFI_INFO("use double channel\n");
+				ret = pwm_double_channel_conf_dt(plat);
+				if (!ret)
+					pwm_double_channel_conf(plat);
+				else if (ret == -EPROBE_DEFER)
+					goto out;
+			}
+		}
+#endif
+		if (!of_property_read_u32(pdev->dev.of_node,
+			"wifi_static_buf", &buf_level)) {
+			WIFI_INFO("buf_level is :%d\n", buf_level);
+			//buf_level 0: aml wifi
+			//buf_level 1: dhd wifi for linux no VTS
+			//buf_level 2: dhd wifi for android
+			bcmdhd_init_wlan_mem(buf_level);
+		}
+		plat->plat_info_valid = 1;
+
+		if (!(plat->interrupt_pin)) {
+			WIFI_INFO("interrupt_pin=%d\n", plat->interrupt_pin);
+			WIFI_INFO("irq_num=%d, irq_trigger_type=%d\n",
+				  plat->irq_num, plat->irq_trigger_type);
+			WIFI_INFO("power_on_pin=%d\n", plat->power_on_pin);
+			WIFI_INFO("clock_32k_pin=%d\n", plat->clock_32k_pin);
+		}
+	}
+#endif
+	ret = alloc_chrdev_region(&wifi_power_devno,
+				  0, 1, WIFI_POWER_DRIVER_NAME);
+	if (ret < 0) {
+		ret = -ENODEV;
+		goto out;
+	}
+	ret = class_register(&wifi_power_class);
+	if (ret < 0)
+		goto error1;
+	wifi_power_cdev = cdev_alloc();
+	if (!wifi_power_cdev)
+		goto error2;
+	cdev_init(wifi_power_cdev, &wifi_power_fops);
+	wifi_power_cdev->owner = THIS_MODULE;
+	ret = cdev_add(wifi_power_cdev, wifi_power_devno, 1);
+	if (ret)
+		goto error3;
+	devp = device_create(&wifi_power_class, NULL,
+			     wifi_power_devno, NULL, WIFI_POWER_DEVICE_NAME);
+	if (IS_ERR(devp)) {
+		ret = PTR_ERR(devp);
+		goto error3;
+	}
+	devp->platform_data = pdata;
+
+	wifi_setup_dt();
+
+	wifi_dt_class = class_create("aml_wifi");
+	ret = class_create_file(wifi_dt_class, &class_attr_power);
+	/********wifi rand mac***********/
+	ret = alloc_chrdev_region(&wifi_mac_devno, 0, 1, WIFI_MAC_DEVICE_NAME);
+	if (ret < 0)
+		goto error3;
+	wifi_mac_cdev = cdev_alloc();
+	if (!wifi_mac_cdev)
+		goto error3;
+	cdev_init(wifi_mac_cdev, &wifi_mac_fops);
+	wifi_mac_cdev->owner = THIS_MODULE;
+	ret = cdev_add(wifi_mac_cdev, wifi_mac_devno, 1);
+	if (ret)
+		goto error4;
+	wifi_mac_devp = device_create(wifi_dt_class, NULL,
+					wifi_mac_devno, NULL, WIFI_MAC_DEVICE_NAME);
+	if (IS_ERR(wifi_mac_devp)) {
+		ret = PTR_ERR(wifi_mac_devp);
+		goto error4;
+	}
+	device_init_wakeup(&pdev->dev, true);
+	return 0;
+error4:
+	cdev_del(wifi_mac_cdev);
+error3:
+	cdev_del(wifi_power_cdev);
+error2:
+	class_unregister(&wifi_power_class);
+error1:
+	unregister_chrdev_region(wifi_power_devno, 1);
+out:
+	return ret;
+}
+
+static int wifi_dev_remove(struct platform_device *pdev)
+{
+	WIFI_INFO("%s is enter\n", __func__);
+	wifi_teardown_dt();
+	return 0;
+}
+
+static int wifi_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	return 0;
+}
+
+static int wifi_resume(struct platform_device *pdev)
+{
+	if (get_resume_method() == WIFI_WAKEUP)
+		pm_wakeup_event(&pdev->dev, 5000);
+	return 0;
+}
+
+static struct platform_driver wifi_plat_driver = {
+	.probe = wifi_dev_probe,
+	.remove = wifi_dev_remove,
+	.driver = {
+	.name = "aml_wifi",
+	.owner = THIS_MODULE,
+	.of_match_table = wifi_match
+	},
+	.suspend = wifi_suspend,
+	.resume = wifi_resume,
+};
+
+int __init wifi_dt_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&wifi_plat_driver);
+	return ret;
+}
+
+void __exit wifi_dt_exit(void)
+{
+	platform_driver_unregister(&wifi_plat_driver);
+}
+
+/**************** wifi mac *****************/
+u8 WIFI_MAC[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+char wifi_mac[32] = {0};
+char *wifimac;
+#ifdef MODULE
+__module_param(wifimac, charp, 0644);
+#else
+core_param(wifimac, wifimac, charp, 0644);
+#endif
+static unsigned char chartonum(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'A' && c <= 'F')
+		return (c - 'A') + 10;
+	if (c >= 'a' && c <= 'f')
+		return (c - 'a') + 10;
+	return 0;
+}
+
+static int mac_addr_set(char *line)
+{
+	unsigned char mac[6];
+	int i = 0;
+
+	WIFI_INFO("try to wifi mac from emmc key!\n");
+	for (i = 0; i < 6 && line[0] != '\0' && line[1] != '\0'; i++) {
+		mac[i] = chartonum(line[0]) << 4 | chartonum(line[1]);
+		line += 3;
+	}
+	memcpy(WIFI_MAC, mac, 6);
+	snprintf(wifi_mac, sizeof(wifi_mac),
+		 "%02x:%02x:%02x:%02x:%02x:%02x",
+		 WIFI_MAC[0], WIFI_MAC[1], WIFI_MAC[2],
+		 WIFI_MAC[3], WIFI_MAC[4], WIFI_MAC[5]);
+	wifimac = (char *)wifi_mac;
+	WIFI_INFO("uboot setup mac-addr: %x:%x:%x:%x:%x:%x\n",
+		  WIFI_MAC[0], WIFI_MAC[1], WIFI_MAC[2],
+		  WIFI_MAC[3], WIFI_MAC[4], WIFI_MAC[5]);
+
+	return 1;
+}
+
+#ifdef MODULE
+static char *mac_addr = "";
+
+static int set_mac_addr(const char *val, const struct kernel_param *kp)
+{
+	param_set_charp(val, kp);
+
+	return mac_addr_set(mac_addr);
+}
+
+static const struct kernel_param_ops mac_addr_ops = {
+	.set = set_mac_addr,
+	.get = param_get_charp,
+};
+
+__module_param_cb(mac_addr, &mac_addr_ops, &mac_addr, 0644);
+MODULE_PARM_DESC(mac_addr, "mac addr");
+#else
+__setup("mac_wifi=", mac_addr_set);
+#endif
+
+static ssize_t wifi_mac_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	int ret;
+	char mac[18];
+
+	if (WIFI_MAC[0] != 0xff)
+		return 0;
+
+	ret = copy_from_user(mac, buf, count);
+	if (ret < 0) {
+		WIFI_INFO("wifi mac write failed\n");
+		return -EFAULT;
+	}
+	mac_addr_set(mac);
+
+	return 0;
+}
+
+u8 *wifi_get_mac(void)
+{
+	return WIFI_MAC;
+}
+EXPORT_SYMBOL(wifi_get_mac);
+
+void aml_wifi_chip(const char *type)
+{
+	memcpy(aml_wifi_chip_type, type, 10);
+}
+EXPORT_SYMBOL(aml_wifi_chip);
+
+void extern_wifi_set_enable(int is_on)
+{
+	if (is_on) {
+		set_wifi_power(1);
+		WIFI_INFO("WIFI  Enable! %d\n", wifi_info.power_on_pin);
+	} else {
+		set_wifi_power(0);
+		WIFI_INFO("WIFI  Disable! %d\n", wifi_info.power_on_pin);
+	}
+}
+EXPORT_SYMBOL(extern_wifi_set_enable);
+
+int wifi_irq_num(void)
+{
+	return wifi_info.irq_num;
+}
+EXPORT_SYMBOL(wifi_irq_num);
+
+int wifi_irq_trigger_level(void)
+{
+	return wifi_info.irq_trigger_type;
+}
+EXPORT_SYMBOL(wifi_irq_trigger_level);
diff --git a/include/linux/amlogic/aml_sd.h b/include/linux/amlogic/aml_sd.h
new file mode 100644
index 000000000..e5f957f3a
--- /dev/null
+++ b/include/linux/amlogic/aml_sd.h
@@ -0,0 +1,543 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __AML_SD_H__
+#define __AML_SD_H__
+
+#include <linux/mmc/card.h>
+#include <linux/interrupt.h>
+/* unknown */
+#define CARD_TYPE_UNKNOWN		0
+/* MMC card */
+#define CARD_TYPE_MMC			1
+/* SD card */
+#define CARD_TYPE_SD			2
+/* SDIO card */
+#define CARD_TYPE_SDIO			3
+/* SD combo (IO+mem) card */
+#define CARD_TYPE_SD_COMBO		4
+/* NON sdio device (means SD/MMC card) */
+#define CARD_TYPE_NON_SDIO		5
+
+#define aml_card_type_unknown(c)	((c)->card_type == CARD_TYPE_UNKNOWN)
+#define aml_card_type_mmc(c)		((c)->card_type == CARD_TYPE_MMC)
+#define aml_card_type_sd(c)		((c)->card_type == CARD_TYPE_SD)
+#define aml_card_type_sdio(c)		((c)->card_type == CARD_TYPE_SDIO)
+#define aml_card_type_non_sdio(c)	((c)->card_type == CARD_TYPE_NON_SDIO)
+
+/* flag is "@ML" */
+#define TUNED_FLAG            0x004C4D40
+/* version is "V1" */
+#define TUNED_VERSION         0x00003156
+/* magic is 0x00487e44 */
+#define TUNED_MAGIC           0x00487e44
+
+#define MMC_DEVICES_NUM 2
+#define MMC_MULT_DEV_SEQ_SD 1
+#define MMC_MULT_DEV_SEQ_SDIO 2
+
+struct mmc_phase {
+	unsigned int core_phase;
+	unsigned int tx_phase;
+	unsigned int rx_phase;
+	unsigned int tx_delay;
+};
+
+struct para_e {
+	struct mmc_phase init;
+	struct mmc_phase hs;
+	struct mmc_phase hs2;
+	struct mmc_phase hs4;
+	struct mmc_phase sdr;
+};
+
+#define LATCHING_RXPHASE 0
+#define LATCHING_TXPHASE 1
+#define LATCHING_FIXADJ 2
+
+struct meson_mmc_data {
+	unsigned int tx_delay_mask;
+	unsigned int rx_delay_mask;
+	unsigned int always_on;
+	unsigned int adjust;
+	u8 latching_mode;
+};
+
+enum aml_host_bus_fsm { /* Host bus fsm status */
+	BUS_FSM_IDLE,           /* 0, idle */
+	BUS_FSM_SND_CMD,        /* 1, send cmd */
+	BUS_FSM_CMD_DONE,       /* 2, wait for cmd done */
+	BUS_FSM_RESP_START,     /* 3, resp start */
+	BUS_FSM_RESP_DONE,      /* 4, wait for resp done */
+	BUS_FSM_DATA_START,     /* 5, data start */
+	BUS_FSM_DATA_DONE,      /* 6, wait for data done */
+	BUS_FSM_DESC_WRITE_BACK,/* 7, wait for desc write back */
+	BUS_FSM_IRQ_SERVICE,    /* 8, wait for irq service */
+};
+
+struct sd_emmc_desc {
+	u32 cmd_cfg;
+	u32 cmd_arg;
+	u32 cmd_data;
+	u32 cmd_resp;
+};
+
+struct meson_mmc_hole {
+	u8 start;
+	u8 size;
+};
+
+struct hs400_para {
+	unsigned int delay1;
+	unsigned int delay2;
+	unsigned int intf3;
+	unsigned int flag;
+};
+
+struct hs200_para {
+	unsigned int adjust;
+};
+
+struct hs_para {
+	unsigned int adjust;
+};
+
+struct aml_tuning_para {
+	unsigned int chip_id[4];
+	unsigned int magic;
+	unsigned int vddee;
+	struct hs400_para hs4[7];
+	struct hs200_para hs2;
+	struct hs_para hs;
+	unsigned int version;
+	unsigned int busmode;
+	unsigned int update;
+	int temperature;
+	long long checksum;
+
+};
+
+struct meson_host {
+	struct	device		*dev;
+	struct	meson_mmc_data *data;
+	struct	mmc_host	*mmc;
+	struct	mmc_command	*cmd;
+	struct delayed_work dtbkey;
+	void __iomem *regs;
+	void __iomem *pin_mux_base;
+	void __iomem *clk_tree_base;
+	struct resource *res[3];
+	struct clk *core_clk;
+	struct clk *tx_clk;
+	struct clk *mmc_clk;
+	struct clk *mux[3];
+	struct clk *mux_div;
+	struct clk *clk[3];
+	unsigned long req_rate;
+	unsigned char timing;
+	bool ddr;
+
+	bool dram_access_quirk;
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_clk_gate;
+
+	unsigned int bounce_buf_size;
+	void *bounce_buf;
+	dma_addr_t bounce_dma_addr;
+	struct sd_emmc_desc *descs;
+	dma_addr_t descs_dma_addr;
+
+	int irq;
+
+	bool vqmmc_enabled;
+	struct para_e sd_mmc;
+	char is_tuning;
+	unsigned int delay_cell;
+	bool needs_pre_post_req;
+	int sd_sdio_switch_volat_done;
+	int irq_sdio_sleep;
+	int sdio_irqen;
+	unsigned int emmc_boot_base;
+	u32 pin_mux_val;
+	u32 clk_tree_val;
+	u32 host_clk_val;
+	int debug_flag;
+	unsigned int card_type;
+	unsigned int card_insert;
+	u8 fixadj_have_hole;
+	struct meson_mmc_hole hole[3];
+	u8 fix_hole;
+	u64 align[10];
+	char cmd_retune;
+	unsigned int win_start;
+	u8 *blk_test;
+	u8 *adj_win;
+	unsigned int cmd_c;
+	int cd_irq;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	int is_uart;
+	int sd_uart_init;
+	int first_temp_index;
+	int cur_temp_index;
+	int compute_cmd_delay;
+	int compute_coef;
+	unsigned int save_para;
+	unsigned int src_clk_rate;
+	struct aml_tuning_para para;
+	int run_pxp_flag;
+	int nwr_cnt;
+	bool auto_clk;
+	bool ignore_desc_busy;
+	bool use_intf3_tuning;
+	bool enable_hwcq;
+	int flags;
+	spinlock_t lock; /* lock for claim and bus ops */
+	bool src_clk_cfg_done;
+	bool tdma;
+	struct dentry *debugfs_root;
+	struct clk *src_clk;
+	unsigned int f_min;
+	unsigned int f_max;
+	struct completion drv_completion;
+};
+
+struct amlsd_platform {
+	struct meson_host *host;
+	struct mmc_host *mmc;
+	struct list_head sibling;
+	struct para_e sd_mmc;
+	u32 ocr_avail;
+	u32 port;
+	u32 debug_flag;
+	unsigned long req_rate;
+	struct clk *src_clk;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_clk_gate;
+	unsigned char timing;
+	bool vqmmc_enabled;
+	bool auto_clk;
+	bool ddr;
+	bool ignore_desc_busy;
+	unsigned int card_insert;
+	int is_uart;
+	unsigned int src_clk_rate;
+	char is_tuning;
+	struct delayed_work cd_detect;
+	unsigned int caps;
+	unsigned int caps2;
+	unsigned int pm_caps;
+	unsigned int card_capacity;
+	unsigned int tx_phase;
+	unsigned int tx_delay;
+	unsigned int runtime;
+	unsigned int save_para;
+	unsigned int co_phase;
+	unsigned int f_min;
+	unsigned int f_max;
+	unsigned int clkc;
+	unsigned int clk2;
+	unsigned int clkc_w;
+	unsigned int ctrl;
+	unsigned int adj;
+	unsigned int dly1;
+	unsigned int dly2;
+	unsigned int intf3;
+	unsigned int win_start;
+	unsigned int irq_sdio_sleep;
+	unsigned int clock;
+	/* signalling voltage (1.8V or 3.3V) */
+	unsigned char signal_voltage;
+	int	bus_width;
+	int	bl_len;
+	int	stop_clk;
+
+	unsigned int irq_cd;
+	unsigned int gpio_cd;
+	unsigned int gpio_cd_level;
+	unsigned int gpio_cd_sta;
+	unsigned int gpio_power;
+	unsigned int power_mode;
+	unsigned int no_sduart;
+	unsigned int scan_val;
+	unsigned int vol_switch;
+	unsigned int vol_switch_18;
+	unsigned int vol_switch_delay;
+	unsigned int gpio_ro;
+	unsigned int gpio_trigger;
+	unsigned int gpio_dat3;
+	unsigned int hw_reset;
+	unsigned int jtag_pin;
+	int is_sduart;
+	unsigned int card_in_delay;
+	bool is_in;
+	/* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD),
+	 * 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card,
+	 * 5:NON sdio device(means sd/mmc card), other:reserved
+	 */
+	unsigned int card_type;
+	unsigned int max_blk_count;
+	unsigned int max_blk_size;
+	unsigned int max_req_size;
+	unsigned int max_seg_size;
+};
+
+struct wifi_clk_table {
+	char m_wifi_name[20];
+	unsigned short m_use_flag;
+	unsigned short m_device_id;
+	unsigned int m_uhs_max_dtr;
+};
+
+enum wifi_clk_table_e {
+	WIFI_CLOCK_TABLE_8822BS = 0,
+	WIFI_CLOCK_TABLE_8822CS = 1,
+	WIFI_CLOCK_TABLE_QCA6174 = 2,
+	WIFI_CLOCK_TABLE_MAX,
+};
+
+void sdio_reinit(void);
+const char *get_wifi_inf(void);
+int sdio_get_vendor(void);
+void aml_host_bus_fsm_show(struct mmc_host *mmc, int status);
+extern struct mmc_host *sdio_host;
+
+#define   DRIVER_NAME "meson-gx-mmc"
+#define   G12A_DRIVER_NAME "meson-g12a-mmc"
+
+#if 0
+#if CONFIG_AMLOGIC_KERNEL_VERSION == 13515
+void mmc_sd_update_cmdline_timing(void *data, struct mmc_card *card, int *err);
+void mmc_sd_update_dataline_timing(void *data, struct mmc_card *card, int *err);
+#define SD_CMD_TIMING mmc_sd_update_cmdline_timing
+#define SD_DATA_TIMING mmc_sd_update_dataline_timing
+#endif
+#endif
+
+#define	  SD_EMMC_CLOCK 0x0
+#define   CLK_DIV_MASK GENMASK(5, 0)
+#define   CLK_SRC_MASK GENMASK(7, 6)
+#define   CLK_CORE_PHASE_MASK GENMASK(9, 8)
+#define   CLK_TX_PHASE_MASK GENMASK(11, 10)
+#define   CLK_RX_PHASE_MASK GENMASK(13, 12)
+#define   CLK_PHASE_0 0
+#define   CLK_PHASE_180 2
+#define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)
+#define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)
+#define   CLK_V2_ALWAYS_ON BIT(24)
+
+#define   CLK_V3_TX_DELAY_MASK GENMASK(21, 16)
+#define   CLK_V3_RX_DELAY_MASK GENMASK(27, 22)
+#define   CLK_V3_ALWAYS_ON BIT(28)
+#define   CFG_IRQ_SDIO_SLEEP BIT(29)
+#define   CFG_IRQ_SDIO_SLEEP_DS BIT(30)
+
+#define   CLK_TX_DELAY_MASK(h)    ((h)->data->tx_delay_mask)
+#define   CLK_RX_DELAY_MASK(h)    ((h)->data->rx_delay_mask)
+#define   CLK_ALWAYS_ON(h)        ((h)->data->always_on)
+
+#define SD_EMMC_DELAY 0x4
+
+#define SD_EMMC_ADJUST 0x8
+#define   ADJUST_ADJ_DELAY_MASK GENMASK(21, 16)
+#define   ADJUST_DS_EN BIT(15)
+#define   ADJUST_ADJ_EN BIT(13)
+
+#define SD_EMMC_DELAY1 0x4
+#define SD_EMMC_DELAY2 0x8
+#define SD_EMMC_V3_ADJUST 0xc
+#define	  CALI_SEL_MASK GENMASK(11, 8)
+#define	  CALI_ENABLE BIT(12)
+#define	  CFG_ADJUST_ENABLE BIT(13)
+#define	  CALI_RISE BIT(14)
+#define	  DS_ENABLE BIT(15)
+#define	  CLK_ADJUST_DELAY GENMASK(21, 16)
+#define	  ADJ_AUTO BIT(22)
+
+#define SD_EMMC_CALOUT 0x10
+#define SD_EMMC_ADJ_IDX_LOG 0x20
+#define SD_EMMC_CLKTEST_LOG 0x24
+#define   CLKTEST_TIMES_MASK GENMASK(30, 0)
+#define   CLKTEST_DONE BIT(31)
+#define SD_EMMC_CLKTEST_OUT 0x28
+#define SD_EMMC_EYETEST_LOG 0x2c
+#define   EYETEST_TIMES_MASK GENMASK(30, 0)
+#define   EYETEST_DONE BIT(31)
+#define SD_EMMC_EYETEST_OUT0 0x30
+#define SD_EMMC_EYETEST_OUT1 0x34
+#define SD_EMMC_INTF3 0x38
+#define   CLKTEST_EXP_MASK GENMASK(4, 0)
+#define   CLKTEST_ON_M BIT(5)
+#define   EYETEST_EXP_MASK GENMASK(10, 6)
+#define   EYETEST_ON BIT(11)
+#define   DS_SHT_M_MASK GENMASK(17, 12)
+#define   DS_SHT_EXP_MASK GENMASK(21, 18)
+#define   SD_INTF3 BIT(22)
+
+#define   EYETEST_SEL BIT(26)
+#define   RESP_SEL BIT(27)
+#define   CFG_RX_SEL BIT(26)
+#define   CFG_RX_PN BIT(27)
+#define   RESP_OLD BIT(28)
+#define   RESP_PN BIT(29)
+#define   RESP_DS BIT(30)
+
+#define SD_EMMC_START 0x40
+#define   START_DESC_INIT BIT(0)
+#define   START_DESC_BUSY BIT(1)
+#define   START_DESC_ADDR_MASK GENMASK(31, 2)
+
+#define SD_EMMC_CFG 0x44
+#define   CFG_BUS_WIDTH_MASK GENMASK(1, 0)
+#define   CFG_BUS_WIDTH_1 0x0
+#define   CFG_BUS_WIDTH_4 0x1
+#define   CFG_BUS_WIDTH_8 0x2
+#define   CFG_DDR BIT(2)
+#define   CFG_BLK_LEN_MASK GENMASK(7, 4)
+#define   CFG_RESP_TIMEOUT_MASK GENMASK(11, 8)
+#define   CFG_RC_CC_MASK GENMASK(15, 12)
+#define   CFG_STOP_CLOCK BIT(22)
+#define   CFG_CLK_ALWAYS_ON BIT(18)
+#define   CFG_CHK_DS BIT(20)
+#define   CFG_AUTO_CLK BIT(23)
+#define   CFG_ERR_ABORT BIT(27)
+
+#define SD_EMMC_STATUS 0x48
+#define   STATUS_BUSY BIT(31)
+#define   STATUS_DESC_BUSY BIT(30)
+#define   STATUS_DATI GENMASK(23, 16)
+
+#define SD_EMMC_IRQ_EN 0x4c
+#define   IRQ_RXD_ERR_MASK GENMASK(7, 0)
+#define   IRQ_TXD_ERR BIT(8)
+#define   IRQ_DESC_ERR BIT(9)
+#define   IRQ_RESP_ERR BIT(10)
+#define   IRQ_CRC_ERR \
+	(IRQ_RXD_ERR_MASK | IRQ_TXD_ERR | IRQ_DESC_ERR | IRQ_RESP_ERR)
+#define   IRQ_RESP_TIMEOUT BIT(11)
+#define   IRQ_DESC_TIMEOUT BIT(12)
+#define   IRQ_TIMEOUTS \
+	(IRQ_RESP_TIMEOUT | IRQ_DESC_TIMEOUT)
+#define   IRQ_END_OF_CHAIN BIT(13)
+#define   IRQ_RESP_STATUS BIT(14)
+#define   IRQ_SDIO BIT(15)
+#define   CFG_CMD_SETUP BIT(17)
+#define   BUS_FSM_MASK GENMASK(29, 26)
+#define   IRQ_EN_MASK \
+	(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN | IRQ_RESP_STATUS |\
+	 IRQ_SDIO)
+
+#define SD_EMMC_CMD_CFG 0x50
+#define SD_EMMC_CMD_ARG 0x54
+#define SD_EMMC_CMD_DAT 0x58
+#define SD_EMMC_CMD_RSP 0x5c
+#define SD_EMMC_CMD_RSP1 0x60
+#define SD_EMMC_CMD_RSP2 0x64
+#define SD_EMMC_CMD_RSP3 0x68
+
+#define SD_EMMC_RXD 0x94
+#define SD_EMMC_TXD 0x94
+#define SD_EMMC_LAST_REG SD_EMMC_TXD
+
+#define SD_EMMC_SRAM_DESC_BUF_OFF 0x200
+#define SD_EMMC_SRAM_DATA_BUF_LEN 1024
+#define SD_EMMC_SRAM_DATA_BUF_OFF 0x400
+#define SD_EMMC_MAX_SEGS 256
+#define SD_EMMC_MAX_REQ_SIZE (128 * 1024)
+#define SD_EMMC_MAX_SEG_SIZE (64 * 1024)
+
+#define SD_EMMC_CFG_BLK_SIZE 512 /* internal buffer max: 512 bytes */
+#define SD_EMMC_CFG_RESP_TIMEOUT 256 /* in clock cycles */
+#define SD_EMMC_CMD_TIMEOUT 1024 /* in ms */
+#define SD_EMMC_CMD_TIMEOUT_DATA 4096 /* in ms */
+#define SD_EMMC_CFG_CMD_GAP 16 /* in clock cycles */
+#define SD_EMMC_DESC_BUF_LEN (2 * PAGE_SIZE)
+
+#define SD_EMMC_PRE_REQ_DONE BIT(0)
+#define SD_EMMC_DESC_CHAIN_MODE BIT(1)
+
+#define MUX_CLK_NUM_PARENTS 2
+
+#define CMD_CFG_LENGTH_MASK GENMASK(8, 0)
+#define CMD_CFG_BLOCK_MODE BIT(9)
+#define CMD_CFG_R1B BIT(10)
+#define CMD_CFG_END_OF_CHAIN BIT(11)
+#define CMD_CFG_TIMEOUT_MASK GENMASK(15, 12)
+#define CMD_CFG_NO_RESP BIT(16)
+#define CMD_CFG_NO_CMD BIT(17)
+#define CMD_CFG_DATA_IO BIT(18)
+#define CMD_CFG_DATA_WR BIT(19)
+#define CMD_CFG_RESP_NOCRC BIT(20)
+#define CMD_CFG_RESP_128 BIT(21)
+#define CMD_CFG_RESP_NUM BIT(22)
+#define CMD_CFG_DATA_NUM BIT(23)
+#define CMD_CFG_CMD_INDEX_MASK GENMASK(29, 24)
+#define CMD_CFG_ERROR BIT(30)
+#define CMD_CFG_OWNER BIT(31)
+
+#define CMD_DATA_MASK GENMASK(31, 2)
+#define CMD_DATA_BIG_ENDIAN BIT(1)
+#define CMD_DATA_SRAM BIT(0)
+#define CMD_RESP_MASK GENMASK(31, 1)
+#define CMD_RESP_SRAM BIT(0)
+#define EMMC_SDIO_CLOCK_FELD    0Xffff
+#define CALI_HS_50M_ADJUST      0
+#define ERROR   1
+#define FIXED   2
+#define		SZ_1M			0x00100000
+#define	MMC_PATTERN_NAME		"pattern"
+#define	MMC_PATTERN_OFFSET		((SZ_1M * (36 + 3)) / 512)
+#define	MMC_MAGIC_NAME			"magic"
+#define	MMC_MAGIC_OFFSET		((SZ_1M * (36 + 6)) / 512)
+#define	MMC_RANDOM_NAME			"random"
+#define	MMC_RANDOM_OFFSET		((SZ_1M * (36 + 7)) / 512)
+#define	MMC_DTB_NAME			"dtb"
+#define	MMC_DTB_OFFSET			((SZ_1M * (36 + 4)) / 512)
+#define CALI_BLK_CNT	80
+#define CALI_HS_50M_ADJUST	0
+#define EMMC_SDIO_CLOCK_FELD	0Xffff
+#define MMC_PM_TIMEOUT	(2000)
+#define ERROR	1
+#define FIXED	2
+#define RETUNING	3
+#define	DATA3_PINMUX_MASK GENMASK(15, 12)
+
+#define TUNING_NUM_PER_POINT 40
+#define MAX_TUNING_RETRY 4
+#define AML_FIXED_ADJ_MAX 6
+#define AML_FIXED_ADJ_MIN 5
+#define AML_FIXADJ_STEP 4
+#define ADJ_WIN_PRINT_MAXLEN 256
+#define NO_FIXED_ADJ_MID BIT(31)
+#define AML_MV_DLY2_NOMMC_CMD(x) ((x) << 24)
+
+#define SD_EMMC_FIXED_ADJ_HS200
+#define EMMC_CMD_WIN_MAX_SIZE	50
+#define EMMC_CMD_WIN_FULL_SIZE	64
+
+#define DBG_COMMON        BIT(0)
+#define DBG_HS200         BIT(1)
+#define Print_dbg(dbg_level, fmt, args...) do {\
+		if ((dbg_level) & mmc_debug)	\
+			pr_info("[%s]" fmt, __func__, ##args);	\
+} while (0)
+
+/* delay_cell=70ps,1ns/delay_cell */
+#define DELAY_CELL_COUNTS 14
+
+/* emmc partition */
+#define MMC_TUNING_OFFSET				0X14400
+
+#define RESULT_OK                       0
+#define RESULT_FAIL                     1
+#define RESULT_UNSUP_HOST               2
+#define RESULT_UNSUP_CARD               3
+
+/* Host attributes */
+#define AML_USE_64BIT_DMA        BIT(0)
+
+#endif /*__AML_SD_H__*/
+
diff --git a/include/linux/amlogic/cpu_version.h b/include/linux/amlogic/cpu_version.h
new file mode 100644
index 000000000..4f33c80a8
--- /dev/null
+++ b/include/linux/amlogic/cpu_version.h
@@ -0,0 +1,6 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/amlogic/media/registers/cpu_version.h>
diff --git a/include/linux/amlogic/dhd_buf.h b/include/linux/amlogic/dhd_buf.h
new file mode 100644
index 000000000..8b6ab9c74
--- /dev/null
+++ b/include/linux/amlogic/dhd_buf.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _BCMDHD_BUF_H
+#define _BCMDHD_BUF_H
+int bcmdhd_init_wlan_mem(unsigned int all_buf);
+#endif
diff --git a/include/linux/amlogic/gki_module.h b/include/linux/amlogic/gki_module.h
new file mode 100644
index 000000000..10c65cfaa
--- /dev/null
+++ b/include/linux/amlogic/gki_module.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __GKI_MODULE_AMLOGIC_H
+#define __GKI_MODULE_AMLOGIC_H
+
+#define GKI_MODULE_SETUP_MAGIC1 0x014589cd
+#define GKI_MODULE_SETUP_MAGIC2 0x2367abef
+
+struct gki_module_setup_struct {
+	/* must be first */
+	int magic1;
+	int magic2;
+
+	char *str;
+	void *fn;
+	int early;
+};
+
+struct cmd_param_val {
+	char *param;
+	char *val;
+};
+
+extern struct cmd_param_val *cpv;
+extern int cpv_count;
+
+#define __setup_gki_module(str, fn, early)			\
+	struct gki_module_setup_struct __gki_setup_##fn =        \
+		   {GKI_MODULE_SETUP_MAGIC1, GKI_MODULE_SETUP_MAGIC2,    \
+		   str, fn, early};                                     \
+	EXPORT_SYMBOL(__gki_setup_##fn)
+
+#ifdef MODULE
+
+#undef __setup
+#undef __setup_param
+#undef early_param
+
+#define __setup(str, fn)						\
+		__setup_gki_module(str, fn, 0)
+
+#define early_param(str, fn)						\
+		__setup_gki_module(str, fn, 1)
+void __module_init_hook(struct module *m);
+
+#define module_init_hook(initfn)      \
+	int __init init_module(void) \
+	{       \
+		__module_init_hook(THIS_MODULE); \
+		return initfn();     \
+	}	\
+	___ADDRESSABLE(init_module, __initdata);
+
+#undef early_initcall
+#undef core_initcall
+#undef core_initcall_sync
+#undef postcore_initcall
+#undef postcore_initcall_sync
+#undef arch_initcall
+#undef subsys_initcall
+#undef subsys_initcall_sync
+#undef fs_initcall
+#undef fs_initcall_sync
+#undef rootfs_initcall
+#undef device_initcall
+#undef device_initcall_sync
+#undef late_initcall
+#undef late_initcall_sync
+#undef console_initcall
+#undef security_initcall
+
+#define early_initcall(fn)		module_init_hook(fn)
+#define core_initcall(fn)		module_init_hook(fn)
+#define core_initcall_sync(fn)		module_init_hook(fn)
+#define postcore_initcall(fn)		module_init_hook(fn)
+#define postcore_initcall_sync(fn)	module_init_hook(fn)
+#define arch_initcall(fn)		module_init_hook(fn)
+#define subsys_initcall(fn)		module_init_hook(fn)
+#define subsys_initcall_sync(fn)	module_init_hook(fn)
+#define fs_initcall(fn)			module_init_hook(fn)
+#define fs_initcall_sync(fn)		module_init_hook(fn)
+#define rootfs_initcall(fn)		module_init_hook(fn)
+#define device_initcall(fn)		module_init_hook(fn)
+#define device_initcall_sync(fn)	module_init_hook(fn)
+#define late_initcall(fn)		module_init_hook(fn)
+#define late_initcall_sync(fn)		module_init_hook(fn)
+#define console_initcall(fn)		module_init_hook(fn)
+#define security_initcall(fn)		module_init_hook(fn)
+
+#undef module_init
+#define module_init(fn)			module_init_hook(fn)
+
+#endif //MODULE
+
+#endif //__GKI_MODULE_AMLOGIC_H
diff --git a/include/linux/amlogic/key_manage.h b/include/linux/amlogic/key_manage.h
new file mode 100644
index 000000000..e3f4def82
--- /dev/null
+++ b/include/linux/amlogic/key_manage.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __KEYMANAGE__
+#define __KEYMANAGE__
+
+enum {
+	UNIFYKEY_STORAGE_TYPE_INVALID = 0,
+	UNIFYKEY_STORAGE_TYPE_EMMC,
+	UNIFYKEY_STORAGE_TYPE_NAND,
+	UNIFYKEY_STORAGE_TYPE_MAX
+};
+
+struct unifykey_storage_ops {
+	s32 (*read)(u8 *buf, u32 len, u32 *actual_len);
+	s32 (*write)(u8 *buf, u32 len, u32 *actual_len);
+};
+
+struct unifykey_type {
+	u32 storage_type;
+	struct unifykey_storage_ops *ops;
+};
+
+// int register_unifykey_types(struct unifykey_type *uk_type);
+// void auto_attach(void);
+
+#endif /*__KEYMANAGE__*/
diff --git a/include/linux/amlogic/media/registers/cpu_version.h b/include/linux/amlogic/media/registers/cpu_version.h
new file mode 100644
index 000000000..f62202823
--- /dev/null
+++ b/include/linux/amlogic/media/registers/cpu_version.h
@@ -0,0 +1,346 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __REGISTERS_MESON_CPU_H
+#define __REGISTERS_MESON_CPU_H
+
+#define MESON_CPU_TYPE_MESON1		0x10
+#define MESON_CPU_TYPE_MESON2		0x20
+#define MESON_CPU_TYPE_MESON3		0x30
+#define MESON_CPU_TYPE_MESON6		0x60
+#define MESON_CPU_TYPE_MESON6TV		0x70
+#define MESON_CPU_TYPE_MESON6TVD	0x75
+#define MESON_CPU_TYPE_MESON8		0x80
+#define MESON_CPU_TYPE_MESON8B		0x8B
+#define MESON_CPU_TYPE_MESONG9TV	0x90
+
+/*
+ *	Read back value for P_ASSIST_HW_REV
+ *
+ *	Please note: M8M2 readback value same as M8 (0x19)
+ *			     We changed it to 0x1D in software,
+ *			     Please ALWAYS use get_meson_cpu_version()
+ *			     to get the version of Meson CPU
+ */
+#define MESON_CPU_MAJOR_ID_M6		0x16
+#define MESON_CPU_MAJOR_ID_M6TV		0x17
+#define MESON_CPU_MAJOR_ID_M6TVL	0x18
+#define MESON_CPU_MAJOR_ID_M8		0x19
+#define MESON_CPU_MAJOR_ID_MTVD		0x1A
+#define MESON_CPU_MAJOR_ID_MG9TV	0x1C
+#define MESON_CPU_MAJOR_ID_M8M2		0x1D
+
+#define MESON_CPU_VERSION_LVL_PACK	2
+
+enum meson_cpuid_type_e {
+	MESON_CPU_MAJOR_ID_M8B = 0x1B,
+	MESON_CPU_MAJOR_ID_GXBB = 0x1F,
+	MESON_CPU_MAJOR_ID_GXTVBB,
+	MESON_CPU_MAJOR_ID_GXL,
+	MESON_CPU_MAJOR_ID_GXM,
+	MESON_CPU_MAJOR_ID_TXL,
+	MESON_CPU_MAJOR_ID_TXLX,
+	MESON_CPU_MAJOR_ID_AXG,
+	MESON_CPU_MAJOR_ID_GXLX,
+	MESON_CPU_MAJOR_ID_TXHD,
+	MESON_CPU_MAJOR_ID_G12A,
+	MESON_CPU_MAJOR_ID_G12B,
+	MESON_CPU_MAJOR_ID_SM1 = 0x2B,
+	MESON_CPU_MAJOR_ID_TL1 = 0x2E,
+	MESON_CPU_MAJOR_ID_TM2,
+	MESON_CPU_MAJOR_ID_C1,
+	MESON_CPU_MAJOR_ID_SC2 = 0x32,
+	MESON_CPU_MAJOR_ID_C2 = 0x33,
+	MESON_CPU_MAJOR_ID_T5 = 0x34,
+	MESON_CPU_MAJOR_ID_T5D = 0x35,
+	MESON_CPU_MAJOR_ID_T7 = 0x36,
+	MESON_CPU_MAJOR_ID_S4 = 0x37,
+	MESON_CPU_MAJOR_ID_T3 = 0x38,
+	MESON_CPU_MAJOR_ID_S4D = 0x3a,
+	MESON_CPU_MAJOR_ID_T5W = 0x3b,
+	MESON_CPU_MAJOR_ID_C3 = 0x3c,
+	MESON_CPU_MAJOR_ID_A4 = 0x40,
+	MESON_CPU_MAJOR_ID_S5 = 0x3e,
+	MESON_CPU_MAJOR_ID_T5M = 0x41,
+	MESON_CPU_MAJOR_ID_T3X = 0x42,
+	MESON_CPU_MAJOR_ID_TXHD2 = 0x44,
+	MESON_CPU_MAJOR_ID_S1A = 0x45,
+	MESON_CPU_MAJOR_ID_UNKNOWN,
+};
+
+#define MESON_CPU_VERSION_LVL_MAJOR	0
+#define MESON_CPU_VERSION_LVL_MINOR	1
+#define MESON_CPU_VERSION_LVL_PACK	2
+#define MESON_CPU_VERSION_LVL_MISC	3
+#define MESON_CPU_VERSION_LVL_MAX	MESON_CPU_VERSION_LVL_MISC
+
+struct codecio_device_data_s {
+	enum meson_cpuid_type_e cpu_id;
+};
+
+int get_cpu_type_from_media(void);
+
+unsigned char get_meson_cpu_version(int level);
+
+static inline int get_cpu_type(void)
+{
+	int cpu_id_from_media = 0;
+
+	cpu_id_from_media = get_cpu_type_from_media();
+	if (cpu_id_from_media)
+		return cpu_id_from_media;
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+
+static inline u32 get_cpu_package(void)
+{
+	unsigned int pk;
+
+	pk = get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0;
+	return pk;
+}
+
+static inline bool package_id_is(unsigned int id)
+{
+	return get_cpu_package() == id;
+}
+
+static inline bool is_meson_m8_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8;
+}
+
+static inline bool is_meson_mtvd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MTVD;
+}
+
+static inline bool is_meson_m8m2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8M2;
+}
+
+static inline bool is_meson_g9tv_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_MG9TV;
+}
+
+/* new added*/
+static inline bool is_meson_m8b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8B;
+}
+
+static inline bool is_meson_gxbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB;
+}
+
+static inline bool is_meson_gxtvbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB;
+}
+
+static inline bool is_meson_gxl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXL;
+}
+
+static inline bool is_meson_gxl_package_905D(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x0);
+}
+
+static inline bool is_meson_gxl_package_905X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x80);
+}
+
+static inline bool is_meson_gxl_package_905L(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xc0);
+}
+
+static inline bool is_meson_gxl_package_905M2(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xe0);
+}
+
+static inline bool is_meson_gxl_package_805X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x30);
+}
+
+static inline bool is_meson_gxl_package_805Y(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xb0);
+}
+
+static inline bool is_meson_gxm_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXM;
+}
+
+static inline bool is_meson_txl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXL;
+}
+
+static inline bool is_meson_txlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXLX;
+}
+
+static inline bool is_meson_axg_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_AXG;
+}
+
+static inline bool is_meson_gxlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXLX;
+}
+
+static inline bool is_meson_txhd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXHD;
+}
+
+static inline bool is_meson_g12a_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12A;
+}
+
+static inline bool is_meson_g12b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12B;
+}
+
+static inline bool is_meson_sm1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SM1;
+}
+
+static inline bool is_meson_tl1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TL1;
+}
+
+static inline bool is_meson_tm2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TM2;
+}
+
+static inline bool is_meson_c1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_C1;
+}
+
+static inline bool is_meson_sc2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SC2;
+}
+
+static inline bool is_meson_t5_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5;
+}
+
+static inline bool is_meson_t5d_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5D;
+}
+
+static inline bool is_meson_t7_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T7;
+}
+
+static inline bool is_meson_s4_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S4;
+}
+
+static inline bool is_meson_t3_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T3;
+}
+
+static inline bool is_meson_s4d_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S4D;
+}
+
+static inline bool is_meson_t5w_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5W;
+}
+
+static inline bool is_meson_c3_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_C3;
+}
+
+static inline bool is_meson_a4_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_A4;
+}
+
+static inline bool is_meson_s5_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S5;
+}
+
+static inline bool is_meson_t5m_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T5M;
+}
+
+static inline bool is_meson_t3x_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_T3X;
+}
+
+static inline bool is_meson_txhd2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXHD2;
+}
+
+static inline bool is_meson_s1a_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_S1A;
+}
+
+static inline bool cpu_after_eq(unsigned int id)
+{
+	return get_cpu_type() >= id;
+}
+
+static inline bool is_meson_txlx_package_962X(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x10);
+}
+
+static inline bool is_meson_txlx_package_962E(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_rev_a(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xA);
+}
+
+static inline bool is_meson_rev_b(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xB);
+}
+
+static inline bool is_meson_rev_c(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xC);
+}
+
+#endif
diff --git a/include/linux/amlogic/module_merge.h b/include/linux/amlogic/module_merge.h
new file mode 100644
index 000000000..5500f4194
--- /dev/null
+++ b/include/linux/amlogic/module_merge.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _MODULE_MERGE_H_
+#define _MODULE_MERGE_H_
+
+#include <linux/amlogic/gki_module.h>
+
+#define call_sub_init(func) \
+{ \
+	int ret = 0; \
+	ret = func(); \
+	if (ret < 0) \
+		pr_err("call %s() ret=%d\n", #func, ret); \
+	else \
+		pr_debug("call %s() success\n", #func); \
+}
+
+#endif /* _MODULE_MERGE_H_ */
diff --git a/include/linux/amlogic/pm.h b/include/linux/amlogic/pm.h
new file mode 100644
index 000000000..9fb960aff
--- /dev/null
+++ b/include/linux/amlogic/pm.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __AML_PM_H__
+#define __AML_PM_H__
+#include <linux/notifier.h>
+
+/* wake up reason*/
+#define	UNDEFINED_WAKEUP		0
+#define	CHARGING_WAKEUP		1
+#define	REMOTE_WAKEUP		2
+#define	RTC_WAKEUP		3
+#define	BT_WAKEUP		4
+#define	WIFI_WAKEUP		5
+#define	POWER_KEY_WAKEUP	6
+#define	AUTO_WAKEUP		7
+#define	CEC_WAKEUP		8
+#define	REMOTE_CUS_WAKEUP	9
+#define ETH_PHY_WAKEUP		10
+#define	CECB_WAKEUP	11
+#define	ETH_PHY_GPIO	12
+#define	VAD_WAKEUP	13
+#define HDMI_RX_WAKEUP	14
+
+#if IS_ENABLED(CONFIG_AMLOGIC_GX_SUSPEND)
+unsigned int get_resume_method(void);
+unsigned int get_resume_reason(void);
+unsigned int is_pm_s2idle_mode(void);
+#else
+static inline unsigned int get_resume_method(void)
+{
+	return 0;
+}
+
+static inline unsigned int get_resume_reason(void)
+{
+	return 0;
+}
+
+static inline unsigned int is_pm_s2idle_mode(void)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+
+struct early_suspend {
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+	void *param;
+};
+
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+unsigned int lgcy_early_suspend_init(struct platform_device *pdev);
+
+#endif //CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+
+#ifdef CONFIG_AMLOGIC_M8B_SUSPEND
+/*l2c virtual addr*/
+#define IO_PL310_BASE 0xfe000000
+
+/*IR, power key, low power,
+ *adapter plug in/out and so on,
+ *are all use this flag.
+ */
+#define FLAG_WAKEUP_PWRKEY		0x1234abcd
+#define FLAG_WAKEUP_ALARM		0x12345678
+#define FLAG_WAKEUP_WIFI		0x12340001
+#define FLAG_WAKEUP_BT			0x12340002
+#define FLAG_WAKEUP_PWROFF		0x12340003
+
+/*AOBUS*/
+#define AO_RTI_STATUS_REG2 0x0008
+#define AO_RTC_ADDR0 0x0740
+#define AO_RTC_ADDR1 0x0744
+#define AO_RTC_ADDR2 0x0748
+#define AO_RTC_ADDR3 0x074c
+#define AO_UART_STATUS 0x04cc
+#define AO_UART_REG5   0x04d4
+
+/*CBUS*/
+#define HHI_SYS_PLL_CNTL  0x10c0
+#define HHI_MPEG_CLK_CNTL 0x105d
+
+#endif //CONFIG_AMLOGIC_M8B_SUSPEND
+
+#endif //__AML_PM_H__
diff --git a/include/linux/amlogic/wifi_dt.h b/include/linux/amlogic/wifi_dt.h
new file mode 100644
index 000000000..3d3418924
--- /dev/null
+++ b/include/linux/amlogic/wifi_dt.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _wifi_dt_h_
+#define _wifi_dt_h_
+
+void extern_wifi_set_enable(int is_on);
+int wifi_irq_num(void);
+void set_usb_bt_power(int is_power);
+void aml_wifi_chip(const char *type);
+
+#ifdef CONFIG_PCI
+/*amlogic 4.9 kernel support pci interface wifi*/
+void pci_lock_rescan_remove(void);
+struct pci_bus *pci_find_next_bus(const struct pci_bus *from);
+unsigned int pci_rescan_bus(struct pci_bus *bus);
+void pci_unlock_rescan_remove(void);
+struct pci_dev *pci_get_device(unsigned int vendor, unsigned int device,
+			       struct pci_dev *from);
+void pci_stop_and_remove_bus_device_locked(struct pci_dev *dev);
+#endif
+
+#endif /* _wifi_dt_h_ */
-- 
2.34.1

